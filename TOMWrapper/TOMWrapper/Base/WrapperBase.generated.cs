
// Code generated by a template
using System;
using System.Linq;
using System.Collections.Generic;
using System.ComponentModel;
using TabularEditor.PropertyGridUI;
using TabularEditor.PropertyGridUI.Converters;
using TabularEditor.TOMWrapper.Undo;
using System.Drawing.Design;
using TOM = Microsoft.AnalysisServices.Tabular;

namespace TabularEditor.TOMWrapper
{
    internal static partial class Properties
    {
	    public const string ACCOUNT = "Account";
	    public const string ALIGNMENT = "Alignment";
	    public const string ALTERNATEOF = "AlternateOf";
	    public const string ALTERNATESOURCEPRECEDENCE = "AlternateSourcePrecedence";
	    public const string ANALYTICSAIMETADATA = "AnalyticsAIMetadata";
	    public const string ANNOTATIONS = "Annotations";
	    public const string ATTRIBUTEHIERARCHY = "AttributeHierarchy";
	    public const string AUTOMATICAGGREGATIONOPTIONS = "AutomaticAggregationOptions";
	    public const string BASECOLUMN = "BaseColumn";
	    public const string BASETABLE = "BaseTable";
	    public const string CALCULATIONGROUP = "CalculationGroup";
	    public const string CALCULATIONITEMS = "CalculationItems";
	    public const string COLLATION = "Collation";
	    public const string COLUMN = "Column";
	    public const string COLUMNORIGIN = "ColumnOrigin";
	    public const string COLUMNPERMISSIONS = "ColumnPermissions";
	    public const string COLUMNS = "Columns";
	    public const string CONNECTIONDETAILS = "ConnectionDetails";
	    public const string CONNECTIONSTRING = "ConnectionString";
	    public const string CONTEXTEXPRESSION = "ContextExpression";
	    public const string CREDENTIAL = "Credential";
	    public const string CROSSFILTERINGBEHAVIOR = "CrossFilteringBehavior";
	    public const string CULTURE = "Culture";
	    public const string CULTURES = "Cultures";
	    public const string DATAACCESSOPTIONS = "DataAccessOptions";
	    public const string DATABASE = "Database";
	    public const string DATACATEGORY = "DataCategory";
	    public const string DATASOURCEDEFAULTMAXCONNECTIONS = "DataSourceDefaultMaxConnections";
	    public const string DATASOURCES = "DataSources";
	    public const string DATASOURCEVARIABLESOVERRIDEBEHAVIOR = "DataSourceVariablesOverrideBehavior";
	    public const string DATATYPE = "DataType";
	    public const string DATAVIEW = "DataView";
	    public const string DEFAULTCOLUMN = "DefaultColumn";
	    public const string DEFAULTDATAVIEW = "DefaultDataView";
	    public const string DEFAULTDETAILROWSDEFINITION = "DefaultDetailRowsDefinition";
	    public const string DEFAULTHIERARCHY = "DefaultHierarchy";
	    public const string DEFAULTMEASURE = "DefaultMeasure";
	    public const string DEFAULTMODE = "DefaultMode";
	    public const string DEFAULTPOWERBIDATASOURCEVERSION = "DefaultPowerBIDataSourceVersion";
	    public const string DESCRIPTION = "Description";
	    public const string DETAILROWSDEFINITION = "DetailRowsDefinition";
	    public const string DISCOURAGECOMPOSITEMODELS = "DiscourageCompositeModels";
	    public const string DISCOURAGEIMPLICITMEASURES = "DiscourageImplicitMeasures";
	    public const string DISCOURAGEREPORTMEASURES = "DiscourageReportMeasures";
	    public const string DISPLAYFOLDER = "DisplayFolder";
	    public const string DISPLAYORDINAL = "DisplayOrdinal";
	    public const string ENCODINGHINT = "EncodingHint";
	    public const string ERRORMESSAGE = "ErrorMessage";
	    public const string EXCLUDEFROMMODELREFRESH = "ExcludeFromModelRefresh";
	    public const string EXPRESSION = "Expression";
	    public const string EXPRESSIONS = "Expressions";
	    public const string EXTENDEDPROPERTIES = "ExtendedProperties";
	    public const string FILTEREXPRESSION = "FilterExpression";
	    public const string FORCEUNIQUENAMES = "ForceUniqueNames";
	    public const string FORMATSTRING = "FormatString";
	    public const string FORMATSTRINGDEFINITION = "FormatStringDefinition";
	    public const string FROMCARDINALITY = "FromCardinality";
	    public const string FROMCOLUMN = "FromColumn";
	    public const string FROMTABLE = "FromTable";
	    public const string HASLOCALCHANGES = "HasLocalChanges";
	    public const string HIDEMEMBERS = "HideMembers";
	    public const string HIERARCHIES = "Hierarchies";
	    public const string HIERARCHY = "Hierarchy";
	    public const string IDENTITYPROVIDER = "IdentityProvider";
	    public const string IMPERSONATIONMODE = "ImpersonationMode";
	    public const string INPERSPECTIVE = "InPerspective";
	    public const string ISACTIVE = "IsActive";
	    public const string ISAVAILABLEINMDX = "IsAvailableInMDX";
	    public const string ISDATATYPEINFERRED = "IsDataTypeInferred";
	    public const string ISDEFAULT = "IsDefault";
	    public const string ISDEFAULTIMAGE = "IsDefaultImage";
	    public const string ISDEFAULTLABEL = "IsDefaultLabel";
	    public const string ISDYNAMIC = "IsDynamic";
	    public const string ISHIDDEN = "IsHidden";
	    public const string ISKEY = "IsKey";
	    public const string ISNAMEINFERRED = "IsNameInferred";
	    public const string ISNULLABLE = "IsNullable";
	    public const string ISOLATION = "Isolation";
	    public const string ISPRIVATE = "IsPrivate";
	    public const string ISSIMPLEMEASURE = "IsSimpleMeasure";
	    public const string ISUNIQUE = "IsUnique";
	    public const string JOINONDATEBEHAVIOR = "JoinOnDateBehavior";
	    public const string KEEPUNIQUEROWS = "KeepUniqueRows";
	    public const string KIND = "Kind";
	    public const string KPI = "KPI";
	    public const string LEVELS = "Levels";
	    public const string LINEAGETAG = "LineageTag";
	    public const string LINGUISTICMETADATA = "LinguisticMetadata";
	    public const string MATTRIBUTES = "MAttributes";
	    public const string MAXCONNECTIONS = "MaxConnections";
	    public const string MEASURE = "Measure";
	    public const string MEASURES = "Measures";
	    public const string MEMBERID = "MemberID";
	    public const string MEMBERNAME = "MemberName";
	    public const string MEMBERS = "Members";
	    public const string MEMBERTYPE = "MemberType";
	    public const string METADATAPERMISSION = "MetadataPermission";
	    public const string MODE = "Mode";
	    public const string MODELPERMISSION = "ModelPermission";
	    public const string MODIFIEDTIME = "ModifiedTime";
	    public const string NAME = "Name";
	    public const string OBJECTTRANSLATIONS = "ObjectTranslations";
	    public const string OBJECTTYPE = "ObjectType";
	    public const string OPTIONS = "Options";
	    public const string ORDINAL = "Ordinal";
	    public const string PARAMETERVALUESCOLUMN = "ParameterValuesColumn";
	    public const string PARENT = "Parent";
	    public const string PARTITIONS = "Partitions";
	    public const string PASSWORD = "Password";
	    public const string PERSPECTIVES = "Perspectives";
	    public const string PERSPECTIVETABLES = "PerspectiveTables";
	    public const string PRECEDENCE = "Precedence";
	    public const string PROVIDER = "Provider";
	    public const string QUERYGROUP = "QueryGroup";
	    public const string QUERYGROUPS = "QueryGroups";
	    public const string REFRESHEDTIME = "RefreshedTime";
	    public const string REFRESHPOLICY = "RefreshPolicy";
	    public const string RELATEDCOLUMNDETAILS = "RelatedColumnDetails";
	    public const string RELATIONSHIP = "Relationship";
	    public const string RELATIONSHIPS = "Relationships";
	    public const string RELYONREFERENTIALINTEGRITY = "RelyOnReferentialIntegrity";
	    public const string RETAINDATATILLFORCECALCULATE = "RetainDataTillForceCalculate";
	    public const string ROLE = "Role";
	    public const string ROLES = "Roles";
	    public const string SECURITYFILTERINGBEHAVIOR = "SecurityFilteringBehavior";
	    public const string SERVER = "Server";
	    public const string SETS = "Sets";
	    public const string SHOWASVARIATIONSONLY = "ShowAsVariationsOnly";
	    public const string SORTBYCOLUMN = "SortByColumn";
	    public const string SOURCE = "Source";
	    public const string SOURCECOLUMN = "SourceColumn";
	    public const string SOURCELINEAGETAG = "SourceLineageTag";
	    public const string SOURCEPROVIDERTYPE = "SourceProviderType";
	    public const string SOURCEQUERYCULTURE = "SourceQueryCulture";
	    public const string SOURCETYPE = "SourceType";
	    public const string STATE = "State";
	    public const string STATUSDESCRIPTION = "StatusDescription";
	    public const string STATUSEXPRESSION = "StatusExpression";
	    public const string STATUSGRAPHIC = "StatusGraphic";
	    public const string STORAGELOCATION = "StorageLocation";
	    public const string STRUCTUREMODIFIEDTIME = "StructureModifiedTime";
	    public const string SUMMARIZATION = "Summarization";
	    public const string SUMMARIZEBY = "SummarizeBy";
	    public const string SYSTEMMANAGED = "SystemManaged";
	    public const string TABLE = "Table";
	    public const string TABLEDETAILPOSITION = "TableDetailPosition";
	    public const string TABLEPERMISSIONS = "TablePermissions";
	    public const string TABLES = "Tables";
	    public const string TARGETDESCRIPTION = "TargetDescription";
	    public const string TARGETEXPRESSION = "TargetExpression";
	    public const string TARGETFORMATSTRING = "TargetFormatString";
	    public const string TIMEOUT = "Timeout";
	    public const string TOCARDINALITY = "ToCardinality";
	    public const string TOCOLUMN = "ToColumn";
	    public const string TOTABLE = "ToTable";
	    public const string TRANSLATEDDESCRIPTIONS = "TranslatedDescriptions";
	    public const string TRANSLATEDDISPLAYFOLDERS = "TranslatedDisplayFolders";
	    public const string TRANSLATEDNAMES = "TranslatedNames";
	    public const string TRENDDESCRIPTION = "TrendDescription";
	    public const string TRENDEXPRESSION = "TrendExpression";
	    public const string TRENDGRAPHIC = "TrendGraphic";
	    public const string TYPE = "Type";
	    public const string VARIATIONS = "Variations";
    }

	internal static class ObjectMetadata
	{
		private static readonly Dictionary<Type, Type> TOMMap = new Dictionary<Type, Type>() {
            { typeof(Variation) , typeof(TOM.Variation) },
            { typeof(StructuredDataSource) , typeof(TOM.StructuredDataSource) },
            { typeof(CalculatedColumn) , typeof(TOM.CalculatedColumn) },
            { typeof(CalculatedTableColumn) , typeof(TOM.CalculatedTableColumn) },
            { typeof(Column) , typeof(TOM.Column) },
            { typeof(Culture) , typeof(TOM.Culture) },
            { typeof(DataColumn) , typeof(TOM.DataColumn) },
            { typeof(DataSource) , typeof(TOM.DataSource) },
            { typeof(ExternalModelRoleMember) , typeof(TOM.ExternalModelRoleMember) },
            { typeof(Hierarchy) , typeof(TOM.Hierarchy) },
            { typeof(KPI) , typeof(TOM.KPI) },
            { typeof(AlternateOf) , typeof(TOM.AlternateOf) },
            { typeof(Level) , typeof(TOM.Level) },
            { typeof(Measure) , typeof(TOM.Measure) },
            { typeof(Model) , typeof(TOM.Model) },
            { typeof(ModelRole) , typeof(TOM.ModelRole) },
            { typeof(ModelRoleMember) , typeof(TOM.ModelRoleMember) },
            { typeof(Partition) , typeof(TOM.Partition) },
            { typeof(Set) , typeof(TOM.Set) },
            { typeof(Perspective) , typeof(TOM.Perspective) },
            { typeof(ProviderDataSource) , typeof(TOM.ProviderDataSource) },
            { typeof(Relationship) , typeof(TOM.Relationship) },
            { typeof(SingleColumnRelationship) , typeof(TOM.SingleColumnRelationship) },
            { typeof(Table) , typeof(TOM.Table) },
            { typeof(WindowsModelRoleMember) , typeof(TOM.WindowsModelRoleMember) },
            { typeof(NamedExpression) , typeof(TOM.NamedExpression) },
            { typeof(CalculationGroup) , typeof(TOM.CalculationGroup) },
            { typeof(CalculationItem) , typeof(TOM.CalculationItem) },
            { typeof(TablePermission) , typeof(TOM.TablePermission) },
	    };

		public static Type ToTOM(Type wrapperType) {
			return TOMMap[wrapperType];
		}

		public static Type FromTOM(Type tomType) {
			return TOMMap.FirstOrDefault(kvp => kvp.Value == tomType).Key;
		}

		public static readonly Type[] Creatable = {
            typeof(Variation),
            typeof(StructuredDataSource),
            typeof(CalculatedColumn),
            typeof(CalculatedTableColumn),
            typeof(Culture),
            typeof(DataColumn),
            typeof(ExternalModelRoleMember),
            typeof(Hierarchy),
            typeof(Level),
            typeof(Measure),
            typeof(ModelRole),
            typeof(Partition),
            typeof(Set),
            typeof(Perspective),
            typeof(ProviderDataSource),
            typeof(SingleColumnRelationship),
            typeof(Table),
            typeof(WindowsModelRoleMember),
            typeof(NamedExpression),
            typeof(CalculationItem),
            typeof(TablePermission),
	        typeof(MPartition),
            typeof(EntityPartition),
            typeof(PolicyRangePartition),
			typeof(CalculatedTable),
			typeof(CalculationGroupTable)
        };
	}
	/// <summary>
///             The type of the content of a string. E.g. XML or JSON.
///             </summary><remarks>This enum is only supported when the compatibility level of the database is at 1465 or above.</remarks>
	public enum ContentType {    
        Xml = 0,
        Json = 1,
	}
	/// <summary>
///             Indicates the dialect of the query expression.
///             </summary><remarks>This enum is only supported when the compatibility level of the database is at 1400 or above.</remarks>
	public enum ExpressionKind {    
        M = 0,
	}
	/// <summary>
///             The type of DataSource. Currently, the only possible value is Provider.
///             </summary>
	public enum DataSourceType {    
        Provider = 1,
        Structured = 2,
	}
	/// <summary>
///             An enumeration of possible values for a partition source.
///             </summary>
	public enum PartitionSourceType {    
        Query = 1,
        Calculated = 2,
        None = 3,
        M = 4,
        Entity = 5,
        PolicyRange = 6,
        CalculationGroup = 7,
        Inferred = 8,
	}
	/// <summary>
///             Describes the type of data contained in the column. 
///             </summary>
	public enum DataType {    
        Automatic = 1,
        String = 2,
        Int64 = 6,
        Double = 8,
        DateTime = 9,
        Decimal = 10,
        Boolean = 11,
        Binary = 17,
        Unknown = 19,
        Variant = 20,
	}
	/// <summary>
///             An enumeration of possible values for object state.
///             </summary>
	public enum ObjectState {    
        Ready = 1,
        NoData = 3,
        CalculationNeeded = 4,
        SemanticError = 5,
        EvaluationError = 6,
        DependencyError = 7,
        Incomplete = 8,
        ForceCalculationNeeded = 10,
	}
	/// <summary>
///             An enumeration of possible values for aligning data in a cell. 
///             </summary>
	public enum Alignment {    
        Default = 1,
        Left = 2,
        Right = 3,
        Center = 4,
	}
	/// <summary>
///             Specifies the aggregate function to be used by reporting tools to summarize column values.
///             </summary>
	public enum AggregateFunction {    
        Default = 1,
        None = 2,
        Sum = 3,
        Min = 4,
        Max = 5,
        Count = 6,
        Average = 7,
        DistinctCount = 8,
	}
	/// <summary>
///             An enumeration of possible values for a column type. 
///             </summary>
	public enum ColumnType {    
        Data = 1,
        Calculated = 2,
        RowNumber = 3,
        CalculatedTableColumn = 4,
	}
	/// <summary>
///             Indicates whether the particular member of a security role is an individual user or a group of users, or if the member is automatically detected.
///             </summary>
	public enum RoleMemberType {    
        Auto = 1,
        User = 2,
        Group = 3,
	}
	/// <summary>
///             Defines the method for making data available in the partition.
///             </summary>
	public enum ModeType {    
        Import = 0,
        DirectQuery = 1,
        Default = 2,
        Push = 3,
        Dual = 4,
	}
	/// <summary>
///             Determines which partitions are to be selected to run queries against the model.
///             </summary>
	public enum DataViewType {    
        Full = 0,
        Sample = 1,
        Default = 3,
	}
	/// <summary>
///             An enumeration of possible model permissions that can be used in a Role object.
///             </summary>
	public enum ModelPermission {    
        None = 1,
        Read = 2,
        ReadRefresh = 3,
        Refresh = 4,
        Administrator = 5,
	}
	/// <summary>
///             Determines how credentials are obtained for an impersonated connection to a data source during data import or refresh.
///             </summary>
	public enum ImpersonationMode {    
        Default = 1,
        ImpersonateAccount = 2,
        ImpersonateAnonymous = 3,
        ImpersonateCurrentUser = 4,
        ImpersonateServiceAccount = 5,
        ImpersonateUnattendedAccount = 6,
	}
	/// <summary>
///             Controls the locking behavior of the SQL statements when executing commands against the data source. 
///             </summary>
	public enum DatasourceIsolation {    
        ReadCommitted = 1,
        Snapshot = 2,
	}
	/// <summary>
///             The type of relationship. Currently, the only possible value is SingleColumn.
///             </summary>
	public enum RelationshipType {    
        SingleColumn = 1,
	}
	/// <summary>
///             Indicates how relationships influence filtering of data. The enumeration defines the possible behaviors.
///             </summary>
	public enum CrossFilteringBehavior {    
        OneDirection = 1,
        BothDirections = 2,
        Automatic = 3,
	}
	/// <summary>
///             Indicates how relationships influence filtering of data when evaluating row-level security expressions. The enumeration defines the possible behaviors.
///             </summary>
	public enum SecurityFilteringBehavior {    
        OneDirection = 1,
        BothDirections = 2,
        None = 3,
	}
	/// <summary>
///             When joining two date time columns, indicates whether to join on date and time parts or on date part only.
///             </summary>
	public enum DateTimeRelationshipBehavior {    
        DateAndTime = 1,
        DatePartOnly = 2,
	}
	/// <summary>
///             An enumeration of possible values for defining cardinality on either side of a table relationship.
///             </summary>
	public enum RelationshipEndCardinality {    
        None = 0,
        One = 1,
        Many = 2,
	}
	/// <summary>
///             Ragged/unbalanced hierarchies can be enabled by hiding members.
///             </summary><remarks>This enum is only supported when the compatibility level of the database is at 1400 or above.</remarks>
	public enum HierarchyHideMembersType {    
        Default = 0,
        HideBlankMembers = 1,
	}
	/// <summary>
///             Encoding hint to suggest whether a column should use hash encoding.
///             </summary><remarks>This enum is only supported when the compatibility level of the database is at 1400 or above.</remarks>
	public enum EncodingHintType {    
        Default = 0,
        Hash = 1,
        Value = 2,
	}
	/// <summary>
///             An enumeration of possible values for a refresh type.
///             </summary>
	public enum RefreshType {    
        Full = 1,
        ClearValues = 2,
        Calculate = 3,
        DataOnly = 4,
        Automatic = 5,
        Add = 7,
        Defragment = 8,
	}
	/// <summary>
///             An enumeration of possible values for the type of value stored in extended property.
///             </summary><remarks>This enum is only supported when the compatibility level of the database is at 1400 or above.</remarks>
	public enum ExtendedPropertyType {    
        String = 0,
        Json = 1,
	}
	/// <summary>
///             Access control to a data defined by a metadata object.
///             </summary><remarks>This enum is only supported when the compatibility level of the database is at 1400 or above.</remarks>
	public enum MetadataPermission {    
        Default = 0,
        None = 1,
        Read = 2,
	}
	/// <summary>
///             DataSource format version in Power BI Service.
///             </summary><remarks>This enum is only supported when the compatibility level of the database is at 1450 or above.</remarks>
	public enum PowerBIDataSourceVersion {    
        PowerBI_V1 = 0,
        PowerBI_V2 = 1,
        PowerBI_V3 = 2,
	}
	/// <summary>
///             Specifies the Summarization type to be used by alternative sources' columns.
///             </summary><remarks>This enum is only supported when the compatibility level of the database is at 1460 or above.</remarks>
	public enum SummarizationType {    
        GroupBy = 0,
        Sum = 1,
        Count = 2,
        Min = 3,
        Max = 4,
	}
	/// <summary>
///             Specifies the granularity of the refresh policy for auto partitioning
///             </summary><remarks>This enum is only supported when the compatibility level of the database is at 1450 or above.</remarks>
	public enum RefreshGranularityType {    
        Day = 0,
        Month = 1,
        Quarter = 2,
        Year = 3,
        Invalid = -1,
	}
  
	/// <summary>
///             Variation object.
///             </summary><remarks>This metadata object is only supported for Pbi server, at database compatibility level of 1400 or above for Box server, at database compatibility level of 1400 or above for Excel server.</remarks>
	[TypeConverter(typeof(DynamicPropertyConverter))]
	public sealed partial class Variation: TabularNamedObject
			, IDescriptionObject
			, IInternalAnnotationObject
			, IInternalExtendedPropertyObject
			, IClonableObject
	{
	    internal new TOM.Variation MetadataObject 
		{ 
			get 
			{ 
				return base.MetadataObject as TOM.Variation; 
		    } 
			set 
			{ 
				base.MetadataObject = value; 
			}
		}

        private bool CanClearAnnotations() => GetAnnotationsCount() > 0;
        ///<summary>Removes all annotations from this object.</summary>
        [IntelliSense("Removes all annotations from this object.")]
        public void ClearAnnotations()
        {
            Handler.BeginUpdate("Clear annotations");
            foreach(var annotation in GetAnnotations().ToList()) {
                RemoveAnnotation(annotation);
            }
            Handler.EndUpdate();
        }

		///<summary>The collection of Annotations on the current Variation.</summary>
        [Browsable(true),NoMultiselect,Category("Metadata"),Description("The collection of Annotations on the current Variation."),Editor(typeof(AnnotationCollectionEditor), typeof(UITypeEditor))]
        [PropertyAction(nameof(ClearAnnotations))]
		public AnnotationCollection Annotations { get; private set; }
		///<summary>Gets the value of the annotation with the given index, assuming it exists.</summary>
		[IntelliSense("Gets the value of the annotation with the given index, assuming it exists.")]
		public string GetAnnotation(int index) {
			return MetadataObject.Annotations[index].Value;
		}
		///<summary>Returns true if an annotation with the given name exists. Otherwise false.</summary>
		[IntelliSense("Returns true if an annotation with the given name exists. Otherwise false.")]
		public bool HasAnnotation(string name) {
		    return MetadataObject.Annotations.ContainsName(name);
		}
		///<summary>Gets the value of the annotation with the given name. Returns null if no such annotation exists.</summary>
		[IntelliSense("Gets the value of the annotation with the given name. Returns null if no such annotation exists.")]
		public string GetAnnotation(string name) {
		    return HasAnnotation(name) ? MetadataObject.Annotations[name].Value : null;
		}
		///<summary>Sets the value of the annotation with the given index, assuming it exists.</summary>
		[IntelliSense("Sets the value of the annotation with the given index, assuming it exists.")]
		public void SetAnnotation(int index, string value) {
		    SetAnnotation(index, value, true);
		}
		internal void SetAnnotation(int index, string value, bool undoable) {
		    var name = MetadataObject.Annotations[index].Name;
			SetAnnotation(name, value, undoable);
		}
		void IInternalAnnotationObject.SetAnnotation(int index, string value, bool undoable) {
			SetAnnotation(index, value, undoable);
		}
		///<summary>Returns a unique name for a new annotation.</summary>
		public string GetNewAnnotationName() {
			return MetadataObject.Annotations.GetNewName("New Annotation");
		}
		///<summary>Sets the value of the annotation having the given name. If no such annotation exists, it will be created. If value is set to null, the annotation will be removed.</summary>
		[IntelliSense("Sets the value of the annotation having the given name. If no such annotation exists, it will be created. If value is set to null, the annotation will be removed.")]
		public void SetAnnotation(string name, string value) {
		    SetAnnotation(name, value, true);
		}
		internal void SetAnnotation(string name, string value, bool undoable) {
			if(name == null) name = GetNewAnnotationName();

			if(value == null) {
				// Remove annotation if set to null:
				RemoveAnnotation(name, undoable);
				return;
			}

			if(undoable) {
 				if(GetAnnotation(name) == value) return;
				bool undoable2 = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + value, ref undoable2, ref cancel);
				if (cancel) return;
			}

			if(MetadataObject.Annotations.Contains(name)) {
				// Change existing annotation:

				var oldValue = GetAnnotation(name);
				MetadataObject.Annotations[name].Value = value;
				if (undoable) {
					Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, oldValue));
					OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, name + ":" + value);
				}
			} else {
				// Add new annotation:

				MetadataObject.Annotations.Add(new TOM.Annotation{ Name = name, Value = value });
				if (undoable) {
					Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, null));
					OnPropertyChanged(Properties.ANNOTATIONS, null, name + ":" + value);
				}
			}
		}
		void IInternalAnnotationObject.SetAnnotation(string name, string value, bool undoable) {
			this.SetAnnotation(name, value, undoable);
		}
		///<summary>Remove an annotation by the given name.</summary>
		[IntelliSense("Remove an annotation by the given name.")]
		public void RemoveAnnotation(string name) {
		    RemoveAnnotation(name, true);
		}
		internal void RemoveAnnotation(string name, bool undoable) {
			if(MetadataObject.Annotations.Contains(name)) {
				if(undoable) 
				{
				    bool undoable2 = true;
				    bool cancel = false;
				    OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + GetAnnotation(name), ref undoable2, ref cancel);
				    if (cancel) return;
				}

			    var oldValue = MetadataObject.Annotations[name].Value;
				MetadataObject.Annotations.Remove(name);

				if (undoable) 
				{
					Handler.UndoManager.Add(new UndoAnnotationAction(this, name, null, oldValue));
					OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, null);
			    }
			}
		}
		void IInternalAnnotationObject.RemoveAnnotation(string name, bool undoable) {
			this.RemoveAnnotation(name, undoable);
		}
		///<summary>Gets the number of annotations on the current Variation.</summary>
		[IntelliSense("Gets the number of annotations on the current Variation.")]
		public int GetAnnotationsCount() {
			return MetadataObject.Annotations.Count;
		}
		///<summary>Gets a collection of all annotation names on the current Variation.</summary>
		[IntelliSense("Gets a collection of all annotation names on the current Variation.")]
		public IEnumerable<string> GetAnnotations() {
			return MetadataObject.Annotations.Select(a => a.Name);
		}

		        private bool CanClearExtendedProperties() => GetExtendedPropertyCount() > 0;
        ///<summary>Removes all Extended Properties from this object.</summary>
        [IntelliSense("Removes all Extended Properties from this object.")]
        public void ClearExtendedProperties()
        {
            Handler.BeginUpdate("Clear extended properties");
            foreach(var extendedProperty in GetExtendedProperties().ToList()) {
                RemoveExtendedProperty(extendedProperty);
            }
            Handler.EndUpdate();
        }

		///<summary>The collection of Extended Properties on the current Variation.</summary>
        [DisplayName("Extended Properties"),NoMultiselect,Category("Metadata"),Description("The collection of Extended Properties on the current Variation."),Editor(typeof(ExtendedPropertyCollectionEditor), typeof(UITypeEditor))]
        [PropertyAction(nameof(ClearExtendedProperties))]
		public ExtendedPropertyCollection ExtendedProperties { get; private set; }

		///<summary>Returns true if an ExtendedProperty with the given name exists. Otherwise false.</summary>
		[IntelliSense("Returns true if an ExtendedProperty with the given name exists. Otherwise false.")]
		public bool HasExtendedProperty(string name) {
		    return MetadataObject.ExtendedProperties.ContainsName(name);
		}
		///<summary>Gets the type of the ExtendedProperty with the given index, assuming it exists.</summary>
		public ExtendedPropertyType GetExtendedPropertyType(int index) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[index].Type;
		}
		///<summary>Gets the type of the ExtendedProperty with the given name, assuming it exists.</summary>
		public ExtendedPropertyType GetExtendedPropertyType(string name) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[name].Type;
		}
		///<summary>Gets the value of the ExtendedProperty with the given index, assuming it exists.</summary>
		public string GetExtendedProperty(int index) {
			var ep = MetadataObject.ExtendedProperties[index];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		///<summary>Gets the value of the ExtendedProperty with the given name. Returns null if no such ExtendedProperty exists.</summary>
		[IntelliSense("Gets the value of the ExtendedProperty with the given name. Returns null if no such ExtendedProperty exists.")]
		public string GetExtendedProperty(string name) {
		    if(!HasExtendedProperty(name)) return null;
			var ep = MetadataObject.ExtendedProperties[name];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		///<summary>Sets the value of the ExtendedProperty with the given index, optionally specifiying the type (string or JSON) of the ExtendedProperty.</summary>
		public void SetExtendedProperty(int index, string value, ExtendedPropertyType type) {
			SetExtendedProperty(index, value, type, true);
		}
		void IInternalExtendedPropertyObject.SetExtendedProperty(int index, string value, ExtendedPropertyType type, bool undoable) {
			SetExtendedProperty(index, value, type, undoable);
		}
		internal void SetExtendedProperty(int index, string value, ExtendedPropertyType type, bool undoable) {
			var name = MetadataObject.ExtendedProperties[index].Name;
			SetExtendedProperty(name, value, type, undoable);
		}
		///<summary>Returns a unique name for a new ExtendedProperty.</summary>
		public string GetNewExtendedPropertyName() {
			return MetadataObject.ExtendedProperties.GetNewName("New ExtendedProperty");
		}
		///<summary>Sets the value of the ExtendedProperty having the given name. If no such ExtendedProperty exists, it will be created. If value is set to null, the ExtendedProperty will be removed.</summary>
		[IntelliSense("Sets the value of the ExtendedProperty having the given name. If no such ExtendedProperty exists, it will be created. If value is set to null, the ExtendedProperty will be removed.")]
		public void SetExtendedProperty(string name, string value, ExtendedPropertyType type) {
			SetExtendedProperty(name, value, type, true);
		}
		internal void SetExtendedProperty(string name, string value, ExtendedPropertyType type, bool undoable) {
			if(name == null) name = GetNewExtendedPropertyName();

			if(value == null) {
				// Remove ExtendedProperty if set to null:
				RemoveExtendedProperty(name);
				return;
			}

			if(GetExtendedProperty(name) == value) return;
			if(undoable) {
				bool cancel = false;
				OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + value, ref undoable, ref cancel);
				if (cancel) return;
			}

			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Change existing ExtendedProperty:
				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				var ep = MetadataObject.ExtendedProperties[name];
				if (ep is TOM.JsonExtendedProperty)
					(ep as TOM.JsonExtendedProperty).Value = value;
				else 
					(ep as TOM.StringExtendedProperty).Value = value;
					
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, name + ":" + value);
			} else {
				// Add new ExtendedProperty:
				if (type == ExtendedPropertyType.Json)
					MetadataObject.ExtendedProperties.Add(new TOM.JsonExtendedProperty{ Name = name, Value = value });
				else
					MetadataObject.ExtendedProperties.Add(new TOM.StringExtendedProperty{ Name = name, Value = value });

				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, null, type));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, null, name + ":" + value);
			}
		}
		void IInternalExtendedPropertyObject.SetExtendedProperty(string name, string value, ExtendedPropertyType type, bool undoable) {
			this.SetExtendedProperty(name, value, type, undoable);
		}

		///<summary>Remove an ExtendedProperty by the given name.</summary>
		[IntelliSense("Remove an ExtendedProperty by the given name.")]
		public void RemoveExtendedProperty(string name) {
			RemoveExtendedProperty(name, true);
		}

		internal void RemoveExtendedProperty(string name, bool undoable) {
			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Get current value:
				if(undoable) {
					bool cancel = false;
					OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + GetExtendedProperty(name), ref undoable, ref cancel);
					if (cancel) return;
				}

				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				MetadataObject.ExtendedProperties.Remove(name);

				// Undo-handling:
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, null, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, null);
			}
		}
		void IInternalExtendedPropertyObject.RemoveExtendedProperty(string name, bool undoable) {
			this.RemoveExtendedProperty(name, undoable);
		}
		///<summary>Gets the number of ExtendedProperties on the current object.</summary>
		[IntelliSense("Gets the number of ExtendedProperties on the current object.")]
		public int GetExtendedPropertyCount() {
			return MetadataObject.ExtendedProperties.Count;
		}
		///<summary>Gets a collection of all ExtendedProperty names on the current object.</summary>
		[IntelliSense("Gets a collection of all ExtendedProperty names on the current object.")]
		public IEnumerable<string> GetExtendedProperties() {
			return MetadataObject.ExtendedProperties.Select(a => a.Name);
		}

		/// <summary>
///             Missing comment
///             </summary>
		[DisplayName("Description")]
		[Category("Basic"),Description(@"The Description of this Variation"),IntelliSense(@"The Description of this Variation")][Editor(typeof(System.ComponentModel.Design.MultilineStringEditor), typeof(System.Drawing.Design.UITypeEditor))]
		public string Description {
			get {
			    return MetadataObject.Description;
			}
			set {
				
				var oldValue = Description;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DESCRIPTION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.Description = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DESCRIPTION, oldValue, newValue));
				OnPropertyChanged(Properties.DESCRIPTION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeDescription() { return false; }
/// <summary>
///             If true, the Variation is the Default one for the Column.
///             </summary>
		[DisplayName("Default")]
		[Category("Options"),Description(@"If true, the Variation is the Default one for the Column."),IntelliSense(@"If true, the Variation is the Default one for the Column.")]
		public bool IsDefault {
			get {
			    return MetadataObject.IsDefault;
			}
			set {
				
				var oldValue = IsDefault;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ISDEFAULT, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.IsDefault = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.ISDEFAULT, oldValue, newValue));
				OnPropertyChanged(Properties.ISDEFAULT, oldValue, newValue);
			}
		}
		private bool ShouldSerializeIsDefault() { return false; }
/// <summary>
///             Missing comment
///             </summary>
		[DisplayName("Parent Column")]
		[Category("Basic"),Description(@"The Column of this Variation"),IntelliSense(@"The Column of this Variation")][TypeConverter(typeof(TableColumnConverter)),ReadOnly(true)]
		public Column Column {
			get {
				if (MetadataObject.Column == null) return null;
			    return Handler.WrapperLookup[MetadataObject.Column] as Column;
            }
			
		}
		private bool ShouldSerializeColumn() { return false; }
/// <summary>
///             Missing comment
///             </summary>
		[DisplayName("Relationship")]
		[Category("Options"),Description(@"The Relationship of this Variation"),IntelliSense(@"The Relationship of this Variation")][TypeConverter(typeof(AllRelationshipConverter))]
		public Relationship Relationship {
			get {
				if (MetadataObject.Relationship == null) return null;
			    return Handler.WrapperLookup[MetadataObject.Relationship] as Relationship;
            }
			set {
				
				var oldValue = Relationship;
				var newValue = value;
				if (oldValue?.MetadataObject == newValue?.MetadataObject) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.RELATIONSHIP, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.Relationship = value == null ? null : value.MetadataObject;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.RELATIONSHIP, oldValue, newValue));
				OnPropertyChanged(Properties.RELATIONSHIP, oldValue, newValue);
			}
		}
		private bool ShouldSerializeRelationship() { return false; }
/// <summary>
///             Missing comment
///             </summary>
		[DisplayName("Default Hierarchy")]
		[Category("Options"),Description(@"The DefaultHierarchy of this Variation"),IntelliSense(@"The DefaultHierarchy of this Variation")][TypeConverter(typeof(AllHierarchyConverter))]
		public Hierarchy DefaultHierarchy {
			get {
				if (MetadataObject.DefaultHierarchy == null) return null;
			    return Handler.WrapperLookup[MetadataObject.DefaultHierarchy] as Hierarchy;
            }
			set {
				
				var oldValue = DefaultHierarchy;
				var newValue = value;
				if (oldValue?.MetadataObject == newValue?.MetadataObject) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DEFAULTHIERARCHY, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.DefaultHierarchy = value == null ? null : value.MetadataObject;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DEFAULTHIERARCHY, oldValue, newValue));
				OnPropertyChanged(Properties.DEFAULTHIERARCHY, oldValue, newValue);
			}
		}
		private bool ShouldSerializeDefaultHierarchy() { return false; }
/// <summary>
///             Missing comment
///             </summary>
		[DisplayName("Default Column")]
		[Category("Options"),Description(@"The DefaultColumn of this Variation"),IntelliSense(@"The DefaultColumn of this Variation")][TypeConverter(typeof(AllColumnConverter))]
		public Column DefaultColumn {
			get {
				if (MetadataObject.DefaultColumn == null) return null;
			    return Handler.WrapperLookup[MetadataObject.DefaultColumn] as Column;
            }
			set {
				
				var oldValue = DefaultColumn;
				var newValue = value;
				if (oldValue?.MetadataObject == newValue?.MetadataObject) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DEFAULTCOLUMN, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.DefaultColumn = value == null ? null : value.MetadataObject;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DEFAULTCOLUMN, oldValue, newValue));
				OnPropertyChanged(Properties.DEFAULTCOLUMN, oldValue, newValue);
			}
		}
		private bool ShouldSerializeDefaultColumn() { return false; }

		internal static Variation CreateFromMetadata(Column parent, TOM.Variation metadataObject) {
			var obj = new Variation(metadataObject);
			parent.Variations.Add(obj);
			
			obj.Init();

			return obj;
		}


		/// <summary>
		/// Creates a new Variation and adds it to the parent Column.
		/// Also creates the underlying metadataobject and adds it to the TOM tree.
		/// </summary>
		public static Variation CreateNew(Column parent, string name = null)
		{
			if(!parent.Handler.PowerBIGovernance.AllowCreate(typeof(Variation))) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(Variation).GetTypeName()));
			}

			var metadataObject = new TOM.Variation();
			metadataObject.Name = parent.Variations.GetNewName(string.IsNullOrWhiteSpace(name) ? "New " + typeof(Variation).GetTypeName() : name);
            InitMetadata(metadataObject, parent);
            var obj = new Variation(metadataObject);

			parent.Variations.Add(obj);
			
			obj.Init();

			return obj;
		}

        static partial void InitMetadata(TOM.Variation metadataObject, Column parent);


		/// <summary>
		/// Creates an exact copy of this Variation object.
		/// </summary>
		[IntelliSense("Creates an exact copy of this Variation object.")]
		public Variation Clone(string newName = null, Column newParent = null) {
			if(!Handler.PowerBIGovernance.AllowCreate(this.GetType())) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(Variation).GetTypeName()));
			}

		    Handler.BeginUpdate("Clone Variation");

			// Create a clone of the underlying metadataobject:
			var tom = MetadataObject.Clone() as TOM.Variation;


			// Assign a new, unique name:
			tom.Name = Parent.Variations.GetNewName(string.IsNullOrEmpty(newName) ? tom.Name + " copy" : newName);
				
			// Create the TOM Wrapper object, representing the metadataobject
			Variation obj = CreateFromMetadata(newParent ?? Parent, tom);

            Handler.EndUpdate();

            return obj;
		}

		TabularNamedObject IClonableObject.Clone(string newName, bool includeTranslations, TabularNamedObject newParent) 
		{
			return Clone(newName);
		}

	
        internal override void RenewMetadataObject()
        {
            Handler.WrapperLookup.Remove(MetadataObject);
            var json = TOM.JsonSerializer.SerializeObject(MetadataObject, RenewMetadataOptions);
            MetadataObject = TOM.JsonSerializer.DeserializeObject<TOM.Variation>(json);
            Handler.WrapperLookup.Add(MetadataObject, this);
        }

		///<summary>The parent Column of the current Variation.</summary>
		public Column Parent { 
			get {
				return Handler.WrapperLookup[MetadataObject.Parent] as Column;
			}
		}



		/// <summary>
		/// CTOR - only called from static factory methods on the class
		/// </summary>
		Variation(TOM.Variation metadataObject) : base(metadataObject)
		{
			
			// Create indexer for annotations:
			Annotations = new AnnotationCollection(this);
			
			// Create indexer for extended properties:
			ExtendedProperties = new ExtendedPropertyCollection(this);
		}



		internal override void Undelete(ITabularObjectCollection collection, Type tomObjectType, string tomJson) {
			base.Undelete(collection, tomObjectType, tomJson);
			Reinit();
			ReapplyReferences();
		}
		internal override sealed bool Browsable(string propertyName) {
			// Allow custom overrides to hide a property regardless of its compatibility level requirements:
			if(!base.Browsable(propertyName)) return false;

			switch (propertyName) {

				// Hide properties based on compatibility requirements (inferred from TOM):
				case Properties.EXTENDEDPROPERTIES:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1400 : Handler.CompatibilityLevel >= 1400;
				case Properties.PARENT:
					return false;
				
				default:
					return true;
			}
		}

    }


	/// <summary>
	/// Collection class for Variation. Provides convenient properties for setting a property on multiple objects at once.
	/// </summary>
	public sealed partial class VariationCollection: TabularObjectCollection<Variation>
	{
		internal Column Column { get { return Parent as Column; } }
		TOM.VariationCollection TOM_Collection;
		internal VariationCollection(string collectionName, TOM.VariationCollection metadataObjectCollection, Column parent) : base(collectionName, parent)
		{
			TOM_Collection = metadataObjectCollection;
		}
		internal override Type GetItemType() { return typeof(Variation); }
        internal override void TOM_Add(TOM.MetadataObject obj) { TOM_Collection.Add(obj as TOM.Variation); }
        internal override bool TOM_Contains(TOM.MetadataObject obj) { return TOM_Collection.Contains(obj as TOM.Variation); }
        internal override void TOM_Remove(TOM.MetadataObject obj) { TOM_Collection.Remove(obj as TOM.Variation); }
        internal override void TOM_Clear() { TOM_Collection.Clear(); }
        internal override bool TOM_ContainsName(string name) { return TOM_Collection.ContainsName(name); }
		internal override TOM.MetadataObject TOM_Get(int index) { return TOM_Collection[index]; }
        internal override TOM.MetadataObject TOM_Get(string name) { return TOM_Collection[name]; }
        internal override TOM.MetadataObject TOM_Find(string name) { return TOM_Collection.Find(name); }
        internal override string GetNewName(string prefix = null) { return string.IsNullOrEmpty(prefix) ? TOM_Collection.GetNewName() : TOM_Collection.GetNewName(prefix); }
        internal override int IndexOf(TOM.MetadataObject obj) { return TOM_Collection.IndexOf(obj as TOM.Variation); }
        /// <summary>The number of items in this collection.</summary>
		public override int Count { get { return TOM_Collection.Count; } }
		/// <summary>Returns an enumerator that iterates through the collection.</summary>
        public override IEnumerator<Variation> GetEnumerator() { return TOM_Collection.Select(h => Handler.WrapperLookup[h]).OfType<Variation>().GetEnumerator(); }
		internal override void Reinit() {
			var ixOffset = 0;
			for(int i = 0; i < Count; i++) {
				var metadataObj = TOM_Get(i) as TOM.Variation;
				var item = Handler.WrapperLookup.TryGetValue(metadataObj, out var existingItem) ? existingItem as Variation : CreateFromMetadata(metadataObj);
				Handler.WrapperLookup.Remove(item.MetadataObject);
				item.MetadataObject = Column.MetadataObject.Variations[i + ixOffset] as TOM.Variation;
				Handler.WrapperLookup.Add(item.MetadataObject, item);
				item.Collection = this;
			}
			TOM_Collection = Column.MetadataObject.Variations;
			foreach(var item in this) item.Reinit();
		}

		internal override void ReapplyReferences() {
			foreach(var item in this) item.ReapplyReferences();
		}

		private Variation CreateFromMetadata(TOM.Variation obj)
		{
			if(obj is TOM.Variation variationObj) return Variation.CreateFromMetadata(Column, variationObj);
		    return null;
		}

		/// <summary>
		/// Calling this method will populate the VariationCollection with objects based on the MetadataObjects in the corresponding MetadataObjectCollection.
		/// </summary>
		internal override void CreateChildrenFromMetadata()
		{
			// Construct child objects (they are automatically added to the Handler's WrapperLookup dictionary):
			foreach(var obj in TOM_Collection)
			{
				CreateFromMetadata(obj);
			}
		}

		/// <summary>
		/// Sets the Description property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the Description property of all objects in the collection at once.")]
		public string Description {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("Description"));
				this.ToList().ForEach(item => { item.Description = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the IsDefault property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the IsDefault property of all objects in the collection at once.")]
		public bool IsDefault {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("IsDefault"));
				this.ToList().ForEach(item => { item.IsDefault = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the Relationship property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the Relationship property of all objects in the collection at once.")]
		public Relationship Relationship {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("Relationship"));
				this.ToList().ForEach(item => { item.Relationship = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the DefaultHierarchy property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the DefaultHierarchy property of all objects in the collection at once.")]
		public Hierarchy DefaultHierarchy {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("DefaultHierarchy"));
				this.ToList().ForEach(item => { item.DefaultHierarchy = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the DefaultColumn property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the DefaultColumn property of all objects in the collection at once.")]
		public Column DefaultColumn {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("DefaultColumn"));
				this.ToList().ForEach(item => { item.DefaultColumn = value; });
				Handler.UndoManager.EndBatch();
			}
		}
	}
  
	/// <summary>
///             Represents a data source that uses JSON-based extensible protocol to define the location and mechanism of retrieving the data.
///             </summary><remarks>This metadata object is only supported when the compatibility level of the database is at 1400 or above.</remarks>
	[TypeConverter(typeof(DynamicPropertyConverter))]
	public sealed partial class StructuredDataSource: DataSource
			, IClonableObject
	{
	    internal new TOM.StructuredDataSource MetadataObject 
		{ 
			get 
			{ 
				return base.MetadataObject as TOM.StructuredDataSource; 
		    } 
			set 
			{ 
				base.MetadataObject = value; 
			}
		}

/// <summary>
///             For internal use only.
///             </summary>
		[DisplayName("Context Expression")]
		[Category("Options"),Description(@"For internal use only."),IntelliSense(@"For internal use only.")][Editor(typeof(System.ComponentModel.Design.MultilineStringEditor), typeof(System.Drawing.Design.UITypeEditor))]
		public string ContextExpression {
			get {
			    return MetadataObject.ContextExpression;
			}
			set {
				
				var oldValue = ContextExpression;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.CONTEXTEXPRESSION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.ContextExpression = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.CONTEXTEXPRESSION, oldValue, newValue));
				OnPropertyChanged(Properties.CONTEXTEXPRESSION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeContextExpression() { return false; }

		internal static StructuredDataSource CreateFromMetadata(Model parent, TOM.StructuredDataSource metadataObject) {
			var obj = new StructuredDataSource(metadataObject);
			parent.DataSources.Add(obj);
			
			obj.Init();

			return obj;
		}


		/// <summary>
		/// Creates a new StructuredDataSource and adds it to the parent Model.
		/// Also creates the underlying metadataobject and adds it to the TOM tree.
		/// </summary>
		public static StructuredDataSource CreateNew(Model parent, string name = null)
		{
			if(!parent.Handler.PowerBIGovernance.AllowCreate(typeof(StructuredDataSource))) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(StructuredDataSource).GetTypeName()));
			}

			var metadataObject = new TOM.StructuredDataSource();
			metadataObject.Name = parent.DataSources.GetNewName(string.IsNullOrWhiteSpace(name) ? "New " + typeof(StructuredDataSource).GetTypeName() : name);
            InitMetadata(metadataObject, parent);
            var obj = new StructuredDataSource(metadataObject);

			parent.DataSources.Add(obj);
			
			obj.Init();

			return obj;
		}

        static partial void InitMetadata(TOM.StructuredDataSource metadataObject, Model parent);

		/// <summary>
		/// Creates a new StructuredDataSource and adds it to the current Model.
		/// Also creates the underlying metadataobject and adds it to the TOM tree.
		/// </summary>		
		public static StructuredDataSource CreateNew(string name = null)
		{
			return CreateNew(TabularModelHandler.Singleton.Model, name);
		}


		/// <summary>
		/// Creates an exact copy of this StructuredDataSource object.
		/// </summary>
		[IntelliSense("Creates an exact copy of this StructuredDataSource object.")]
		public StructuredDataSource Clone(string newName = null) {
			if(!Handler.PowerBIGovernance.AllowCreate(this.GetType())) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(StructuredDataSource).GetTypeName()));
			}

		    Handler.BeginUpdate("Clone StructuredDataSource");

			// Create a clone of the underlying metadataobject:
			var tom = MetadataObject.Clone() as TOM.StructuredDataSource;


			// Assign a new, unique name:
			tom.Name = Parent.DataSources.GetNewName(string.IsNullOrEmpty(newName) ? tom.Name + " copy" : newName);
				
			// Create the TOM Wrapper object, representing the metadataobject
			StructuredDataSource obj = CreateFromMetadata(Parent, tom);

            Handler.EndUpdate();

            return obj;
		}

		TabularNamedObject IClonableObject.Clone(string newName, bool includeTranslations, TabularNamedObject newParent) 
		{
			if (newParent != null) throw new ArgumentException("This object can not be cloned to another parent. Argument newParent should be left as null.", "newParent");
			return Clone(newName);
		}

	
        internal override void RenewMetadataObject()
        {
            Handler.WrapperLookup.Remove(MetadataObject);
            var json = TOM.JsonSerializer.SerializeObject(MetadataObject, RenewMetadataOptions);
            MetadataObject = TOM.JsonSerializer.DeserializeObject<TOM.StructuredDataSource>(json);
            Handler.WrapperLookup.Add(MetadataObject, this);
        }

		///<summary>The parent Model of the current Structured Data Source.</summary>
		public new Model Parent { 
			get {
				return Handler.WrapperLookup[MetadataObject.Parent] as Model;
			}
		}



		/// <summary>
		/// CTOR - only called from static factory methods on the class
		/// </summary>
		StructuredDataSource(TOM.StructuredDataSource metadataObject) : base(metadataObject)
		{
		}



		internal override void Undelete(ITabularObjectCollection collection, Type tomObjectType, string tomJson) {
			base.Undelete(collection, tomObjectType, tomJson);
			Reinit();
			ReapplyReferences();
		}
		internal override sealed bool Browsable(string propertyName) {
			// Allow custom overrides to hide a property regardless of its compatibility level requirements:
			if(!base.Browsable(propertyName)) return false;

			switch (propertyName) {

				// Hide properties based on compatibility requirements (inferred from TOM):
				case Properties.PARENT:
					return false;
				
				default:
					return true;
			}
		}

    }

  
	/// <summary>
///             Represents a column that is based on a DAX expression in a Table that also contains DataColumns and a RowNumberColumn. A CalculatedColumn can also be added to a calculated table.
///             </summary>
	[TypeConverter(typeof(DynamicPropertyConverter))]
	public sealed partial class CalculatedColumn: Column
			, IExpressionObject
			, IClonableObject
	{
	    internal new TOM.CalculatedColumn MetadataObject 
		{ 
			get 
			{ 
				return base.MetadataObject as TOM.CalculatedColumn; 
		    } 
			set 
			{ 
				base.MetadataObject = value; 
			}
		}

/// <summary>
///             A boolean value indicating whether the data type is inferred.
///             </summary>
		[DisplayName("Data Type Inferred")]
		[Category("Options"),Description(@"A boolean value indicating whether the data type is inferred."),IntelliSense(@"A boolean value indicating whether the data type is inferred.")]
		public bool IsDataTypeInferred {
			get {
			    return MetadataObject.IsDataTypeInferred;
			}
			set {
				
				var oldValue = IsDataTypeInferred;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ISDATATYPEINFERRED, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.IsDataTypeInferred = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.ISDATATYPEINFERRED, oldValue, newValue));
				OnPropertyChanged(Properties.ISDATATYPEINFERRED, oldValue, newValue);
			}
		}
		private bool ShouldSerializeIsDataTypeInferred() { return false; }
/// <summary>
///             The DAX expression that is evaluated for the calculated column.
///             </summary>
		[DisplayName("Expression")]
		[Category("Options"),Description(@"The DAX expression that is evaluated for the calculated column."),IntelliSense(@"The DAX expression that is evaluated for the calculated column.")][Editor(typeof(System.ComponentModel.Design.MultilineStringEditor), typeof(System.Drawing.Design.UITypeEditor))]
		public string Expression {
			get {
			    return MetadataObject.Expression;
			}
			set {
				
				var oldValue = Expression;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.EXPRESSION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.Expression = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.EXPRESSION, oldValue, newValue));
				OnPropertyChanged(Properties.EXPRESSION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeExpression() { return false; }

		internal static CalculatedColumn CreateFromMetadata(Table parent, TOM.CalculatedColumn metadataObject) {
            // Generate a new LineageTag if an object with the provided lineage tag already exists:
            if(!string.IsNullOrEmpty(metadataObject.LineageTag)) {
                if (parent.Handler.CompatibilityLevel < 1540) metadataObject.LineageTag = null;
                else if (parent.MetadataObject.Columns.FindByLineageTag(metadataObject.LineageTag) != metadataObject) {
                    metadataObject.LineageTag = Guid.NewGuid().ToString();
                }
            }
			var obj = new CalculatedColumn(metadataObject);
			parent.Columns.Add(obj);
			
			obj.Init();

			return obj;
		}


		/// <summary>
		/// Creates a new CalculatedColumn and adds it to the parent Table.
		/// Also creates the underlying metadataobject and adds it to the TOM tree.
		/// </summary>
		public static CalculatedColumn CreateNew(Table parent, string name = null)
		{
			if(!parent.Handler.PowerBIGovernance.AllowCreate(typeof(CalculatedColumn))) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(CalculatedColumn).GetTypeName()));
			}

			var metadataObject = new TOM.CalculatedColumn();
            if(parent.Model.Database.CompatibilityLevel >= 1540) metadataObject.LineageTag = Guid.NewGuid().ToString();
			metadataObject.Name = parent.Columns.GetNewName(string.IsNullOrWhiteSpace(name) ? "New " + typeof(CalculatedColumn).GetTypeName() : name);
            InitMetadata(metadataObject, parent);
            var obj = new CalculatedColumn(metadataObject);

			parent.Columns.Add(obj);
			
			obj.Init();

			return obj;
		}

        static partial void InitMetadata(TOM.CalculatedColumn metadataObject, Table parent);


		/// <summary>
		/// Creates an exact copy of this CalculatedColumn object.
		/// </summary>
		[IntelliSense("Creates an exact copy of this CalculatedColumn object.")]
		public CalculatedColumn Clone(string newName = null, bool includeTranslations = true, Table newParent = null) {
			if(!Handler.PowerBIGovernance.AllowCreate(this.GetType())) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(CalculatedColumn).GetTypeName()));
			}

		    Handler.BeginUpdate("Clone CalculatedColumn");

			// Create a clone of the underlying metadataobject:
			var tom = MetadataObject.Clone() as TOM.CalculatedColumn;

            if(Model.Database.CompatibilityLevel >= 1540 && !string.IsNullOrEmpty(LineageTag)) {
                tom.LineageTag = Guid.NewGuid().ToString();
            }

			// Assign a new, unique name:
			tom.Name = Parent.Columns.GetNewName(string.IsNullOrEmpty(newName) ? tom.Name + " copy" : newName);
				
			// Create the TOM Wrapper object, representing the metadataobject
			CalculatedColumn obj = CreateFromMetadata(newParent ?? Parent, tom);

			// Copy translations, if applicable:
			if(includeTranslations) {
				obj.CopyTranslationsFrom(this);
			}
				
			// Copy perspectives:
			obj.InPerspective.CopyFrom(InPerspective);

			// TODO: Make sure that dependency trees are properly rebuilt when IDaxDependantObjects are cloned
			// FormulaFixup.BuildDependencyTree(this);
            Handler.EndUpdate();

            return obj;
		}

		TabularNamedObject IClonableObject.Clone(string newName, bool includeTranslations, TabularNamedObject newParent) 
		{
			return Clone(newName);
		}

	
        internal override void RenewMetadataObject()
        {
            Handler.WrapperLookup.Remove(MetadataObject);
            var json = TOM.JsonSerializer.SerializeObject(MetadataObject, RenewMetadataOptions);
            MetadataObject = TOM.JsonSerializer.DeserializeObject<TOM.CalculatedColumn>(json);
            Handler.WrapperLookup.Add(MetadataObject, this);
        }

		///<summary>The parent Table of the current Calculated Column.</summary>
		public Table Parent { 
			get {
				return Handler.WrapperLookup[MetadataObject.Parent] as Table;
			}
		}



		/// <summary>
		/// CTOR - only called from static factory methods on the class
		/// </summary>
		CalculatedColumn(TOM.CalculatedColumn metadataObject) : base(metadataObject)
		{
		}



		internal override void Undelete(ITabularObjectCollection collection, Type tomObjectType, string tomJson) {
			base.Undelete(collection, tomObjectType, tomJson);
			Reinit();
			ReapplyReferences();
		}
		internal override sealed bool Browsable(string propertyName) {
			// Allow custom overrides to hide a property regardless of its compatibility level requirements:
			if(!base.Browsable(propertyName)) return false;

			switch (propertyName) {

				// Hide properties based on compatibility requirements (inferred from TOM):
				case Properties.PARENT:
					return false;
				
				default:
					return true;
			}
		}

    }

  
	/// <summary>
///             Represents a column in a Table that is based on a DAX expression. A collection of CalculatedTableColumn, under a Table object bound to a partition with Source of type CalculatedPartitionSource, results in a calculated table.
///             </summary>
	[TypeConverter(typeof(DynamicPropertyConverter))]
	public sealed partial class CalculatedTableColumn: Column
			, IClonableObject
	{
	    internal new TOM.CalculatedTableColumn MetadataObject 
		{ 
			get 
			{ 
				return base.MetadataObject as TOM.CalculatedTableColumn; 
		    } 
			set 
			{ 
				base.MetadataObject = value; 
			}
		}

/// <summary>
///             A boolean value indicating whether name of the column is inferred by the server.
///             </summary>
		[DisplayName("Name Inferred")]
		[Category("Options"),Description(@"A boolean value indicating whether name of the column is inferred by the server."),IntelliSense(@"A boolean value indicating whether name of the column is inferred by the server.")]
		public bool IsNameInferred {
			get {
			    return MetadataObject.IsNameInferred;
			}
			set {
				
				var oldValue = IsNameInferred;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ISNAMEINFERRED, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.IsNameInferred = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.ISNAMEINFERRED, oldValue, newValue));
				OnPropertyChanged(Properties.ISNAMEINFERRED, oldValue, newValue);
			}
		}
		private bool ShouldSerializeIsNameInferred() { return false; }
/// <summary>
///             A boolean value indicating whether the data type is inferred.
///             </summary>
		[DisplayName("Data Type Inferred")]
		[Category("Options"),Description(@"A boolean value indicating whether the data type is inferred."),IntelliSense(@"A boolean value indicating whether the data type is inferred.")]
		public bool IsDataTypeInferred {
			get {
			    return MetadataObject.IsDataTypeInferred;
			}
			set {
				
				var oldValue = IsDataTypeInferred;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ISDATATYPEINFERRED, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.IsDataTypeInferred = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.ISDATATYPEINFERRED, oldValue, newValue));
				OnPropertyChanged(Properties.ISDATATYPEINFERRED, oldValue, newValue);
			}
		}
		private bool ShouldSerializeIsDataTypeInferred() { return false; }
/// <summary>
///             Name of the column from which data will be retrieved. The name must match a column returned during processing or refresh, where the partition source is an expression (as the Expression of a CalculatedPartitionSource).
///             </summary>
		[DisplayName("Source Column")]
		[Category("Basic"),Description(@"Name of the column from which data will be retrieved. The name must match a column returned during processing or refresh, where the partition source is an expression (as the Expression of a CalculatedPartitionSource)."),IntelliSense(@"Name of the column from which data will be retrieved. The name must match a column returned during processing or refresh, where the partition source is an expression (as the Expression of a CalculatedPartitionSource).")]
		public string SourceColumn {
			get {
			    return MetadataObject.SourceColumn;
			}
			set {
				
				var oldValue = SourceColumn;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.SOURCECOLUMN, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.SourceColumn = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.SOURCECOLUMN, oldValue, newValue));
				OnPropertyChanged(Properties.SOURCECOLUMN, oldValue, newValue);
			}
		}
		private bool ShouldSerializeSourceColumn() { return false; }
/// <summary>
///             Returns a ColumnOrigin object. Applicable only to non-calculated columns of a calculated table. ColumnOrigin points to another column which is the source of this column' metadata and data.
///             </summary>
		[DisplayName("Column Origin")]
		[Category("Options"),Description(@"Returns a ColumnOrigin object. Applicable only to non-calculated columns of a calculated table. ColumnOrigin points to another column which is the source of this column' metadata and data."),IntelliSense(@"Returns a ColumnOrigin object. Applicable only to non-calculated columns of a calculated table. ColumnOrigin points to another column which is the source of this column' metadata and data.")][Browsable(false)]
		public Column ColumnOrigin {
			get {
				if (MetadataObject.ColumnOrigin == null) return null;
			    return Handler.WrapperLookup[MetadataObject.ColumnOrigin] as Column;
            }
			
		}
		private bool ShouldSerializeColumnOrigin() { return false; }

		internal static CalculatedTableColumn CreateFromMetadata(Table parent, TOM.CalculatedTableColumn metadataObject) {
            // Generate a new LineageTag if an object with the provided lineage tag already exists:
            if(!string.IsNullOrEmpty(metadataObject.LineageTag)) {
                if (parent.Handler.CompatibilityLevel < 1540) metadataObject.LineageTag = null;
                else if (parent.MetadataObject.Columns.FindByLineageTag(metadataObject.LineageTag) != metadataObject) {
                    metadataObject.LineageTag = Guid.NewGuid().ToString();
                }
            }
			var obj = new CalculatedTableColumn(metadataObject);
			parent.Columns.Add(obj);
			
			obj.Init();

			return obj;
		}


		/// <summary>
		/// Creates a new CalculatedTableColumn and adds it to the parent Table.
		/// Also creates the underlying metadataobject and adds it to the TOM tree.
		/// </summary>
		public static CalculatedTableColumn CreateNew(Table parent, string name = null)
		{
			if(!parent.Handler.PowerBIGovernance.AllowCreate(typeof(CalculatedTableColumn))) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(CalculatedTableColumn).GetTypeName()));
			}

			var metadataObject = new TOM.CalculatedTableColumn();
            if(parent.Model.Database.CompatibilityLevel >= 1540) metadataObject.LineageTag = Guid.NewGuid().ToString();
			metadataObject.Name = parent.Columns.GetNewName(string.IsNullOrWhiteSpace(name) ? "New " + typeof(CalculatedTableColumn).GetTypeName() : name);
            InitMetadata(metadataObject, parent);
            var obj = new CalculatedTableColumn(metadataObject);

			parent.Columns.Add(obj);
			
			obj.Init();

			return obj;
		}

        static partial void InitMetadata(TOM.CalculatedTableColumn metadataObject, Table parent);


		/// <summary>
		/// Creates an exact copy of this CalculatedTableColumn object.
		/// </summary>
		[IntelliSense("Creates an exact copy of this CalculatedTableColumn object.")]
		public CalculatedTableColumn Clone(string newName = null, bool includeTranslations = true, Table newParent = null) {
			if(!Handler.PowerBIGovernance.AllowCreate(this.GetType())) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(CalculatedTableColumn).GetTypeName()));
			}

		    Handler.BeginUpdate("Clone CalculatedTableColumn");

			// Create a clone of the underlying metadataobject:
			var tom = MetadataObject.Clone() as TOM.CalculatedTableColumn;

            if(Model.Database.CompatibilityLevel >= 1540 && !string.IsNullOrEmpty(LineageTag)) {
                tom.LineageTag = Guid.NewGuid().ToString();
            }

			// Assign a new, unique name:
			tom.Name = Parent.Columns.GetNewName(string.IsNullOrEmpty(newName) ? tom.Name + " copy" : newName);
				
			// Create the TOM Wrapper object, representing the metadataobject
			CalculatedTableColumn obj = CreateFromMetadata(newParent ?? Parent, tom);

			// Copy translations, if applicable:
			if(includeTranslations) {
				obj.CopyTranslationsFrom(this);
			}
				
			// Copy perspectives:
			obj.InPerspective.CopyFrom(InPerspective);

            Handler.EndUpdate();

            return obj;
		}

		TabularNamedObject IClonableObject.Clone(string newName, bool includeTranslations, TabularNamedObject newParent) 
		{
			return Clone(newName);
		}

	
        internal override void RenewMetadataObject()
        {
            Handler.WrapperLookup.Remove(MetadataObject);
            var json = TOM.JsonSerializer.SerializeObject(MetadataObject, RenewMetadataOptions);
            MetadataObject = TOM.JsonSerializer.DeserializeObject<TOM.CalculatedTableColumn>(json);
            Handler.WrapperLookup.Add(MetadataObject, this);
        }

		///<summary>The parent Table of the current Calculated Table Column.</summary>
		public Table Parent { 
			get {
				return Handler.WrapperLookup[MetadataObject.Parent] as Table;
			}
		}



		/// <summary>
		/// CTOR - only called from static factory methods on the class
		/// </summary>
		CalculatedTableColumn(TOM.CalculatedTableColumn metadataObject) : base(metadataObject)
		{
		}



		internal override void Undelete(ITabularObjectCollection collection, Type tomObjectType, string tomJson) {
			base.Undelete(collection, tomObjectType, tomJson);
			Reinit();
			ReapplyReferences();
		}
		internal override sealed bool Browsable(string propertyName) {
			// Allow custom overrides to hide a property regardless of its compatibility level requirements:
			if(!base.Browsable(propertyName)) return false;

			switch (propertyName) {

				// Hide properties based on compatibility requirements (inferred from TOM):
				case Properties.PARENT:
					return false;
				
				default:
					return true;
			}
		}

    }

  
	/// <summary>
///             Represents a base class of a column object of a Tabular model, used to specify a DataColumn, RowNumberColumn, CalculatedColumn, or CalculatedTableColumn.
///             </summary>
	[TypeConverter(typeof(DynamicPropertyConverter))]
	public abstract partial class Column: TabularNamedObject
			, IFolderObject
			, IHideableObject
			, IErrorMessageObject
			, ITabularTableObject
			, IDescriptionObject
			, IFormattableObject
			, ILineageTagObject
			, IInternalAnnotationObject
			, IInternalExtendedPropertyObject
			, IInternalTabularPerspectiveObject
			, IInternalTranslatableObject
			, ISynonymObject
	{
	    internal new TOM.Column MetadataObject 
		{ 
			get 
			{ 
				return base.MetadataObject as TOM.Column; 
		    } 
			set 
			{ 
				base.MetadataObject = value; 
			}
		}

/// <summary> 
///             For a DataColumn, specifies the data type. See <see href="https://msdn.microsoft.com/library/gg492146.aspx" /> for a list of supported data types.  
///             </summary>
		[DisplayName("Data Type")]
		[Category("Basic"),Description(@"For a DataColumn, specifies the data type. See https://msdn.microsoft.com/library/gg492146.aspx for a list of supported data types."),IntelliSense(@"For a DataColumn, specifies the data type. See https://msdn.microsoft.com/library/gg492146.aspx for a list of supported data types.")][TypeConverter(typeof(DataTypeEnumConverter))]
		public DataType DataType {
			get {
			    return (DataType)MetadataObject.DataType;
			}
			set {
				
				var oldValue = DataType;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DATATYPE, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.DataType = (TOM.DataType)newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DATATYPE, oldValue, newValue));
				OnPropertyChanged(Properties.DATATYPE, oldValue, newValue);
			}
		}
		private bool ShouldSerializeDataType() { return false; }
        private bool CanClearAnnotations() => GetAnnotationsCount() > 0;
        ///<summary>Removes all annotations from this object.</summary>
        [IntelliSense("Removes all annotations from this object.")]
        public void ClearAnnotations()
        {
            Handler.BeginUpdate("Clear annotations");
            foreach(var annotation in GetAnnotations().ToList()) {
                RemoveAnnotation(annotation);
            }
            Handler.EndUpdate();
        }

		///<summary>The collection of Annotations on the current Column.</summary>
        [Browsable(true),NoMultiselect,Category("Metadata"),Description("The collection of Annotations on the current Column."),Editor(typeof(AnnotationCollectionEditor), typeof(UITypeEditor))]
        [PropertyAction(nameof(ClearAnnotations))]
		public AnnotationCollection Annotations { get; private set; }
		///<summary>Gets the value of the annotation with the given index, assuming it exists.</summary>
		[IntelliSense("Gets the value of the annotation with the given index, assuming it exists.")]
		public string GetAnnotation(int index) {
			return MetadataObject.Annotations[index].Value;
		}
		///<summary>Returns true if an annotation with the given name exists. Otherwise false.</summary>
		[IntelliSense("Returns true if an annotation with the given name exists. Otherwise false.")]
		public bool HasAnnotation(string name) {
		    return MetadataObject.Annotations.ContainsName(name);
		}
		///<summary>Gets the value of the annotation with the given name. Returns null if no such annotation exists.</summary>
		[IntelliSense("Gets the value of the annotation with the given name. Returns null if no such annotation exists.")]
		public string GetAnnotation(string name) {
		    return HasAnnotation(name) ? MetadataObject.Annotations[name].Value : null;
		}
		///<summary>Sets the value of the annotation with the given index, assuming it exists.</summary>
		[IntelliSense("Sets the value of the annotation with the given index, assuming it exists.")]
		public void SetAnnotation(int index, string value) {
		    SetAnnotation(index, value, true);
		}
		internal void SetAnnotation(int index, string value, bool undoable) {
		    var name = MetadataObject.Annotations[index].Name;
			SetAnnotation(name, value, undoable);
		}
		void IInternalAnnotationObject.SetAnnotation(int index, string value, bool undoable) {
			SetAnnotation(index, value, undoable);
		}
		///<summary>Returns a unique name for a new annotation.</summary>
		public string GetNewAnnotationName() {
			return MetadataObject.Annotations.GetNewName("New Annotation");
		}
		///<summary>Sets the value of the annotation having the given name. If no such annotation exists, it will be created. If value is set to null, the annotation will be removed.</summary>
		[IntelliSense("Sets the value of the annotation having the given name. If no such annotation exists, it will be created. If value is set to null, the annotation will be removed.")]
		public void SetAnnotation(string name, string value) {
		    SetAnnotation(name, value, true);
		}
		internal void SetAnnotation(string name, string value, bool undoable) {
			if(name == null) name = GetNewAnnotationName();

			if(value == null) {
				// Remove annotation if set to null:
				RemoveAnnotation(name, undoable);
				return;
			}

			if(undoable) {
 				if(GetAnnotation(name) == value) return;
				bool undoable2 = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + value, ref undoable2, ref cancel);
				if (cancel) return;
			}

			if(MetadataObject.Annotations.Contains(name)) {
				// Change existing annotation:

				var oldValue = GetAnnotation(name);
				MetadataObject.Annotations[name].Value = value;
				if (undoable) {
					Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, oldValue));
					OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, name + ":" + value);
				}
			} else {
				// Add new annotation:

				MetadataObject.Annotations.Add(new TOM.Annotation{ Name = name, Value = value });
				if (undoable) {
					Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, null));
					OnPropertyChanged(Properties.ANNOTATIONS, null, name + ":" + value);
				}
			}
		}
		void IInternalAnnotationObject.SetAnnotation(string name, string value, bool undoable) {
			this.SetAnnotation(name, value, undoable);
		}
		///<summary>Remove an annotation by the given name.</summary>
		[IntelliSense("Remove an annotation by the given name.")]
		public void RemoveAnnotation(string name) {
		    RemoveAnnotation(name, true);
		}
		internal void RemoveAnnotation(string name, bool undoable) {
			if(MetadataObject.Annotations.Contains(name)) {
				if(undoable) 
				{
				    bool undoable2 = true;
				    bool cancel = false;
				    OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + GetAnnotation(name), ref undoable2, ref cancel);
				    if (cancel) return;
				}

			    var oldValue = MetadataObject.Annotations[name].Value;
				MetadataObject.Annotations.Remove(name);

				if (undoable) 
				{
					Handler.UndoManager.Add(new UndoAnnotationAction(this, name, null, oldValue));
					OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, null);
			    }
			}
		}
		void IInternalAnnotationObject.RemoveAnnotation(string name, bool undoable) {
			this.RemoveAnnotation(name, undoable);
		}
		///<summary>Gets the number of annotations on the current Column.</summary>
		[IntelliSense("Gets the number of annotations on the current Column.")]
		public int GetAnnotationsCount() {
			return MetadataObject.Annotations.Count;
		}
		///<summary>Gets a collection of all annotation names on the current Column.</summary>
		[IntelliSense("Gets a collection of all annotation names on the current Column.")]
		public IEnumerable<string> GetAnnotations() {
			return MetadataObject.Annotations.Select(a => a.Name);
		}

		        private bool CanClearExtendedProperties() => GetExtendedPropertyCount() > 0;
        ///<summary>Removes all Extended Properties from this object.</summary>
        [IntelliSense("Removes all Extended Properties from this object.")]
        public void ClearExtendedProperties()
        {
            Handler.BeginUpdate("Clear extended properties");
            foreach(var extendedProperty in GetExtendedProperties().ToList()) {
                RemoveExtendedProperty(extendedProperty);
            }
            Handler.EndUpdate();
        }

		///<summary>The collection of Extended Properties on the current Column.</summary>
        [DisplayName("Extended Properties"),NoMultiselect,Category("Metadata"),Description("The collection of Extended Properties on the current Column."),Editor(typeof(ExtendedPropertyCollectionEditor), typeof(UITypeEditor))]
        [PropertyAction(nameof(ClearExtendedProperties))]
		public ExtendedPropertyCollection ExtendedProperties { get; private set; }

		///<summary>Returns true if an ExtendedProperty with the given name exists. Otherwise false.</summary>
		[IntelliSense("Returns true if an ExtendedProperty with the given name exists. Otherwise false.")]
		public bool HasExtendedProperty(string name) {
		    return MetadataObject.ExtendedProperties.ContainsName(name);
		}
		///<summary>Gets the type of the ExtendedProperty with the given index, assuming it exists.</summary>
		public ExtendedPropertyType GetExtendedPropertyType(int index) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[index].Type;
		}
		///<summary>Gets the type of the ExtendedProperty with the given name, assuming it exists.</summary>
		public ExtendedPropertyType GetExtendedPropertyType(string name) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[name].Type;
		}
		///<summary>Gets the value of the ExtendedProperty with the given index, assuming it exists.</summary>
		public string GetExtendedProperty(int index) {
			var ep = MetadataObject.ExtendedProperties[index];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		///<summary>Gets the value of the ExtendedProperty with the given name. Returns null if no such ExtendedProperty exists.</summary>
		[IntelliSense("Gets the value of the ExtendedProperty with the given name. Returns null if no such ExtendedProperty exists.")]
		public string GetExtendedProperty(string name) {
		    if(!HasExtendedProperty(name)) return null;
			var ep = MetadataObject.ExtendedProperties[name];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		///<summary>Sets the value of the ExtendedProperty with the given index, optionally specifiying the type (string or JSON) of the ExtendedProperty.</summary>
		public void SetExtendedProperty(int index, string value, ExtendedPropertyType type) {
			SetExtendedProperty(index, value, type, true);
		}
		void IInternalExtendedPropertyObject.SetExtendedProperty(int index, string value, ExtendedPropertyType type, bool undoable) {
			SetExtendedProperty(index, value, type, undoable);
		}
		internal void SetExtendedProperty(int index, string value, ExtendedPropertyType type, bool undoable) {
			var name = MetadataObject.ExtendedProperties[index].Name;
			SetExtendedProperty(name, value, type, undoable);
		}
		///<summary>Returns a unique name for a new ExtendedProperty.</summary>
		public string GetNewExtendedPropertyName() {
			return MetadataObject.ExtendedProperties.GetNewName("New ExtendedProperty");
		}
		///<summary>Sets the value of the ExtendedProperty having the given name. If no such ExtendedProperty exists, it will be created. If value is set to null, the ExtendedProperty will be removed.</summary>
		[IntelliSense("Sets the value of the ExtendedProperty having the given name. If no such ExtendedProperty exists, it will be created. If value is set to null, the ExtendedProperty will be removed.")]
		public void SetExtendedProperty(string name, string value, ExtendedPropertyType type) {
			SetExtendedProperty(name, value, type, true);
		}
		internal void SetExtendedProperty(string name, string value, ExtendedPropertyType type, bool undoable) {
			if(name == null) name = GetNewExtendedPropertyName();

			if(value == null) {
				// Remove ExtendedProperty if set to null:
				RemoveExtendedProperty(name);
				return;
			}

			if(GetExtendedProperty(name) == value) return;
			if(undoable) {
				bool cancel = false;
				OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + value, ref undoable, ref cancel);
				if (cancel) return;
			}

			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Change existing ExtendedProperty:
				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				var ep = MetadataObject.ExtendedProperties[name];
				if (ep is TOM.JsonExtendedProperty)
					(ep as TOM.JsonExtendedProperty).Value = value;
				else 
					(ep as TOM.StringExtendedProperty).Value = value;
					
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, name + ":" + value);
			} else {
				// Add new ExtendedProperty:
				if (type == ExtendedPropertyType.Json)
					MetadataObject.ExtendedProperties.Add(new TOM.JsonExtendedProperty{ Name = name, Value = value });
				else
					MetadataObject.ExtendedProperties.Add(new TOM.StringExtendedProperty{ Name = name, Value = value });

				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, null, type));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, null, name + ":" + value);
			}
		}
		void IInternalExtendedPropertyObject.SetExtendedProperty(string name, string value, ExtendedPropertyType type, bool undoable) {
			this.SetExtendedProperty(name, value, type, undoable);
		}

		///<summary>Remove an ExtendedProperty by the given name.</summary>
		[IntelliSense("Remove an ExtendedProperty by the given name.")]
		public void RemoveExtendedProperty(string name) {
			RemoveExtendedProperty(name, true);
		}

		internal void RemoveExtendedProperty(string name, bool undoable) {
			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Get current value:
				if(undoable) {
					bool cancel = false;
					OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + GetExtendedProperty(name), ref undoable, ref cancel);
					if (cancel) return;
				}

				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				MetadataObject.ExtendedProperties.Remove(name);

				// Undo-handling:
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, null, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, null);
			}
		}
		void IInternalExtendedPropertyObject.RemoveExtendedProperty(string name, bool undoable) {
			this.RemoveExtendedProperty(name, undoable);
		}
		///<summary>Gets the number of ExtendedProperties on the current object.</summary>
		[IntelliSense("Gets the number of ExtendedProperties on the current object.")]
		public int GetExtendedPropertyCount() {
			return MetadataObject.ExtendedProperties.Count;
		}
		///<summary>Gets a collection of all ExtendedProperty names on the current object.</summary>
		[IntelliSense("Gets a collection of all ExtendedProperty names on the current object.")]
		public IEnumerable<string> GetExtendedProperties() {
			return MetadataObject.ExtendedProperties.Select(a => a.Name);
		}

		/// <summary>
///             Specifies the type of data contained in the column so that you can add custom behaviors based on column type. There are 248 possible values. The first ten are Invalid (-1), All (1), Regular (2), Image (3), ImageBMP (4), ImageGIF (5), ImageJPG (6), ImagePNG (7), ImageTIFF (8), ImageURL (9), Id (10). For the rest, please refer to the MS-SSAS-T SQL Server Analysis Services Tabular Protocol documentation on MSDN.
///             </summary>
		[DisplayName("Data Category")]
		[Category("Options"),Description(@"Specifies the type of data contained in the column so that you can add custom behaviors based on column type. There are 248 possible values. The first ten are Invalid (-1), All (1), Regular (2), Image (3), ImageBMP (4), ImageGIF (5), ImageJPG (6), ImagePNG (7), ImageTIFF (8), ImageURL (9), Id (10). For the rest, please refer to the MS-SSAS-T SQL Server Analysis Services Tabular Protocol documentation on MSDN."),IntelliSense(@"Specifies the type of data contained in the column so that you can add custom behaviors based on column type. There are 248 possible values. The first ten are Invalid (-1), All (1), Regular (2), Image (3), ImageBMP (4), ImageGIF (5), ImageJPG (6), ImagePNG (7), ImageTIFF (8), ImageURL (9), Id (10). For the rest, please refer to the MS-SSAS-T SQL Server Analysis Services Tabular Protocol documentation on MSDN.")][TypeConverter(typeof(ColumnDataCategoryConverter))]
		public string DataCategory {
			get {
			    return MetadataObject.DataCategory;
			}
			set {
				
				var oldValue = DataCategory;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DATACATEGORY, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.DataCategory = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DATACATEGORY, oldValue, newValue));
				OnPropertyChanged(Properties.DATACATEGORY, oldValue, newValue);
			}
		}
		private bool ShouldSerializeDataCategory() { return false; }
/// <summary>
///             The description of the column, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio.
///             </summary>
		[DisplayName("Description")]
		[Category("Basic"),Description(@"The description of the column, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio."),IntelliSense(@"The description of the column, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio.")][Editor(typeof(System.ComponentModel.Design.MultilineStringEditor), typeof(System.Drawing.Design.UITypeEditor))]
		public string Description {
			get {
			    return MetadataObject.Description;
			}
			set {
				
				var oldValue = Description;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DESCRIPTION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.Description = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DESCRIPTION, oldValue, newValue));
				OnPropertyChanged(Properties.DESCRIPTION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeDescription() { return false; }
/// <summary>
///             A boolean value that indicates whether a column is treated as hidden by client visualization tools. True if the column is treated as hidden; otherwise false.
///             </summary>
		[DisplayName("Hidden")]
		[Category("Basic"),Description(@"A boolean value that indicates whether a column is treated as hidden by client visualization tools. True if the column is treated as hidden; otherwise false."),IntelliSense(@"A boolean value that indicates whether a column is treated as hidden by client visualization tools. True if the column is treated as hidden; otherwise false.")]
		public bool IsHidden {
			get {
			    return MetadataObject.IsHidden;
			}
			set {
				
				var oldValue = IsHidden;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ISHIDDEN, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.IsHidden = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.ISHIDDEN, oldValue, newValue));
				OnPropertyChanged(Properties.ISHIDDEN, oldValue, newValue);
				Handler.UpdateObject(this);
			}
		}
		private bool ShouldSerializeIsHidden() { return false; }
/// <summary>
///             Enumerates the state of the column. Possible values include the following. Ready (1) The column is queryable and has up-to-date data. NoData (3) The column is queryable but has no data. This state is applicable only to columns of the type Data. CalculationNeeded (4) The column is not queryable and needs to be refreshed (that is, recalculated) to become functional. This state applies only to columns of the type Calculated or CalculatedTableColumn. SemanticError (5) The column is in an error state because of an invalid expression. The column is not queryable. This state applies only to columns of the type Calculated or CalculatedTableColumn. EvaluationError (6) The column is in an error state because of an error during expression evaluation. The column is not queryable.  This state applies only to columns of the type Calculated or CalculatedTableColumn. DependencyError (7) The column is in an error state because some of its calculation dependencies are in an error state.  The column is not queryable. This state applies only to columns of the type Calculated or CalculatedTableColumn. Incomplete (8) Some parts of the column have no data, and the column needs to be refreshed to bring the data in. The column is queryable. This state applies only to columns of the type Data. SyntaxError (9) The column is in an error state because of a syntax error in its expression. The column is not queryable. This state applies only to columns of the type Calculated.
///             </summary>
		[DisplayName("State")]
		[Category("Metadata"),Description(@"Enumerates the state of the column. Possible values include the following. Ready (1) The column is queryable and has up-to-date data. NoData (3) The column is queryable but has no data. This state is applicable only to columns of the type Data. CalculationNeeded (4) The column is not queryable and needs to be refreshed (that is, recalculated) to become functional. This state applies only to columns of the type Calculated or CalculatedTableColumn. SemanticError (5) The column is in an error state because of an invalid expression. The column is not queryable. This state applies only to columns of the type Calculated or CalculatedTableColumn. EvaluationError (6) The column is in an error state because of an error during expression evaluation. The column is not queryable.  This state applies only to columns of the type Calculated or CalculatedTableColumn. DependencyError (7) The column is in an error state because some of its calculation dependencies are in an error state.  The column is not queryable. This state applies only to columns of the type Calculated or CalculatedTableColumn. Incomplete (8) Some parts of the column have no data, and the column needs to be refreshed to bring the data in. The column is queryable. This state applies only to columns of the type Data. SyntaxError (9) The column is in an error state because of a syntax error in its expression. The column is not queryable. This state applies only to columns of the type Calculated."),IntelliSense(@"Enumerates the state of the column. Possible values include the following. Ready (1) The column is queryable and has up-to-date data. NoData (3) The column is queryable but has no data. This state is applicable only to columns of the type Data. CalculationNeeded (4) The column is not queryable and needs to be refreshed (that is, recalculated) to become functional. This state applies only to columns of the type Calculated or CalculatedTableColumn. SemanticError (5) The column is in an error state because of an invalid expression. The column is not queryable. This state applies only to columns of the type Calculated or CalculatedTableColumn. EvaluationError (6) The column is in an error state because of an error during expression evaluation. The column is not queryable.  This state applies only to columns of the type Calculated or CalculatedTableColumn. DependencyError (7) The column is in an error state because some of its calculation dependencies are in an error state.  The column is not queryable. This state applies only to columns of the type Calculated or CalculatedTableColumn. Incomplete (8) Some parts of the column have no data, and the column needs to be refreshed to bring the data in. The column is queryable. This state applies only to columns of the type Data. SyntaxError (9) The column is in an error state because of a syntax error in its expression. The column is not queryable. This state applies only to columns of the type Calculated.")]
		public ObjectState State {
			get {
			    return (ObjectState)MetadataObject.State;
			}
			
		}
		private bool ShouldSerializeState() { return false; }
/// <summary>
///             A boolean value that indicates whether the column contains only unique values. True if the values are unique; otherwise false.
///             </summary>
		[DisplayName("Unique")]
		[Category("Options"),Description(@"A boolean value that indicates whether the column contains only unique values. True if the values are unique; otherwise false."),IntelliSense(@"A boolean value that indicates whether the column contains only unique values. True if the values are unique; otherwise false.")]
		public bool IsUnique {
			get {
			    return MetadataObject.IsUnique;
			}
			set {
				
				var oldValue = IsUnique;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ISUNIQUE, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.IsUnique = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.ISUNIQUE, oldValue, newValue));
				OnPropertyChanged(Properties.ISUNIQUE, oldValue, newValue);
			}
		}
		private bool ShouldSerializeIsUnique() { return false; }
/// <summary>
///             A boolean value that indicates whether the column is a key of the table. True if the column is a key of the table; otherwise false.
///             </summary>
		[DisplayName("Key")]
		[Category("Options"),Description(@"A boolean value that indicates whether the column is a key of the table. True if the column is a key of the table; otherwise false."),IntelliSense(@"A boolean value that indicates whether the column is a key of the table. True if the column is a key of the table; otherwise false.")]
		public bool IsKey {
			get {
			    return MetadataObject.IsKey;
			}
			set {
				
				var oldValue = IsKey;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ISKEY, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.IsKey = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.ISKEY, oldValue, newValue));
				OnPropertyChanged(Properties.ISKEY, oldValue, newValue);
			}
		}
		private bool ShouldSerializeIsKey() { return false; }
/// <summary>
///             If <b>false</b>, the column cannot contain nulls. Even if <b>true</b>, it may still not allow nulls if it's a key column.
///             </summary>
		[DisplayName("Nullable")]
		[Category("Options"),Description(@"If <b>false</b>, the column cannot contain nulls. Even if <b>true</b>, it may still not allow nulls if it's a key column."),IntelliSense(@"If <b>false</b>, the column cannot contain nulls. Even if <b>true</b>, it may still not allow nulls if it's a key column.")]
		public bool IsNullable {
			get {
			    return MetadataObject.IsNullable;
			}
			set {
				
				var oldValue = IsNullable;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ISNULLABLE, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.IsNullable = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.ISNULLABLE, oldValue, newValue));
				OnPropertyChanged(Properties.ISNULLABLE, oldValue, newValue);
			}
		}
		private bool ShouldSerializeIsNullable() { return false; }
/// <summary>
///             Specifies the text alignment of the column in report visualizations. The possible values are Default (1), Left (2), Right (3), Center (4).
///             </summary>
		[DisplayName("Alignment")]
		[Category("Options"),Description(@"Specifies the text alignment of the column in report visualizations. The possible values are Default (1), Left (2), Right (3), Center (4)."),IntelliSense(@"Specifies the text alignment of the column in report visualizations. The possible values are Default (1), Left (2), Right (3), Center (4).")]
		public Alignment Alignment {
			get {
			    return (Alignment)MetadataObject.Alignment;
			}
			set {
				
				var oldValue = Alignment;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ALIGNMENT, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.Alignment = (TOM.Alignment)newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.ALIGNMENT, oldValue, newValue));
				OnPropertyChanged(Properties.ALIGNMENT, oldValue, newValue);
			}
		}
		private bool ShouldSerializeAlignment() { return false; }
/// <summary>
///             Determines whether you can place this column in the DefaultDetails collection of the Table. This collection is an ordered set of Column types. A positive value indicates participation in the collection. The collection is sorted in ascending order of this element. The DefaultDetails collection is returned as part of the CSDL metadata returned by the DISCOVER_CSDL_METADATA operation.
///             </summary>
		[DisplayName("Table Detail Position")]
		[Category("Options"),Description(@"Determines whether you can place this column in the DefaultDetails collection of the Table. This collection is an ordered set of Column types. A positive value indicates participation in the collection. The collection is sorted in ascending order of this element. The DefaultDetails collection is returned as part of the CSDL metadata returned by the DISCOVER_CSDL_METADATA operation."),IntelliSense(@"Determines whether you can place this column in the DefaultDetails collection of the Table. This collection is an ordered set of Column types. A positive value indicates participation in the collection. The collection is sorted in ascending order of this element. The DefaultDetails collection is returned as part of the CSDL metadata returned by the DISCOVER_CSDL_METADATA operation.")]
		public int TableDetailPosition {
			get {
			    return MetadataObject.TableDetailPosition;
			}
			set {
				
				var oldValue = TableDetailPosition;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.TABLEDETAILPOSITION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.TableDetailPosition = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.TABLEDETAILPOSITION, oldValue, newValue));
				OnPropertyChanged(Properties.TABLEDETAILPOSITION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeTableDetailPosition() { return false; }
/// <summary>
///             A boolean value that indicates whether this column is included in the DisplayKey element in CSDL.
///             </summary>
		[DisplayName("Default Label")]
		[Category("Options"),Description(@"A boolean value that indicates whether this column is included in the DisplayKey element in CSDL."),IntelliSense(@"A boolean value that indicates whether this column is included in the DisplayKey element in CSDL.")]
		public bool IsDefaultLabel {
			get {
			    return MetadataObject.IsDefaultLabel;
			}
			set {
				
				var oldValue = IsDefaultLabel;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ISDEFAULTLABEL, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.IsDefaultLabel = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.ISDEFAULTLABEL, oldValue, newValue));
				OnPropertyChanged(Properties.ISDEFAULTLABEL, oldValue, newValue);
			}
		}
		private bool ShouldSerializeIsDefaultLabel() { return false; }
/// <summary>
///             A boolean value that indicates whether this column is returned as the DefaultImage property in CSDL.
///             </summary>
		[DisplayName("Default Image")]
		[Category("Options"),Description(@"A boolean value that indicates whether this column is returned as the DefaultImage property in CSDL."),IntelliSense(@"A boolean value that indicates whether this column is returned as the DefaultImage property in CSDL.")]
		public bool IsDefaultImage {
			get {
			    return MetadataObject.IsDefaultImage;
			}
			set {
				
				var oldValue = IsDefaultImage;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ISDEFAULTIMAGE, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.IsDefaultImage = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.ISDEFAULTIMAGE, oldValue, newValue));
				OnPropertyChanged(Properties.ISDEFAULTIMAGE, oldValue, newValue);
			}
		}
		private bool ShouldSerializeIsDefaultImage() { return false; }
/// <summary>
///             A value indicating the default function, if any, used to aggregate this field. The possible values are Default (1), None (2), Sum (3), Min (4), Max (5), Count (6), Average (7), DistinctCount (8). If unspecified, Default is assumed for numeric fields, None for all other fields.
///             </summary>
		[DisplayName("Summarize By")]
		[Category("Basic"),Description(@"A value indicating the default function, if any, used to aggregate this field. The possible values are Default (1), None (2), Sum (3), Min (4), Max (5), Count (6), Average (7), DistinctCount (8). If unspecified, Default is assumed for numeric fields, None for all other fields."),IntelliSense(@"A value indicating the default function, if any, used to aggregate this field. The possible values are Default (1), None (2), Sum (3), Min (4), Max (5), Count (6), Average (7), DistinctCount (8). If unspecified, Default is assumed for numeric fields, None for all other fields.")]
		public AggregateFunction SummarizeBy {
			get {
			    return (AggregateFunction)MetadataObject.SummarizeBy;
			}
			set {
				
				var oldValue = SummarizeBy;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.SUMMARIZEBY, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.SummarizeBy = (TOM.AggregateFunction)newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.SUMMARIZEBY, oldValue, newValue));
				OnPropertyChanged(Properties.SUMMARIZEBY, oldValue, newValue);
			}
		}
		private bool ShouldSerializeSummarizeBy() { return false; }
/// <summary>
///             Specifies the data binding. Values include Data (1) where the contents of this column come from a DataSource, Calculated (2) where the contents are computed from an expression after the Data columns have been populated, RowNumber (3) where the column is an internal column representing the row number, or CalculatedTableColumn (4) where tables that are based on a calculated expression will automatically infer and generate the columns in the table.
///             </summary>
		[DisplayName("Type")]
		[Category("Options"),Description(@"Specifies the data binding. Values include Data (1) where the contents of this column come from a DataSource, Calculated (2) where the contents are computed from an expression after the Data columns have been populated, RowNumber (3) where the column is an internal column representing the row number, or CalculatedTableColumn (4) where tables that are based on a calculated expression will automatically infer and generate the columns in the table."),IntelliSense(@"Specifies the data binding. Values include Data (1) where the contents of this column come from a DataSource, Calculated (2) where the contents are computed from an expression after the Data columns have been populated, RowNumber (3) where the column is an internal column representing the row number, or CalculatedTableColumn (4) where tables that are based on a calculated expression will automatically infer and generate the columns in the table.")][Browsable(false)]
		public ColumnType Type {
			get {
			    return (ColumnType)MetadataObject.Type;
			}
			
		}
		private bool ShouldSerializeType() { return false; }
/// <summary>
///             A string that specifies the format of the column contents. 
///             </summary>
		[DisplayName("Format String")]
		[Category("Basic"),Description(@"A string that specifies the format of the column contents."),IntelliSense(@"A string that specifies the format of the column contents.")][TypeConverter(typeof(FormatStringConverter))]
		public string FormatString {
			get {
			    return MetadataObject.FormatString;
			}
			set {
				
				var oldValue = FormatString;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.FORMATSTRING, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.FormatString = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.FORMATSTRING, oldValue, newValue));
				OnPropertyChanged(Properties.FORMATSTRING, oldValue, newValue);
			}
		}
		private bool ShouldSerializeFormatString() { return false; }
/// <summary>
///             A boolean value that indicates whether the column can be excluded from usage in MDX query tools. False if the column can be excluded from usage in MDX query tools; otherwise true.
///             </summary>
		[DisplayName("Available In MDX")]
		[Category("Options"),Description(@"A boolean value that indicates whether the column can be excluded from usage in MDX query tools. False if the column can be excluded from usage in MDX query tools; otherwise true."),IntelliSense(@"A boolean value that indicates whether the column can be excluded from usage in MDX query tools. False if the column can be excluded from usage in MDX query tools; otherwise true.")]
		public bool IsAvailableInMDX {
			get {
			    return MetadataObject.IsAvailableInMDX;
			}
			set {
				
				var oldValue = IsAvailableInMDX;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ISAVAILABLEINMDX, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.IsAvailableInMDX = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.ISAVAILABLEINMDX, oldValue, newValue));
				OnPropertyChanged(Properties.ISAVAILABLEINMDX, oldValue, newValue);
			}
		}
		private bool ShouldSerializeIsAvailableInMDX() { return false; }
/// <summary>
///             Specifies the grouping behavior used for building a hierarchy. True groups by entity key. False groups by value.
///             </summary>
		[DisplayName("Keep Unique Rows")]
		[Category("Options"),Description(@"Specifies the grouping behavior used for building a hierarchy. True groups by entity key. False groups by value."),IntelliSense(@"Specifies the grouping behavior used for building a hierarchy. True groups by entity key. False groups by value.")]
		public bool KeepUniqueRows {
			get {
			    return MetadataObject.KeepUniqueRows;
			}
			set {
				
				var oldValue = KeepUniqueRows;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.KEEPUNIQUEROWS, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.KeepUniqueRows = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.KEEPUNIQUEROWS, oldValue, newValue));
				OnPropertyChanged(Properties.KEEPUNIQUEROWS, oldValue, newValue);
			}
		}
		private bool ShouldSerializeKeepUniqueRows() { return false; }
/// <summary>
///             Indicates the visual position of the column, defined as a relative ordering rather than a strict ordering (example: 10, 20, 40, 50). It allows client applications to maintain a consistent column position.
///             </summary>
		[DisplayName("Display Ordinal")]
		[Category("Options"),Description(@"Indicates the visual position of the column, defined as a relative ordering rather than a strict ordering (example: 10, 20, 40, 50). It allows client applications to maintain a consistent column position."),IntelliSense(@"Indicates the visual position of the column, defined as a relative ordering rather than a strict ordering (example: 10, 20, 40, 50). It allows client applications to maintain a consistent column position.")]
		public int DisplayOrdinal {
			get {
			    return MetadataObject.DisplayOrdinal;
			}
			set {
				
				var oldValue = DisplayOrdinal;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DISPLAYORDINAL, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.DisplayOrdinal = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DISPLAYORDINAL, oldValue, newValue));
				OnPropertyChanged(Properties.DISPLAYORDINAL, oldValue, newValue);
			}
		}
		private bool ShouldSerializeDisplayOrdinal() { return false; }
/// <summary>
///             A string that explains the error state associated with the current object. It is set by the engine only when the state of the object is one of these three values: SemanticError, DependencyError, or EvaluationError. It is applicable only to columns of the type Calculated or CalculatedTableColumn. It will be empty for other column objects.
///             </summary>
		[DisplayName("Error Message")]
		[Category("Metadata"),Description(@"A string that explains the error state associated with the current object. It is set by the engine only when the state of the object is one of these three values: SemanticError, DependencyError, or EvaluationError. It is applicable only to columns of the type Calculated or CalculatedTableColumn. It will be empty for other column objects."),IntelliSense(@"A string that explains the error state associated with the current object. It is set by the engine only when the state of the object is one of these three values: SemanticError, DependencyError, or EvaluationError. It is applicable only to columns of the type Calculated or CalculatedTableColumn. It will be empty for other column objects.")]
		public string ErrorMessage {
			get {
			    return MetadataObject.ErrorMessage;
			}
			
		}
		private bool ShouldSerializeErrorMessage() { return false; }
/// <summary>
///             The original data type of the column as defined in the language of the data source. This data type is used to generate queries directly against the data source, for example in DirectQuery mode.
///             </summary>
		[DisplayName("Source Provider Type")]
		[Category("Options"),Description(@"The original data type of the column as defined in the language of the data source. This data type is used to generate queries directly against the data source, for example in DirectQuery mode."),IntelliSense(@"The original data type of the column as defined in the language of the data source. This data type is used to generate queries directly against the data source, for example in DirectQuery mode.")]
		public string SourceProviderType {
			get {
			    return MetadataObject.SourceProviderType;
			}
			set {
				
				var oldValue = SourceProviderType;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.SOURCEPROVIDERTYPE, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.SourceProviderType = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.SOURCEPROVIDERTYPE, oldValue, newValue));
				OnPropertyChanged(Properties.SOURCEPROVIDERTYPE, oldValue, newValue);
			}
		}
		private bool ShouldSerializeSourceProviderType() { return false; }
/// <summary>
///             Defines the display folder for the column, for use by clients.
///             </summary>
		[DisplayName("Display Folder")]
		[Category("Basic"),Description(@"Defines the display folder for the column, for use by clients."),IntelliSense(@"Defines the display folder for the column, for use by clients.")][Editor(typeof(CustomDialogEditor), typeof(System.Drawing.Design.UITypeEditor))]
		public string DisplayFolder {
			get {
			    return MetadataObject.DisplayFolder;
			}
			set {
				if(value.Contains(@"\\")) throw new Exception("Display Folder names cannot be blank.");
				var oldValue = DisplayFolder;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DISPLAYFOLDER, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.DisplayFolder = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DISPLAYFOLDER, oldValue, newValue));
				OnPropertyChanged(Properties.DISPLAYFOLDER, oldValue, newValue);
				Handler.UpdateFolders(Table);
			}
		}
		private bool ShouldSerializeDisplayFolder() { return false; }
        /// <summary>
        /// Collection of localized Display Folders for the current Column.
        /// </summary>
        [Browsable(true),DisplayName("Translated Display Folders"),Description("Shows all translated Display Folders of the current Column."),Category("Translations, Perspectives, Security")]
	    public TranslationIndexer TranslatedDisplayFolders { private set; get; }
/// <summary>
///             This property allows an encoding hint to be specified for the column. A numeric column may use either value-based encoding or hash-based encoding. Usually the server will automatically attempt detect which encoding to use, but re-encoding may occur later. This property allows hinting to the server that it should start with a different encoding type.
///             </summary><remarks>This property is only supported when the compatibility level of the database is at 1400 or above.</remarks>
		[DisplayName("Encoding Hint")]
		[Category("Options"),Description(@"This property allows an encoding hint to be specified for the column. A numeric column may use either value-based encoding or hash-based encoding. Usually the server will automatically attempt detect which encoding to use, but re-encoding may occur later. This property allows hinting to the server that it should start with a different encoding type."),IntelliSense(@"This property allows an encoding hint to be specified for the column. A numeric column may use either value-based encoding or hash-based encoding. Usually the server will automatically attempt detect which encoding to use, but re-encoding may occur later. This property allows hinting to the server that it should start with a different encoding type.")]
		public EncodingHintType EncodingHint {
			get {
			    return (EncodingHintType)MetadataObject.EncodingHint;
			}
			set {
				
				var oldValue = EncodingHint;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ENCODINGHINT, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.EncodingHint = (TOM.EncodingHintType)newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.ENCODINGHINT, oldValue, newValue));
				OnPropertyChanged(Properties.ENCODINGHINT, oldValue, newValue);
			}
		}
		private bool ShouldSerializeEncodingHint() { return false; }
/// <summary>
///             A tag that represents the lineage of the object.
///             </summary><remarks>This property is only supported when the compatibility level of the database is at 1540 or above.</remarks>
		[DisplayName("Lineage Tag")]
		[Category("Options"),Description(@"A tag that represents the lineage of the object."),IntelliSense(@"A tag that represents the lineage of the object.")]
		public string LineageTag {
			get {
			    return MetadataObject.LineageTag;
			}
			set {
				
				var oldValue = LineageTag;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.LINEAGETAG, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.LineageTag = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.LINEAGETAG, oldValue, newValue));
				OnPropertyChanged(Properties.LINEAGETAG, oldValue, newValue);
			}
		}
		private bool ShouldSerializeLineageTag() { return false; }
/// <summary>
///             A tag that represents the lineage of the source for the object.
///             </summary><remarks>This property is only supported when the compatibility level of the database is at 1550 or above.</remarks>
		[DisplayName("Source Lineage Tag")]
		[Category("Options"),Description(@"A tag that represents the lineage of the source for the object."),IntelliSense(@"A tag that represents the lineage of the source for the object.")]
		public string SourceLineageTag {
			get {
			    return MetadataObject.SourceLineageTag;
			}
			set {
				
				var oldValue = SourceLineageTag;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.SOURCELINEAGETAG, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.SourceLineageTag = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.SOURCELINEAGETAG, oldValue, newValue));
				OnPropertyChanged(Properties.SOURCELINEAGETAG, oldValue, newValue);
			}
		}
		private bool ShouldSerializeSourceLineageTag() { return false; }
		///<summary>The parent table of the current Column.</summary>
		[Browsable(false)]
		public Table Table
		{ 
			get 
			{ 
				TabularObject t = null;
				if(MetadataObject == null || MetadataObject.Table == null) return null;
				if(!Handler.WrapperLookup.TryGetValue(MetadataObject.Table, out t)) {
				    if(!MetadataObject.Table.IsRemoved)
						t = Model.Tables[MetadataObject.Table.Name];
				}
				return t as Table;
			} 
		}
/// <summary>
///             Indicates that the column defining this property will be sorted by the values of the column referenced by this property.
///             </summary>
		[DisplayName("Sort By Column")]
		[Category("Basic"),Description(@"Indicates that the column defining this property will be sorted by the values of the column referenced by this property."),IntelliSense(@"Indicates that the column defining this property will be sorted by the values of the column referenced by this property.")][Editor(typeof(CustomDialogEditor), typeof(System.Drawing.Design.UITypeEditor)), TypeConverter(typeof(ColumnConverter))]
		public Column SortByColumn {
			get {
				if (MetadataObject.SortByColumn == null) return null;
			    return Handler.WrapperLookup[MetadataObject.SortByColumn] as Column;
            }
			set {
				
				var oldValue = SortByColumn;
				var newValue = value;
				if (oldValue?.MetadataObject == newValue?.MetadataObject) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.SORTBYCOLUMN, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.SortByColumn = value == null ? null : Table.Columns[value.MetadataObject.Name].MetadataObject;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.SORTBYCOLUMN, oldValue, newValue));
				OnPropertyChanged(Properties.SORTBYCOLUMN, oldValue, newValue);
			}
		}
		private bool ShouldSerializeSortByColumn() { return false; }

        /// <Summary>
		/// Collection of perspectives in which this Column is visible.
		/// </Summary>
		[Browsable(true),DisplayName("Shown in Perspective"), Description("Provides an easy way to include or exclude the current Column from the perspectives of the model."), Category("Translations, Perspectives, Security")]
        public PerspectiveColumnIndexer InPerspective { get; private set; }
		PerspectiveIndexer ITabularPerspectiveObject.InPerspective { get { return this.InPerspective; } }
        /// <summary>
        /// Collection of localized descriptions for this Column.
        /// </summary>
        [Browsable(true),DisplayName("Translated Descriptions"),Description("Shows all translated descriptions of the current Column."),Category("Translations, Perspectives, Security")]
	    public TranslationIndexer TranslatedDescriptions { private set; get; }
        /// <summary>
        /// Collection of localized names for this Column.
        /// </summary>
        [Browsable(true),DisplayName("Translated Names"),Description("Shows all translated names of the current Column."),Category("Translations, Perspectives, Security")]
	    public TranslationIndexer TranslatedNames { private set; get; }

        /// <summary>
        /// Collection of localized synonyms for this Column.
        /// </summary>
        [Browsable(true),DisplayName("Synonyms"),Description("Shows all translated synonyms of the current Column."),Category("Translations, Perspectives, Security")]
	    public SynonymIndexer Synonyms { private set; get; }
	
        internal override void RenewMetadataObject()
        {
            Handler.WrapperLookup.Remove(MetadataObject);
            var json = TOM.JsonSerializer.SerializeObject(MetadataObject, RenewMetadataOptions);
            MetadataObject = TOM.JsonSerializer.DeserializeObject<TOM.Column>(json);
            Handler.WrapperLookup.Add(MetadataObject, this);
        }


        internal override ITabularObjectCollection GetCollectionForChild(TabularObject child)
        {
			if (child is AlternateOf) return null;
			if (child is Variation) return Variations;
            return base.GetCollectionForChild(child);
        }

        /// <summary>
        /// The collection of Variation objects on this Column.
        /// </summary>
		[DisplayName("Variations")]
		[Category("Options"),IntelliSense("The collection of Variation objects on the current Column.")][NoMultiselect(),Editor(typeof(VariationCollectionEditor),typeof(UITypeEditor))]
		public VariationCollection Variations { get; protected set; }

		/// <summary>
		/// CTOR - only called from static factory methods on the class
		/// </summary>
		protected Column(TOM.Column metadataObject) : base(metadataObject)
		{
			// Create indexers for translations:
			TranslatedNames = new TranslationIndexer(this, TOM.TranslatedProperty.Caption);
			TranslatedDescriptions = new TranslationIndexer(this, TOM.TranslatedProperty.Description);
			Synonyms = new SynonymIndexer(this);
			TranslatedDisplayFolders = new TranslationIndexer(this, TOM.TranslatedProperty.DisplayFolder);

			// Create indexer for perspectives:
			InPerspective = new PerspectiveColumnIndexer(this);
			
			// Create indexer for annotations:
			Annotations = new AnnotationCollection(this);
			
			// Create indexer for extended properties:
			ExtendedProperties = new ExtendedPropertyCollection(this);
			
			// Instantiate child collections:
			Variations = new VariationCollection(this.GetObjectPath() + ".Variations", MetadataObject.Variations, this);

			// Populate child collections:
			Variations.CreateChildrenFromMetadata();

			// Hook up event handlers on child collections:
			Variations.CollectionChanged += Children_CollectionChanged;
		}


		internal override void Reinit() {
			Variations.Reinit();
		}

		internal override void Undelete(ITabularObjectCollection collection, Type tomObjectType, string tomJson) {
			base.Undelete(collection, tomObjectType, tomJson);
			Reinit();
			ReapplyReferences();
		}
		internal override bool Browsable(string propertyName) {
			// Allow custom overrides to hide a property regardless of its compatibility level requirements:
			if(!base.Browsable(propertyName)) return false;

			switch (propertyName) {

				// Hide properties based on compatibility requirements (inferred from TOM):
				case Properties.ALTERNATEOF:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1460 : Handler.CompatibilityLevel >= 1460;
				case Properties.ENCODINGHINT:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1400 : Handler.CompatibilityLevel >= 1400;
				case Properties.EXTENDEDPROPERTIES:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1400 : Handler.CompatibilityLevel >= 1400;
				case Properties.LINEAGETAG:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1540 : Handler.CompatibilityLevel >= 1540;
				case Properties.RELATEDCOLUMNDETAILS:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1400 : false;
				case Properties.SOURCELINEAGETAG:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1550 : Handler.CompatibilityLevel >= 1550;
				case Properties.VARIATIONS:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1200 : Handler.CompatibilityLevel >= 1400;
				case nameof(Synonyms):
					return Synonyms.LinguisticCultures.Any();
				
				// Hides translation properties in the grid, unless the model actually contains translations:
				case Properties.TRANSLATEDNAMES:
				case Properties.TRANSLATEDDESCRIPTIONS:
				case Properties.TRANSLATEDDISPLAYFOLDERS:
					return Model.Cultures.Any();
				
				// Hides the perspective property in the grid, unless the model actually contains perspectives:
				case Properties.INPERSPECTIVE:
					return Model.Perspectives.Any();
				
				default:
					return true;
			}
		}

    }


	/// <summary>
	/// Collection class for Column. Provides convenient properties for setting a property on multiple objects at once.
	/// </summary>
	public sealed partial class ColumnCollection: TabularObjectCollection<Column>
	{
		internal Table Table { get { return Parent as Table; } }
		TOM.ColumnCollection TOM_Collection;
		internal ColumnCollection(string collectionName, TOM.ColumnCollection metadataObjectCollection, Table parent) : base(collectionName, parent)
		{
			TOM_Collection = metadataObjectCollection;
		}
		internal override Type GetItemType() { return typeof(Column); }
        internal override void TOM_Add(TOM.MetadataObject obj) { TOM_Collection.Add(obj as TOM.Column); }
        internal override bool TOM_Contains(TOM.MetadataObject obj) { return TOM_Collection.Contains(obj as TOM.Column); }
        internal override void TOM_Remove(TOM.MetadataObject obj) { TOM_Collection.Remove(obj as TOM.Column); }
        internal override void TOM_Clear() { TOM_Collection.Clear(); }
        internal override bool TOM_ContainsName(string name) { return TOM_Collection.ContainsName(name); }
        internal override TOM.MetadataObject TOM_Get(string name) { return TOM_Collection[name]; }
        internal override TOM.MetadataObject TOM_Find(string name) { return TOM_Collection.Find(name); }
		internal override void Reinit() {
			var ixOffset = 0;
			for(int i = 0; i < Count; i++) {
				var metadataObj = TOM_Get(i) as TOM.Column;
				var item = Handler.WrapperLookup.TryGetValue(metadataObj, out var existingItem) ? existingItem as Column : CreateFromMetadata(metadataObj);
				Handler.WrapperLookup.Remove(item.MetadataObject);
				if(Table.MetadataObject.Columns[i] is TOM.RowNumberColumn) ixOffset++;
				item.MetadataObject = Table.MetadataObject.Columns[i + ixOffset] as TOM.Column;
				Handler.WrapperLookup.Add(item.MetadataObject, item);
				item.Collection = this;
			}
			TOM_Collection = Table.MetadataObject.Columns;
			foreach(var item in this) item.Reinit();
		}

		internal override void ReapplyReferences() {
			foreach(var item in this) item.ReapplyReferences();
		}

		private Column CreateFromMetadata(TOM.Column obj)
		{
			if(obj is TOM.DataColumn datacolumnObj) return DataColumn.CreateFromMetadata(Table, datacolumnObj);
			if(obj is TOM.CalculatedTableColumn calculatedtablecolumnObj) return CalculatedTableColumn.CreateFromMetadata(Table, calculatedtablecolumnObj);
			if(obj is TOM.CalculatedColumn calculatedcolumnObj) return CalculatedColumn.CreateFromMetadata(Table, calculatedcolumnObj);
		    return null;
		}

		/// <summary>
		/// Calling this method will populate the ColumnCollection with objects based on the MetadataObjects in the corresponding MetadataObjectCollection.
		/// </summary>
		internal override void CreateChildrenFromMetadata()
		{
			// Construct child objects (they are automatically added to the Handler's WrapperLookup dictionary):
			foreach(var obj in TOM_Collection)
			{
				CreateFromMetadata(obj);
			}
		}

		/// <summary>
		/// Sets the DataType property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the DataType property of all objects in the collection at once.")]
		public DataType DataType {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("DataType"));
				this.ToList().ForEach(item => { item.DataType = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the DataCategory property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the DataCategory property of all objects in the collection at once.")]
		public string DataCategory {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("DataCategory"));
				this.ToList().ForEach(item => { item.DataCategory = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the Description property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the Description property of all objects in the collection at once.")]
		public string Description {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("Description"));
				this.ToList().ForEach(item => { item.Description = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the IsHidden property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the IsHidden property of all objects in the collection at once.")]
		public bool IsHidden {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("IsHidden"));
				this.ToList().ForEach(item => { item.IsHidden = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the IsUnique property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the IsUnique property of all objects in the collection at once.")]
		public bool IsUnique {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("IsUnique"));
				this.ToList().ForEach(item => { item.IsUnique = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the IsKey property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the IsKey property of all objects in the collection at once.")]
		public bool IsKey {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("IsKey"));
				this.ToList().ForEach(item => { item.IsKey = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the IsNullable property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the IsNullable property of all objects in the collection at once.")]
		public bool IsNullable {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("IsNullable"));
				this.ToList().ForEach(item => { item.IsNullable = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the Alignment property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the Alignment property of all objects in the collection at once.")]
		public Alignment Alignment {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("Alignment"));
				this.ToList().ForEach(item => { item.Alignment = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the TableDetailPosition property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the TableDetailPosition property of all objects in the collection at once.")]
		public int TableDetailPosition {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("TableDetailPosition"));
				this.ToList().ForEach(item => { item.TableDetailPosition = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the IsDefaultLabel property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the IsDefaultLabel property of all objects in the collection at once.")]
		public bool IsDefaultLabel {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("IsDefaultLabel"));
				this.ToList().ForEach(item => { item.IsDefaultLabel = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the IsDefaultImage property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the IsDefaultImage property of all objects in the collection at once.")]
		public bool IsDefaultImage {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("IsDefaultImage"));
				this.ToList().ForEach(item => { item.IsDefaultImage = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the SummarizeBy property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the SummarizeBy property of all objects in the collection at once.")]
		public AggregateFunction SummarizeBy {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("SummarizeBy"));
				this.ToList().ForEach(item => { item.SummarizeBy = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the FormatString property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the FormatString property of all objects in the collection at once.")]
		public string FormatString {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("FormatString"));
				this.ToList().ForEach(item => { item.FormatString = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the IsAvailableInMDX property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the IsAvailableInMDX property of all objects in the collection at once.")]
		public bool IsAvailableInMDX {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("IsAvailableInMDX"));
				this.ToList().ForEach(item => { item.IsAvailableInMDX = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the KeepUniqueRows property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the KeepUniqueRows property of all objects in the collection at once.")]
		public bool KeepUniqueRows {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("KeepUniqueRows"));
				this.ToList().ForEach(item => { item.KeepUniqueRows = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the DisplayOrdinal property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the DisplayOrdinal property of all objects in the collection at once.")]
		public int DisplayOrdinal {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("DisplayOrdinal"));
				this.ToList().ForEach(item => { item.DisplayOrdinal = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the SourceProviderType property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the SourceProviderType property of all objects in the collection at once.")]
		public string SourceProviderType {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("SourceProviderType"));
				this.ToList().ForEach(item => { item.SourceProviderType = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the DisplayFolder property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the DisplayFolder property of all objects in the collection at once.")]
		public string DisplayFolder {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("DisplayFolder"));
				this.ToList().ForEach(item => { item.DisplayFolder = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the EncodingHint property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the EncodingHint property of all objects in the collection at once.")]
		public EncodingHintType EncodingHint {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("EncodingHint"));
				this.ToList().ForEach(item => { item.EncodingHint = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the SourceLineageTag property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the SourceLineageTag property of all objects in the collection at once.")]
		public string SourceLineageTag {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("SourceLineageTag"));
				this.ToList().ForEach(item => { item.SourceLineageTag = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the SortByColumn property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the SortByColumn property of all objects in the collection at once.")]
		public Column SortByColumn {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("SortByColumn"));
				this.ToList().ForEach(item => { item.SortByColumn = value; });
				Handler.UndoManager.EndBatch();
			}
		}
	}
  
	/// <summary>
///             Represents a user culture. It is a child of a Model object, used for translating strings and formatting values.
///             </summary>
	[TypeConverter(typeof(DynamicPropertyConverter))]
	public sealed partial class Culture: TabularNamedObject
			, IInternalAnnotationObject
			, IInternalExtendedPropertyObject
			, IClonableObject
	{
	    internal new TOM.Culture MetadataObject 
		{ 
			get 
			{ 
				return base.MetadataObject as TOM.Culture; 
		    } 
			set 
			{ 
				base.MetadataObject = value; 
			}
		}

        private bool CanClearAnnotations() => GetAnnotationsCount() > 0;
        ///<summary>Removes all annotations from this object.</summary>
        [IntelliSense("Removes all annotations from this object.")]
        public void ClearAnnotations()
        {
            Handler.BeginUpdate("Clear annotations");
            foreach(var annotation in GetAnnotations().ToList()) {
                RemoveAnnotation(annotation);
            }
            Handler.EndUpdate();
        }

		///<summary>The collection of Annotations on the current Culture.</summary>
        [Browsable(true),NoMultiselect,Category("Metadata"),Description("The collection of Annotations on the current Culture."),Editor(typeof(AnnotationCollectionEditor), typeof(UITypeEditor))]
        [PropertyAction(nameof(ClearAnnotations))]
		public AnnotationCollection Annotations { get; private set; }
		///<summary>Gets the value of the annotation with the given index, assuming it exists.</summary>
		[IntelliSense("Gets the value of the annotation with the given index, assuming it exists.")]
		public string GetAnnotation(int index) {
			return MetadataObject.Annotations[index].Value;
		}
		///<summary>Returns true if an annotation with the given name exists. Otherwise false.</summary>
		[IntelliSense("Returns true if an annotation with the given name exists. Otherwise false.")]
		public bool HasAnnotation(string name) {
		    return MetadataObject.Annotations.ContainsName(name);
		}
		///<summary>Gets the value of the annotation with the given name. Returns null if no such annotation exists.</summary>
		[IntelliSense("Gets the value of the annotation with the given name. Returns null if no such annotation exists.")]
		public string GetAnnotation(string name) {
		    return HasAnnotation(name) ? MetadataObject.Annotations[name].Value : null;
		}
		///<summary>Sets the value of the annotation with the given index, assuming it exists.</summary>
		[IntelliSense("Sets the value of the annotation with the given index, assuming it exists.")]
		public void SetAnnotation(int index, string value) {
		    SetAnnotation(index, value, true);
		}
		internal void SetAnnotation(int index, string value, bool undoable) {
		    var name = MetadataObject.Annotations[index].Name;
			SetAnnotation(name, value, undoable);
		}
		void IInternalAnnotationObject.SetAnnotation(int index, string value, bool undoable) {
			SetAnnotation(index, value, undoable);
		}
		///<summary>Returns a unique name for a new annotation.</summary>
		public string GetNewAnnotationName() {
			return MetadataObject.Annotations.GetNewName("New Annotation");
		}
		///<summary>Sets the value of the annotation having the given name. If no such annotation exists, it will be created. If value is set to null, the annotation will be removed.</summary>
		[IntelliSense("Sets the value of the annotation having the given name. If no such annotation exists, it will be created. If value is set to null, the annotation will be removed.")]
		public void SetAnnotation(string name, string value) {
		    SetAnnotation(name, value, true);
		}
		internal void SetAnnotation(string name, string value, bool undoable) {
			if(name == null) name = GetNewAnnotationName();

			if(value == null) {
				// Remove annotation if set to null:
				RemoveAnnotation(name, undoable);
				return;
			}

			if(undoable) {
 				if(GetAnnotation(name) == value) return;
				bool undoable2 = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + value, ref undoable2, ref cancel);
				if (cancel) return;
			}

			if(MetadataObject.Annotations.Contains(name)) {
				// Change existing annotation:

				var oldValue = GetAnnotation(name);
				MetadataObject.Annotations[name].Value = value;
				if (undoable) {
					Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, oldValue));
					OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, name + ":" + value);
				}
			} else {
				// Add new annotation:

				MetadataObject.Annotations.Add(new TOM.Annotation{ Name = name, Value = value });
				if (undoable) {
					Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, null));
					OnPropertyChanged(Properties.ANNOTATIONS, null, name + ":" + value);
				}
			}
		}
		void IInternalAnnotationObject.SetAnnotation(string name, string value, bool undoable) {
			this.SetAnnotation(name, value, undoable);
		}
		///<summary>Remove an annotation by the given name.</summary>
		[IntelliSense("Remove an annotation by the given name.")]
		public void RemoveAnnotation(string name) {
		    RemoveAnnotation(name, true);
		}
		internal void RemoveAnnotation(string name, bool undoable) {
			if(MetadataObject.Annotations.Contains(name)) {
				if(undoable) 
				{
				    bool undoable2 = true;
				    bool cancel = false;
				    OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + GetAnnotation(name), ref undoable2, ref cancel);
				    if (cancel) return;
				}

			    var oldValue = MetadataObject.Annotations[name].Value;
				MetadataObject.Annotations.Remove(name);

				if (undoable) 
				{
					Handler.UndoManager.Add(new UndoAnnotationAction(this, name, null, oldValue));
					OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, null);
			    }
			}
		}
		void IInternalAnnotationObject.RemoveAnnotation(string name, bool undoable) {
			this.RemoveAnnotation(name, undoable);
		}
		///<summary>Gets the number of annotations on the current Culture.</summary>
		[IntelliSense("Gets the number of annotations on the current Culture.")]
		public int GetAnnotationsCount() {
			return MetadataObject.Annotations.Count;
		}
		///<summary>Gets a collection of all annotation names on the current Culture.</summary>
		[IntelliSense("Gets a collection of all annotation names on the current Culture.")]
		public IEnumerable<string> GetAnnotations() {
			return MetadataObject.Annotations.Select(a => a.Name);
		}

		        private bool CanClearExtendedProperties() => GetExtendedPropertyCount() > 0;
        ///<summary>Removes all Extended Properties from this object.</summary>
        [IntelliSense("Removes all Extended Properties from this object.")]
        public void ClearExtendedProperties()
        {
            Handler.BeginUpdate("Clear extended properties");
            foreach(var extendedProperty in GetExtendedProperties().ToList()) {
                RemoveExtendedProperty(extendedProperty);
            }
            Handler.EndUpdate();
        }

		///<summary>The collection of Extended Properties on the current Culture.</summary>
        [DisplayName("Extended Properties"),NoMultiselect,Category("Metadata"),Description("The collection of Extended Properties on the current Culture."),Editor(typeof(ExtendedPropertyCollectionEditor), typeof(UITypeEditor))]
        [PropertyAction(nameof(ClearExtendedProperties))]
		public ExtendedPropertyCollection ExtendedProperties { get; private set; }

		///<summary>Returns true if an ExtendedProperty with the given name exists. Otherwise false.</summary>
		[IntelliSense("Returns true if an ExtendedProperty with the given name exists. Otherwise false.")]
		public bool HasExtendedProperty(string name) {
		    return MetadataObject.ExtendedProperties.ContainsName(name);
		}
		///<summary>Gets the type of the ExtendedProperty with the given index, assuming it exists.</summary>
		public ExtendedPropertyType GetExtendedPropertyType(int index) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[index].Type;
		}
		///<summary>Gets the type of the ExtendedProperty with the given name, assuming it exists.</summary>
		public ExtendedPropertyType GetExtendedPropertyType(string name) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[name].Type;
		}
		///<summary>Gets the value of the ExtendedProperty with the given index, assuming it exists.</summary>
		public string GetExtendedProperty(int index) {
			var ep = MetadataObject.ExtendedProperties[index];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		///<summary>Gets the value of the ExtendedProperty with the given name. Returns null if no such ExtendedProperty exists.</summary>
		[IntelliSense("Gets the value of the ExtendedProperty with the given name. Returns null if no such ExtendedProperty exists.")]
		public string GetExtendedProperty(string name) {
		    if(!HasExtendedProperty(name)) return null;
			var ep = MetadataObject.ExtendedProperties[name];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		///<summary>Sets the value of the ExtendedProperty with the given index, optionally specifiying the type (string or JSON) of the ExtendedProperty.</summary>
		public void SetExtendedProperty(int index, string value, ExtendedPropertyType type) {
			SetExtendedProperty(index, value, type, true);
		}
		void IInternalExtendedPropertyObject.SetExtendedProperty(int index, string value, ExtendedPropertyType type, bool undoable) {
			SetExtendedProperty(index, value, type, undoable);
		}
		internal void SetExtendedProperty(int index, string value, ExtendedPropertyType type, bool undoable) {
			var name = MetadataObject.ExtendedProperties[index].Name;
			SetExtendedProperty(name, value, type, undoable);
		}
		///<summary>Returns a unique name for a new ExtendedProperty.</summary>
		public string GetNewExtendedPropertyName() {
			return MetadataObject.ExtendedProperties.GetNewName("New ExtendedProperty");
		}
		///<summary>Sets the value of the ExtendedProperty having the given name. If no such ExtendedProperty exists, it will be created. If value is set to null, the ExtendedProperty will be removed.</summary>
		[IntelliSense("Sets the value of the ExtendedProperty having the given name. If no such ExtendedProperty exists, it will be created. If value is set to null, the ExtendedProperty will be removed.")]
		public void SetExtendedProperty(string name, string value, ExtendedPropertyType type) {
			SetExtendedProperty(name, value, type, true);
		}
		internal void SetExtendedProperty(string name, string value, ExtendedPropertyType type, bool undoable) {
			if(name == null) name = GetNewExtendedPropertyName();

			if(value == null) {
				// Remove ExtendedProperty if set to null:
				RemoveExtendedProperty(name);
				return;
			}

			if(GetExtendedProperty(name) == value) return;
			if(undoable) {
				bool cancel = false;
				OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + value, ref undoable, ref cancel);
				if (cancel) return;
			}

			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Change existing ExtendedProperty:
				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				var ep = MetadataObject.ExtendedProperties[name];
				if (ep is TOM.JsonExtendedProperty)
					(ep as TOM.JsonExtendedProperty).Value = value;
				else 
					(ep as TOM.StringExtendedProperty).Value = value;
					
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, name + ":" + value);
			} else {
				// Add new ExtendedProperty:
				if (type == ExtendedPropertyType.Json)
					MetadataObject.ExtendedProperties.Add(new TOM.JsonExtendedProperty{ Name = name, Value = value });
				else
					MetadataObject.ExtendedProperties.Add(new TOM.StringExtendedProperty{ Name = name, Value = value });

				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, null, type));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, null, name + ":" + value);
			}
		}
		void IInternalExtendedPropertyObject.SetExtendedProperty(string name, string value, ExtendedPropertyType type, bool undoable) {
			this.SetExtendedProperty(name, value, type, undoable);
		}

		///<summary>Remove an ExtendedProperty by the given name.</summary>
		[IntelliSense("Remove an ExtendedProperty by the given name.")]
		public void RemoveExtendedProperty(string name) {
			RemoveExtendedProperty(name, true);
		}

		internal void RemoveExtendedProperty(string name, bool undoable) {
			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Get current value:
				if(undoable) {
					bool cancel = false;
					OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + GetExtendedProperty(name), ref undoable, ref cancel);
					if (cancel) return;
				}

				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				MetadataObject.ExtendedProperties.Remove(name);

				// Undo-handling:
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, null, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, null);
			}
		}
		void IInternalExtendedPropertyObject.RemoveExtendedProperty(string name, bool undoable) {
			this.RemoveExtendedProperty(name, undoable);
		}
		///<summary>Gets the number of ExtendedProperties on the current object.</summary>
		[IntelliSense("Gets the number of ExtendedProperties on the current object.")]
		public int GetExtendedPropertyCount() {
			return MetadataObject.ExtendedProperties.Count;
		}
		///<summary>Gets a collection of all ExtendedProperty names on the current object.</summary>
		[IntelliSense("Gets a collection of all ExtendedProperty names on the current object.")]
		public IEnumerable<string> GetExtendedProperties() {
			return MetadataObject.ExtendedProperties.Select(a => a.Name);
		}

		
		internal static Culture CreateFromMetadata(Model parent, TOM.Culture metadataObject) {
			var obj = new Culture(metadataObject);
			parent.Cultures.Add(obj);
			
			obj.Init();

			return obj;
		}


		/// <summary>
		/// Creates a new Culture and adds it to the parent Model.
		/// Also creates the underlying metadataobject and adds it to the TOM tree.
		/// </summary>
		public static Culture CreateNew(Model parent, string name = null)
		{
			if(!parent.Handler.PowerBIGovernance.AllowCreate(typeof(Culture))) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(Culture).GetTypeName()));
			}

			var metadataObject = new TOM.Culture();
			metadataObject.Name = parent.Cultures.GetNewName(string.IsNullOrWhiteSpace(name) ? "New " + typeof(Culture).GetTypeName() : name);
            InitMetadata(metadataObject, parent);
            var obj = new Culture(metadataObject);

			parent.Cultures.Add(obj);
			
			obj.Init();

			return obj;
		}

        static partial void InitMetadata(TOM.Culture metadataObject, Model parent);

		/// <summary>
		/// Creates a new Culture and adds it to the current Model.
		/// Also creates the underlying metadataobject and adds it to the TOM tree.
		/// </summary>		
		public static Culture CreateNew(string name = null)
		{
			return CreateNew(TabularModelHandler.Singleton.Model, name);
		}


		/// <summary>
		/// Creates an exact copy of this Culture object.
		/// </summary>
		[IntelliSense("Creates an exact copy of this Culture object.")]
		public Culture Clone(string newName = null) {
			if(!Handler.PowerBIGovernance.AllowCreate(this.GetType())) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(Culture).GetTypeName()));
			}

		    Handler.BeginUpdate("Clone Culture");

			// Create a clone of the underlying metadataobject:
			var tom = MetadataObject.Clone() as TOM.Culture;


			// Assign a new, unique name:
			tom.Name = Parent.Cultures.GetNewName(string.IsNullOrEmpty(newName) ? tom.Name + " copy" : newName);
				
			// Create the TOM Wrapper object, representing the metadataobject
			Culture obj = CreateFromMetadata(Parent, tom);

            Handler.EndUpdate();

            return obj;
		}

		TabularNamedObject IClonableObject.Clone(string newName, bool includeTranslations, TabularNamedObject newParent) 
		{
			if (newParent != null) throw new ArgumentException("This object can not be cloned to another parent. Argument newParent should be left as null.", "newParent");
			return Clone(newName);
		}

	
        internal override void RenewMetadataObject()
        {
            Handler.WrapperLookup.Remove(MetadataObject);
            var json = TOM.JsonSerializer.SerializeObject(MetadataObject, RenewMetadataOptions);
            MetadataObject = TOM.JsonSerializer.DeserializeObject<TOM.Culture>(json);
            Handler.WrapperLookup.Add(MetadataObject, this);
        }

		///<summary>The parent Model of the current Culture.</summary>
		public Model Parent { 
			get {
				return Handler.WrapperLookup[MetadataObject.Parent] as Model;
			}
		}



		/// <summary>
		/// CTOR - only called from static factory methods on the class
		/// </summary>
		Culture(TOM.Culture metadataObject) : base(metadataObject)
		{
			
			// Create indexer for annotations:
			Annotations = new AnnotationCollection(this);
			
			// Create indexer for extended properties:
			ExtendedProperties = new ExtendedPropertyCollection(this);
		}



		internal override void Undelete(ITabularObjectCollection collection, Type tomObjectType, string tomJson) {
			base.Undelete(collection, tomObjectType, tomJson);
			Reinit();
			ReapplyReferences();
		}
		internal override sealed bool Browsable(string propertyName) {
			// Allow custom overrides to hide a property regardless of its compatibility level requirements:
			if(!base.Browsable(propertyName)) return false;

			switch (propertyName) {

				// Hide properties based on compatibility requirements (inferred from TOM):
				case Properties.EXTENDEDPROPERTIES:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1400 : Handler.CompatibilityLevel >= 1400;
				case Properties.PARENT:
					return false;
				
				default:
					return true;
			}
		}

    }


	/// <summary>
	/// Collection class for Culture. Provides convenient properties for setting a property on multiple objects at once.
	/// </summary>
	public sealed partial class CultureCollection: TabularObjectCollection<Culture>
	{
		internal Model Model { get { return Parent as Model; } }
		TOM.CultureCollection TOM_Collection;
		internal CultureCollection(string collectionName, TOM.CultureCollection metadataObjectCollection, Model parent) : base(collectionName, parent)
		{
			TOM_Collection = metadataObjectCollection;
		}
		internal override Type GetItemType() { return typeof(Culture); }
        internal override void TOM_Add(TOM.MetadataObject obj) { TOM_Collection.Add(obj as TOM.Culture); }
        internal override bool TOM_Contains(TOM.MetadataObject obj) { return TOM_Collection.Contains(obj as TOM.Culture); }
        internal override void TOM_Remove(TOM.MetadataObject obj) { TOM_Collection.Remove(obj as TOM.Culture); }
        internal override void TOM_Clear() { TOM_Collection.Clear(); }
        internal override bool TOM_ContainsName(string name) { return TOM_Collection.ContainsName(name); }
		internal override TOM.MetadataObject TOM_Get(int index) { return TOM_Collection[index]; }
        internal override TOM.MetadataObject TOM_Get(string name) { return TOM_Collection[name]; }
        internal override TOM.MetadataObject TOM_Find(string name) { return TOM_Collection.Find(name); }
        internal override string GetNewName(string prefix = null) { return string.IsNullOrEmpty(prefix) ? TOM_Collection.GetNewName() : TOM_Collection.GetNewName(prefix); }
        internal override int IndexOf(TOM.MetadataObject obj) { return TOM_Collection.IndexOf(obj as TOM.Culture); }
        /// <summary>The number of items in this collection.</summary>
		public override int Count { get { return TOM_Collection.Count; } }
		/// <summary>Returns an enumerator that iterates through the collection.</summary>
        public override IEnumerator<Culture> GetEnumerator() { return TOM_Collection.Select(h => Handler.WrapperLookup[h]).OfType<Culture>().GetEnumerator(); }
		internal override void Reinit() {
			var ixOffset = 0;
			for(int i = 0; i < Count; i++) {
				var metadataObj = TOM_Get(i) as TOM.Culture;
				var item = Handler.WrapperLookup.TryGetValue(metadataObj, out var existingItem) ? existingItem as Culture : CreateFromMetadata(metadataObj);
				Handler.WrapperLookup.Remove(item.MetadataObject);
				item.MetadataObject = Model.MetadataObject.Cultures[i + ixOffset] as TOM.Culture;
				Handler.WrapperLookup.Add(item.MetadataObject, item);
				item.Collection = this;
			}
			TOM_Collection = Model.MetadataObject.Cultures;
			foreach(var item in this) item.Reinit();
		}

		internal override void ReapplyReferences() {
			foreach(var item in this) item.ReapplyReferences();
		}

		private Culture CreateFromMetadata(TOM.Culture obj)
		{
			if(obj is TOM.Culture cultureObj) return Culture.CreateFromMetadata(Model, cultureObj);
		    return null;
		}

		/// <summary>
		/// Calling this method will populate the CultureCollection with objects based on the MetadataObjects in the corresponding MetadataObjectCollection.
		/// </summary>
		internal override void CreateChildrenFromMetadata()
		{
			// Construct child objects (they are automatically added to the Handler's WrapperLookup dictionary):
			foreach(var obj in TOM_Collection)
			{
				CreateFromMetadata(obj);
			}
		}

	}
  
	/// <summary>
///             Represents a column in a Table that gets data from an external data source.
///             </summary>
	[TypeConverter(typeof(DynamicPropertyConverter))]
	public sealed partial class DataColumn: Column
			, IClonableObject
	{
	    internal new TOM.DataColumn MetadataObject 
		{ 
			get 
			{ 
				return base.MetadataObject as TOM.DataColumn; 
		    } 
			set 
			{ 
				base.MetadataObject = value; 
			}
		}

/// <summary>
///             Name of the column from which data will be retrieved. The name must match a column returned during processing or refresh, where the partition source is a query (as the Query of a CalculatedPartitionSource).
///             </summary>
		[DisplayName("Source Column")]
		[Category("Basic"),Description(@"Name of the column from which data will be retrieved. The name must match a column returned during processing or refresh, where the partition source is a query (as the Query of a CalculatedPartitionSource)."),IntelliSense(@"Name of the column from which data will be retrieved. The name must match a column returned during processing or refresh, where the partition source is a query (as the Query of a CalculatedPartitionSource).")]
		public string SourceColumn {
			get {
			    return MetadataObject.SourceColumn;
			}
			set {
				
				var oldValue = SourceColumn;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.SOURCECOLUMN, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.SourceColumn = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.SOURCECOLUMN, oldValue, newValue));
				OnPropertyChanged(Properties.SOURCECOLUMN, oldValue, newValue);
			}
		}
		private bool ShouldSerializeSourceColumn() { return false; }

		internal static DataColumn CreateFromMetadata(Table parent, TOM.DataColumn metadataObject) {
            // Generate a new LineageTag if an object with the provided lineage tag already exists:
            if(!string.IsNullOrEmpty(metadataObject.LineageTag)) {
                if (parent.Handler.CompatibilityLevel < 1540) metadataObject.LineageTag = null;
                else if (parent.MetadataObject.Columns.FindByLineageTag(metadataObject.LineageTag) != metadataObject) {
                    metadataObject.LineageTag = Guid.NewGuid().ToString();
                }
            }
			var obj = new DataColumn(metadataObject);
			parent.Columns.Add(obj);
			
			obj.Init();

			return obj;
		}


		/// <summary>
		/// Creates a new DataColumn and adds it to the parent Table.
		/// Also creates the underlying metadataobject and adds it to the TOM tree.
		/// </summary>
		public static DataColumn CreateNew(Table parent, string name = null)
		{
			if(!parent.Handler.PowerBIGovernance.AllowCreate(typeof(DataColumn))) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(DataColumn).GetTypeName()));
			}

			var metadataObject = new TOM.DataColumn();
            if(parent.Model.Database.CompatibilityLevel >= 1540) metadataObject.LineageTag = Guid.NewGuid().ToString();
			metadataObject.Name = parent.Columns.GetNewName(string.IsNullOrWhiteSpace(name) ? "New " + typeof(DataColumn).GetTypeName() : name);
            InitMetadata(metadataObject, parent);
            var obj = new DataColumn(metadataObject);

			parent.Columns.Add(obj);
			
			obj.Init();

			return obj;
		}

        static partial void InitMetadata(TOM.DataColumn metadataObject, Table parent);


		/// <summary>
		/// Creates an exact copy of this DataColumn object.
		/// </summary>
		[IntelliSense("Creates an exact copy of this DataColumn object.")]
		public DataColumn Clone(string newName = null, bool includeTranslations = true, Table newParent = null) {
			if(!Handler.PowerBIGovernance.AllowCreate(this.GetType())) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(DataColumn).GetTypeName()));
			}

		    Handler.BeginUpdate("Clone DataColumn");

			// Create a clone of the underlying metadataobject:
			var tom = MetadataObject.Clone() as TOM.DataColumn;

            if(Model.Database.CompatibilityLevel >= 1540 && !string.IsNullOrEmpty(LineageTag)) {
                tom.LineageTag = Guid.NewGuid().ToString();
            }

			// Assign a new, unique name:
			tom.Name = Parent.Columns.GetNewName(string.IsNullOrEmpty(newName) ? tom.Name + " copy" : newName);
				
			// Create the TOM Wrapper object, representing the metadataobject
			DataColumn obj = CreateFromMetadata(newParent ?? Parent, tom);

			// Copy translations, if applicable:
			if(includeTranslations) {
				obj.CopyTranslationsFrom(this);
			}
				
			// Copy perspectives:
			obj.InPerspective.CopyFrom(InPerspective);

            Handler.EndUpdate();

            return obj;
		}

		TabularNamedObject IClonableObject.Clone(string newName, bool includeTranslations, TabularNamedObject newParent) 
		{
			return Clone(newName);
		}

	
        internal override void RenewMetadataObject()
        {
            Handler.WrapperLookup.Remove(MetadataObject);
            var json = TOM.JsonSerializer.SerializeObject(MetadataObject, RenewMetadataOptions);
            MetadataObject = TOM.JsonSerializer.DeserializeObject<TOM.DataColumn>(json);
            Handler.WrapperLookup.Add(MetadataObject, this);
        }

		///<summary>The parent Table of the current Data Column.</summary>
		public Table Parent { 
			get {
				return Handler.WrapperLookup[MetadataObject.Parent] as Table;
			}
		}



		/// <summary>
		/// CTOR - only called from static factory methods on the class
		/// </summary>
		DataColumn(TOM.DataColumn metadataObject) : base(metadataObject)
		{
		}



		internal override void Undelete(ITabularObjectCollection collection, Type tomObjectType, string tomJson) {
			base.Undelete(collection, tomObjectType, tomJson);
			Reinit();
			ReapplyReferences();
		}
		internal override sealed bool Browsable(string propertyName) {
			// Allow custom overrides to hide a property regardless of its compatibility level requirements:
			if(!base.Browsable(propertyName)) return false;

			switch (propertyName) {

				// Hide properties based on compatibility requirements (inferred from TOM):
				case Properties.PARENT:
					return false;
				
				default:
					return true;
			}
		}

    }

  
	/// <summary>
///             Defines an open connection to an external data source for import, refresh, or DirectQuery operations on a Tabular <see cref="T:TabularEditor.TOMWrapper.Model" />.
///             </summary>
	[TypeConverter(typeof(DynamicPropertyConverter))]
	public abstract partial class DataSource: TabularNamedObject
			, IDescriptionObject
			, IInternalAnnotationObject
			, IInternalExtendedPropertyObject
	{
	    internal new TOM.DataSource MetadataObject 
		{ 
			get 
			{ 
				return base.MetadataObject as TOM.DataSource; 
		    } 
			set 
			{ 
				base.MetadataObject = value; 
			}
		}

        private bool CanClearAnnotations() => GetAnnotationsCount() > 0;
        ///<summary>Removes all annotations from this object.</summary>
        [IntelliSense("Removes all annotations from this object.")]
        public void ClearAnnotations()
        {
            Handler.BeginUpdate("Clear annotations");
            foreach(var annotation in GetAnnotations().ToList()) {
                RemoveAnnotation(annotation);
            }
            Handler.EndUpdate();
        }

		///<summary>The collection of Annotations on the current Data Source.</summary>
        [Browsable(true),NoMultiselect,Category("Metadata"),Description("The collection of Annotations on the current Data Source."),Editor(typeof(AnnotationCollectionEditor), typeof(UITypeEditor))]
        [PropertyAction(nameof(ClearAnnotations))]
		public AnnotationCollection Annotations { get; private set; }
		///<summary>Gets the value of the annotation with the given index, assuming it exists.</summary>
		[IntelliSense("Gets the value of the annotation with the given index, assuming it exists.")]
		public string GetAnnotation(int index) {
			return MetadataObject.Annotations[index].Value;
		}
		///<summary>Returns true if an annotation with the given name exists. Otherwise false.</summary>
		[IntelliSense("Returns true if an annotation with the given name exists. Otherwise false.")]
		public bool HasAnnotation(string name) {
		    return MetadataObject.Annotations.ContainsName(name);
		}
		///<summary>Gets the value of the annotation with the given name. Returns null if no such annotation exists.</summary>
		[IntelliSense("Gets the value of the annotation with the given name. Returns null if no such annotation exists.")]
		public string GetAnnotation(string name) {
		    return HasAnnotation(name) ? MetadataObject.Annotations[name].Value : null;
		}
		///<summary>Sets the value of the annotation with the given index, assuming it exists.</summary>
		[IntelliSense("Sets the value of the annotation with the given index, assuming it exists.")]
		public void SetAnnotation(int index, string value) {
		    SetAnnotation(index, value, true);
		}
		internal void SetAnnotation(int index, string value, bool undoable) {
		    var name = MetadataObject.Annotations[index].Name;
			SetAnnotation(name, value, undoable);
		}
		void IInternalAnnotationObject.SetAnnotation(int index, string value, bool undoable) {
			SetAnnotation(index, value, undoable);
		}
		///<summary>Returns a unique name for a new annotation.</summary>
		public string GetNewAnnotationName() {
			return MetadataObject.Annotations.GetNewName("New Annotation");
		}
		///<summary>Sets the value of the annotation having the given name. If no such annotation exists, it will be created. If value is set to null, the annotation will be removed.</summary>
		[IntelliSense("Sets the value of the annotation having the given name. If no such annotation exists, it will be created. If value is set to null, the annotation will be removed.")]
		public void SetAnnotation(string name, string value) {
		    SetAnnotation(name, value, true);
		}
		internal void SetAnnotation(string name, string value, bool undoable) {
			if(name == null) name = GetNewAnnotationName();

			if(value == null) {
				// Remove annotation if set to null:
				RemoveAnnotation(name, undoable);
				return;
			}

			if(undoable) {
 				if(GetAnnotation(name) == value) return;
				bool undoable2 = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + value, ref undoable2, ref cancel);
				if (cancel) return;
			}

			if(MetadataObject.Annotations.Contains(name)) {
				// Change existing annotation:

				var oldValue = GetAnnotation(name);
				MetadataObject.Annotations[name].Value = value;
				if (undoable) {
					Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, oldValue));
					OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, name + ":" + value);
				}
			} else {
				// Add new annotation:

				MetadataObject.Annotations.Add(new TOM.Annotation{ Name = name, Value = value });
				if (undoable) {
					Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, null));
					OnPropertyChanged(Properties.ANNOTATIONS, null, name + ":" + value);
				}
			}
		}
		void IInternalAnnotationObject.SetAnnotation(string name, string value, bool undoable) {
			this.SetAnnotation(name, value, undoable);
		}
		///<summary>Remove an annotation by the given name.</summary>
		[IntelliSense("Remove an annotation by the given name.")]
		public void RemoveAnnotation(string name) {
		    RemoveAnnotation(name, true);
		}
		internal void RemoveAnnotation(string name, bool undoable) {
			if(MetadataObject.Annotations.Contains(name)) {
				if(undoable) 
				{
				    bool undoable2 = true;
				    bool cancel = false;
				    OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + GetAnnotation(name), ref undoable2, ref cancel);
				    if (cancel) return;
				}

			    var oldValue = MetadataObject.Annotations[name].Value;
				MetadataObject.Annotations.Remove(name);

				if (undoable) 
				{
					Handler.UndoManager.Add(new UndoAnnotationAction(this, name, null, oldValue));
					OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, null);
			    }
			}
		}
		void IInternalAnnotationObject.RemoveAnnotation(string name, bool undoable) {
			this.RemoveAnnotation(name, undoable);
		}
		///<summary>Gets the number of annotations on the current Data Source.</summary>
		[IntelliSense("Gets the number of annotations on the current Data Source.")]
		public int GetAnnotationsCount() {
			return MetadataObject.Annotations.Count;
		}
		///<summary>Gets a collection of all annotation names on the current Data Source.</summary>
		[IntelliSense("Gets a collection of all annotation names on the current Data Source.")]
		public IEnumerable<string> GetAnnotations() {
			return MetadataObject.Annotations.Select(a => a.Name);
		}

		        private bool CanClearExtendedProperties() => GetExtendedPropertyCount() > 0;
        ///<summary>Removes all Extended Properties from this object.</summary>
        [IntelliSense("Removes all Extended Properties from this object.")]
        public void ClearExtendedProperties()
        {
            Handler.BeginUpdate("Clear extended properties");
            foreach(var extendedProperty in GetExtendedProperties().ToList()) {
                RemoveExtendedProperty(extendedProperty);
            }
            Handler.EndUpdate();
        }

		///<summary>The collection of Extended Properties on the current Data Source.</summary>
        [DisplayName("Extended Properties"),NoMultiselect,Category("Metadata"),Description("The collection of Extended Properties on the current Data Source."),Editor(typeof(ExtendedPropertyCollectionEditor), typeof(UITypeEditor))]
        [PropertyAction(nameof(ClearExtendedProperties))]
		public ExtendedPropertyCollection ExtendedProperties { get; private set; }

		///<summary>Returns true if an ExtendedProperty with the given name exists. Otherwise false.</summary>
		[IntelliSense("Returns true if an ExtendedProperty with the given name exists. Otherwise false.")]
		public bool HasExtendedProperty(string name) {
		    return MetadataObject.ExtendedProperties.ContainsName(name);
		}
		///<summary>Gets the type of the ExtendedProperty with the given index, assuming it exists.</summary>
		public ExtendedPropertyType GetExtendedPropertyType(int index) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[index].Type;
		}
		///<summary>Gets the type of the ExtendedProperty with the given name, assuming it exists.</summary>
		public ExtendedPropertyType GetExtendedPropertyType(string name) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[name].Type;
		}
		///<summary>Gets the value of the ExtendedProperty with the given index, assuming it exists.</summary>
		public string GetExtendedProperty(int index) {
			var ep = MetadataObject.ExtendedProperties[index];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		///<summary>Gets the value of the ExtendedProperty with the given name. Returns null if no such ExtendedProperty exists.</summary>
		[IntelliSense("Gets the value of the ExtendedProperty with the given name. Returns null if no such ExtendedProperty exists.")]
		public string GetExtendedProperty(string name) {
		    if(!HasExtendedProperty(name)) return null;
			var ep = MetadataObject.ExtendedProperties[name];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		///<summary>Sets the value of the ExtendedProperty with the given index, optionally specifiying the type (string or JSON) of the ExtendedProperty.</summary>
		public void SetExtendedProperty(int index, string value, ExtendedPropertyType type) {
			SetExtendedProperty(index, value, type, true);
		}
		void IInternalExtendedPropertyObject.SetExtendedProperty(int index, string value, ExtendedPropertyType type, bool undoable) {
			SetExtendedProperty(index, value, type, undoable);
		}
		internal void SetExtendedProperty(int index, string value, ExtendedPropertyType type, bool undoable) {
			var name = MetadataObject.ExtendedProperties[index].Name;
			SetExtendedProperty(name, value, type, undoable);
		}
		///<summary>Returns a unique name for a new ExtendedProperty.</summary>
		public string GetNewExtendedPropertyName() {
			return MetadataObject.ExtendedProperties.GetNewName("New ExtendedProperty");
		}
		///<summary>Sets the value of the ExtendedProperty having the given name. If no such ExtendedProperty exists, it will be created. If value is set to null, the ExtendedProperty will be removed.</summary>
		[IntelliSense("Sets the value of the ExtendedProperty having the given name. If no such ExtendedProperty exists, it will be created. If value is set to null, the ExtendedProperty will be removed.")]
		public void SetExtendedProperty(string name, string value, ExtendedPropertyType type) {
			SetExtendedProperty(name, value, type, true);
		}
		internal void SetExtendedProperty(string name, string value, ExtendedPropertyType type, bool undoable) {
			if(name == null) name = GetNewExtendedPropertyName();

			if(value == null) {
				// Remove ExtendedProperty if set to null:
				RemoveExtendedProperty(name);
				return;
			}

			if(GetExtendedProperty(name) == value) return;
			if(undoable) {
				bool cancel = false;
				OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + value, ref undoable, ref cancel);
				if (cancel) return;
			}

			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Change existing ExtendedProperty:
				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				var ep = MetadataObject.ExtendedProperties[name];
				if (ep is TOM.JsonExtendedProperty)
					(ep as TOM.JsonExtendedProperty).Value = value;
				else 
					(ep as TOM.StringExtendedProperty).Value = value;
					
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, name + ":" + value);
			} else {
				// Add new ExtendedProperty:
				if (type == ExtendedPropertyType.Json)
					MetadataObject.ExtendedProperties.Add(new TOM.JsonExtendedProperty{ Name = name, Value = value });
				else
					MetadataObject.ExtendedProperties.Add(new TOM.StringExtendedProperty{ Name = name, Value = value });

				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, null, type));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, null, name + ":" + value);
			}
		}
		void IInternalExtendedPropertyObject.SetExtendedProperty(string name, string value, ExtendedPropertyType type, bool undoable) {
			this.SetExtendedProperty(name, value, type, undoable);
		}

		///<summary>Remove an ExtendedProperty by the given name.</summary>
		[IntelliSense("Remove an ExtendedProperty by the given name.")]
		public void RemoveExtendedProperty(string name) {
			RemoveExtendedProperty(name, true);
		}

		internal void RemoveExtendedProperty(string name, bool undoable) {
			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Get current value:
				if(undoable) {
					bool cancel = false;
					OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + GetExtendedProperty(name), ref undoable, ref cancel);
					if (cancel) return;
				}

				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				MetadataObject.ExtendedProperties.Remove(name);

				// Undo-handling:
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, null, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, null);
			}
		}
		void IInternalExtendedPropertyObject.RemoveExtendedProperty(string name, bool undoable) {
			this.RemoveExtendedProperty(name, undoable);
		}
		///<summary>Gets the number of ExtendedProperties on the current object.</summary>
		[IntelliSense("Gets the number of ExtendedProperties on the current object.")]
		public int GetExtendedPropertyCount() {
			return MetadataObject.ExtendedProperties.Count;
		}
		///<summary>Gets a collection of all ExtendedProperty names on the current object.</summary>
		[IntelliSense("Gets a collection of all ExtendedProperty names on the current object.")]
		public IEnumerable<string> GetExtendedProperties() {
			return MetadataObject.ExtendedProperties.Select(a => a.Name);
		}

		/// <summary>
///             The description of the data source, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio.
///             </summary>
		[DisplayName("Description")]
		[Category("Basic"),Description(@"The description of the data source, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio."),IntelliSense(@"The description of the data source, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio.")][Editor(typeof(System.ComponentModel.Design.MultilineStringEditor), typeof(System.Drawing.Design.UITypeEditor))]
		public string Description {
			get {
			    return MetadataObject.Description;
			}
			set {
				
				var oldValue = Description;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DESCRIPTION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.Description = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DESCRIPTION, oldValue, newValue));
				OnPropertyChanged(Properties.DESCRIPTION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeDescription() { return false; }
/// <summary>
///             The type of DataSource. At present, the only possible value is Provider, which refers to a data source that accepts a connection string.
///             </summary>
		[DisplayName("Type")]
		[Category("Options"),Description(@"The type of DataSource. At present, the only possible value is Provider, which refers to a data source that accepts a connection string."),IntelliSense(@"The type of DataSource. At present, the only possible value is Provider, which refers to a data source that accepts a connection string.")]
		public DataSourceType Type {
			get {
			    return (DataSourceType)MetadataObject.Type;
			}
			
		}
		private bool ShouldSerializeType() { return false; }
/// <summary>
///             The maximum number of connections to be opened concurrently to the data source.
///             </summary>
		[DisplayName("Max Connections")]
		[Category("Options"),Description(@"The maximum number of connections to be opened concurrently to the data source."),IntelliSense(@"The maximum number of connections to be opened concurrently to the data source.")]
		public int MaxConnections {
			get {
			    return MetadataObject.MaxConnections;
			}
			set {
				
				var oldValue = MaxConnections;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.MAXCONNECTIONS, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.MaxConnections = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.MAXCONNECTIONS, oldValue, newValue));
				OnPropertyChanged(Properties.MAXCONNECTIONS, oldValue, newValue);
			}
		}
		private bool ShouldSerializeMaxConnections() { return false; }

	
        internal override void RenewMetadataObject()
        {
            Handler.WrapperLookup.Remove(MetadataObject);
            var json = TOM.JsonSerializer.SerializeObject(MetadataObject, RenewMetadataOptions);
            MetadataObject = TOM.JsonSerializer.DeserializeObject<TOM.DataSource>(json);
            Handler.WrapperLookup.Add(MetadataObject, this);
        }

		///<summary>The parent Model of the current Data Source.</summary>
		public Model Parent { 
			get {
				return Handler.WrapperLookup[MetadataObject.Parent] as Model;
			}
		}



		/// <summary>
		/// CTOR - only called from static factory methods on the class
		/// </summary>
		protected DataSource(TOM.DataSource metadataObject) : base(metadataObject)
		{
			
			// Create indexer for annotations:
			Annotations = new AnnotationCollection(this);
			
			// Create indexer for extended properties:
			ExtendedProperties = new ExtendedPropertyCollection(this);
		}



		internal override void Undelete(ITabularObjectCollection collection, Type tomObjectType, string tomJson) {
			base.Undelete(collection, tomObjectType, tomJson);
			Reinit();
			ReapplyReferences();
		}
		internal override bool Browsable(string propertyName) {
			// Allow custom overrides to hide a property regardless of its compatibility level requirements:
			if(!base.Browsable(propertyName)) return false;

			switch (propertyName) {

				// Hide properties based on compatibility requirements (inferred from TOM):
				case Properties.EXTENDEDPROPERTIES:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1400 : Handler.CompatibilityLevel >= 1400;
				case Properties.PARENT:
					return false;
				
				default:
					return true;
			}
		}

    }


	/// <summary>
	/// Collection class for DataSource. Provides convenient properties for setting a property on multiple objects at once.
	/// </summary>
	public sealed partial class DataSourceCollection: TabularObjectCollection<DataSource>
	{
		internal Model Model { get { return Parent as Model; } }
		TOM.DataSourceCollection TOM_Collection;
		internal DataSourceCollection(string collectionName, TOM.DataSourceCollection metadataObjectCollection, Model parent) : base(collectionName, parent)
		{
			TOM_Collection = metadataObjectCollection;
		}
		internal override Type GetItemType() { return typeof(DataSource); }
        internal override void TOM_Add(TOM.MetadataObject obj) { TOM_Collection.Add(obj as TOM.DataSource); }
        internal override bool TOM_Contains(TOM.MetadataObject obj) { return TOM_Collection.Contains(obj as TOM.DataSource); }
        internal override void TOM_Remove(TOM.MetadataObject obj) { TOM_Collection.Remove(obj as TOM.DataSource); }
        internal override void TOM_Clear() { TOM_Collection.Clear(); }
        internal override bool TOM_ContainsName(string name) { return TOM_Collection.ContainsName(name); }
		internal override TOM.MetadataObject TOM_Get(int index) { return TOM_Collection[index]; }
        internal override TOM.MetadataObject TOM_Get(string name) { return TOM_Collection[name]; }
        internal override TOM.MetadataObject TOM_Find(string name) { return TOM_Collection.Find(name); }
        internal override string GetNewName(string prefix = null) { return string.IsNullOrEmpty(prefix) ? TOM_Collection.GetNewName() : TOM_Collection.GetNewName(prefix); }
        internal override int IndexOf(TOM.MetadataObject obj) { return TOM_Collection.IndexOf(obj as TOM.DataSource); }
        /// <summary>The number of items in this collection.</summary>
		public override int Count { get { return TOM_Collection.Count; } }
		/// <summary>Returns an enumerator that iterates through the collection.</summary>
        public override IEnumerator<DataSource> GetEnumerator() { return TOM_Collection.Select(h => Handler.WrapperLookup[h]).OfType<DataSource>().GetEnumerator(); }
		internal override void Reinit() {
			var ixOffset = 0;
			for(int i = 0; i < Count; i++) {
				var metadataObj = TOM_Get(i) as TOM.DataSource;
				var item = Handler.WrapperLookup.TryGetValue(metadataObj, out var existingItem) ? existingItem as DataSource : CreateFromMetadata(metadataObj);
				Handler.WrapperLookup.Remove(item.MetadataObject);
				item.MetadataObject = Model.MetadataObject.DataSources[i + ixOffset] as TOM.DataSource;
				Handler.WrapperLookup.Add(item.MetadataObject, item);
				item.Collection = this;
			}
			TOM_Collection = Model.MetadataObject.DataSources;
			foreach(var item in this) item.Reinit();
		}

		internal override void ReapplyReferences() {
			foreach(var item in this) item.ReapplyReferences();
		}

		private DataSource CreateFromMetadata(TOM.DataSource obj)
		{
			if(obj is TOM.ProviderDataSource providerdatasourceObj) return ProviderDataSource.CreateFromMetadata(Model, providerdatasourceObj);
			if(obj is TOM.StructuredDataSource structureddatasourceObj) return StructuredDataSource.CreateFromMetadata(Model, structureddatasourceObj);
		    return null;
		}

		/// <summary>
		/// Calling this method will populate the DataSourceCollection with objects based on the MetadataObjects in the corresponding MetadataObjectCollection.
		/// </summary>
		internal override void CreateChildrenFromMetadata()
		{
			// Construct child objects (they are automatically added to the Handler's WrapperLookup dictionary):
			foreach(var obj in TOM_Collection)
			{
				CreateFromMetadata(obj);
			}
		}

		/// <summary>
		/// Sets the Description property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the Description property of all objects in the collection at once.")]
		public string Description {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("Description"));
				this.ToList().ForEach(item => { item.Description = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the MaxConnections property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the MaxConnections property of all objects in the collection at once.")]
		public int MaxConnections {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("MaxConnections"));
				this.ToList().ForEach(item => { item.MaxConnections = value; });
				Handler.UndoManager.EndBatch();
			}
		}
	}
  
	/// <summary>
///             For internal use only.
///             </summary>
	[TypeConverter(typeof(DynamicPropertyConverter))]
	public sealed partial class ExternalModelRoleMember: ModelRoleMember
			, IClonableObject
	{
	    internal new TOM.ExternalModelRoleMember MetadataObject 
		{ 
			get 
			{ 
				return base.MetadataObject as TOM.ExternalModelRoleMember; 
		    } 
			set 
			{ 
				base.MetadataObject = value; 
			}
		}

/// <summary>
///             A string that defines the identity provider used for authentication.
///             </summary>
		[DisplayName("Identity Provider")]
		[Category("Options"),Description(@"A string that defines the identity provider used for authentication."),IntelliSense(@"A string that defines the identity provider used for authentication.")]
		public string IdentityProvider {
			get {
			    return MetadataObject.IdentityProvider;
			}
			set {
				
				var oldValue = IdentityProvider;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.IDENTITYPROVIDER, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.IdentityProvider = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.IDENTITYPROVIDER, oldValue, newValue));
				OnPropertyChanged(Properties.IDENTITYPROVIDER, oldValue, newValue);
			}
		}
		private bool ShouldSerializeIdentityProvider() { return false; }
/// <summary>
///             Indicates whether the particular member of a security role is an individual user or a group of users, or automatically detected. Possible values are as follows. Auto (1): Member is automatically detected. User (2): Member is an individual user. Group (3): Member is a security group.
///             </summary>
		[DisplayName("Member Type")]
		[Category("Options"),Description(@"Indicates whether the particular member of a security role is an individual user or a group of users, or automatically detected. Possible values are as follows. Auto (1): Member is automatically detected. User (2): Member is an individual user. Group (3): Member is a security group."),IntelliSense(@"Indicates whether the particular member of a security role is an individual user or a group of users, or automatically detected. Possible values are as follows. Auto (1): Member is automatically detected. User (2): Member is an individual user. Group (3): Member is a security group.")]
		public RoleMemberType MemberType {
			get {
			    return (RoleMemberType)MetadataObject.MemberType;
			}
			set {
				
				var oldValue = MemberType;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.MEMBERTYPE, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.MemberType = (TOM.RoleMemberType)newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.MEMBERTYPE, oldValue, newValue));
				OnPropertyChanged(Properties.MEMBERTYPE, oldValue, newValue);
			}
		}
		private bool ShouldSerializeMemberType() { return false; }

		internal static ExternalModelRoleMember CreateFromMetadata(ModelRole parent, TOM.ExternalModelRoleMember metadataObject) {
			var obj = new ExternalModelRoleMember(metadataObject);
			parent.Members.Add(obj);
			
			obj.Init();

			return obj;
		}


		/// <summary>
		/// Creates a new ExternalModelRoleMember and adds it to the parent ModelRole.
		/// Also creates the underlying metadataobject and adds it to the TOM tree.
		/// </summary>
		public static ExternalModelRoleMember CreateNew(ModelRole parent, string name = null)
		{
			if(!parent.Handler.PowerBIGovernance.AllowCreate(typeof(ExternalModelRoleMember))) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(ExternalModelRoleMember).GetTypeName()));
			}

			var metadataObject = new TOM.ExternalModelRoleMember();
			metadataObject.MemberName = parent.Members.GetNewName(string.IsNullOrWhiteSpace(name) ? "New " + typeof(ExternalModelRoleMember).GetTypeName() : name);
            InitMetadata(metadataObject, parent);
            var obj = new ExternalModelRoleMember(metadataObject);

			parent.Members.Add(obj);
			
			obj.Init();

			return obj;
		}

        static partial void InitMetadata(TOM.ExternalModelRoleMember metadataObject, ModelRole parent);


		/// <summary>
		/// Creates an exact copy of this ExternalModelRoleMember object.
		/// </summary>
		[IntelliSense("Creates an exact copy of this ExternalModelRoleMember object.")]
		public ExternalModelRoleMember Clone(string newName = null, ModelRole newParent = null) {
			if(!Handler.PowerBIGovernance.AllowCreate(this.GetType())) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(ExternalModelRoleMember).GetTypeName()));
			}

		    Handler.BeginUpdate("Clone ExternalModelRoleMember");

			// Create a clone of the underlying metadataobject:
			var tom = MetadataObject.Clone() as TOM.ExternalModelRoleMember;


			// Assign a new, unique name:
			tom.Name = Parent.Members.GetNewName(string.IsNullOrEmpty(newName) ? tom.Name + " copy" : newName);
				
			// Create the TOM Wrapper object, representing the metadataobject
			ExternalModelRoleMember obj = CreateFromMetadata(newParent ?? Parent, tom);

            Handler.EndUpdate();

            return obj;
		}

		TabularNamedObject IClonableObject.Clone(string newName, bool includeTranslations, TabularNamedObject newParent) 
		{
			return Clone(newName);
		}

	
        internal override void RenewMetadataObject()
        {
            Handler.WrapperLookup.Remove(MetadataObject);
            var json = TOM.JsonSerializer.SerializeObject(MetadataObject, RenewMetadataOptions);
            MetadataObject = TOM.JsonSerializer.DeserializeObject<TOM.ExternalModelRoleMember>(json);
            Handler.WrapperLookup.Add(MetadataObject, this);
        }

		///<summary>The parent Model Role of the current External Model Role Member.</summary>
		public new ModelRole Parent { 
			get {
				return Handler.WrapperLookup[MetadataObject.Parent] as ModelRole;
			}
		}



		/// <summary>
		/// CTOR - only called from static factory methods on the class
		/// </summary>
		ExternalModelRoleMember(TOM.ExternalModelRoleMember metadataObject) : base(metadataObject)
		{
		}



		internal override void Undelete(ITabularObjectCollection collection, Type tomObjectType, string tomJson) {
			base.Undelete(collection, tomObjectType, tomJson);
			Reinit();
			ReapplyReferences();
		}
		internal override sealed bool Browsable(string propertyName) {
			// Allow custom overrides to hide a property regardless of its compatibility level requirements:
			if(!base.Browsable(propertyName)) return false;

			switch (propertyName) {

				// Hide properties based on compatibility requirements (inferred from TOM):
				case Properties.PARENT:
					return false;
				
				default:
					return true;
			}
		}

    }

  
	/// <summary>
///             Represents a collection of levels that provide a logical hierarchical drilldown path for client applications. It is a child of a Table object.
///             </summary>
	[TypeConverter(typeof(DynamicPropertyConverter))]
	public sealed partial class Hierarchy: TabularNamedObject
			, IFolderObject
			, IHideableObject
			, ITabularTableObject
			, IDescriptionObject
			, ILineageTagObject
			, IInternalAnnotationObject
			, IInternalExtendedPropertyObject
			, IInternalTabularPerspectiveObject
			, IInternalTranslatableObject
			, ISynonymObject
			, IClonableObject
	{
	    internal new TOM.Hierarchy MetadataObject 
		{ 
			get 
			{ 
				return base.MetadataObject as TOM.Hierarchy; 
		    } 
			set 
			{ 
				base.MetadataObject = value; 
			}
		}

        private bool CanClearAnnotations() => GetAnnotationsCount() > 0;
        ///<summary>Removes all annotations from this object.</summary>
        [IntelliSense("Removes all annotations from this object.")]
        public void ClearAnnotations()
        {
            Handler.BeginUpdate("Clear annotations");
            foreach(var annotation in GetAnnotations().ToList()) {
                RemoveAnnotation(annotation);
            }
            Handler.EndUpdate();
        }

		///<summary>The collection of Annotations on the current Hierarchy.</summary>
        [Browsable(true),NoMultiselect,Category("Metadata"),Description("The collection of Annotations on the current Hierarchy."),Editor(typeof(AnnotationCollectionEditor), typeof(UITypeEditor))]
        [PropertyAction(nameof(ClearAnnotations))]
		public AnnotationCollection Annotations { get; private set; }
		///<summary>Gets the value of the annotation with the given index, assuming it exists.</summary>
		[IntelliSense("Gets the value of the annotation with the given index, assuming it exists.")]
		public string GetAnnotation(int index) {
			return MetadataObject.Annotations[index].Value;
		}
		///<summary>Returns true if an annotation with the given name exists. Otherwise false.</summary>
		[IntelliSense("Returns true if an annotation with the given name exists. Otherwise false.")]
		public bool HasAnnotation(string name) {
		    return MetadataObject.Annotations.ContainsName(name);
		}
		///<summary>Gets the value of the annotation with the given name. Returns null if no such annotation exists.</summary>
		[IntelliSense("Gets the value of the annotation with the given name. Returns null if no such annotation exists.")]
		public string GetAnnotation(string name) {
		    return HasAnnotation(name) ? MetadataObject.Annotations[name].Value : null;
		}
		///<summary>Sets the value of the annotation with the given index, assuming it exists.</summary>
		[IntelliSense("Sets the value of the annotation with the given index, assuming it exists.")]
		public void SetAnnotation(int index, string value) {
		    SetAnnotation(index, value, true);
		}
		internal void SetAnnotation(int index, string value, bool undoable) {
		    var name = MetadataObject.Annotations[index].Name;
			SetAnnotation(name, value, undoable);
		}
		void IInternalAnnotationObject.SetAnnotation(int index, string value, bool undoable) {
			SetAnnotation(index, value, undoable);
		}
		///<summary>Returns a unique name for a new annotation.</summary>
		public string GetNewAnnotationName() {
			return MetadataObject.Annotations.GetNewName("New Annotation");
		}
		///<summary>Sets the value of the annotation having the given name. If no such annotation exists, it will be created. If value is set to null, the annotation will be removed.</summary>
		[IntelliSense("Sets the value of the annotation having the given name. If no such annotation exists, it will be created. If value is set to null, the annotation will be removed.")]
		public void SetAnnotation(string name, string value) {
		    SetAnnotation(name, value, true);
		}
		internal void SetAnnotation(string name, string value, bool undoable) {
			if(name == null) name = GetNewAnnotationName();

			if(value == null) {
				// Remove annotation if set to null:
				RemoveAnnotation(name, undoable);
				return;
			}

			if(undoable) {
 				if(GetAnnotation(name) == value) return;
				bool undoable2 = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + value, ref undoable2, ref cancel);
				if (cancel) return;
			}

			if(MetadataObject.Annotations.Contains(name)) {
				// Change existing annotation:

				var oldValue = GetAnnotation(name);
				MetadataObject.Annotations[name].Value = value;
				if (undoable) {
					Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, oldValue));
					OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, name + ":" + value);
				}
			} else {
				// Add new annotation:

				MetadataObject.Annotations.Add(new TOM.Annotation{ Name = name, Value = value });
				if (undoable) {
					Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, null));
					OnPropertyChanged(Properties.ANNOTATIONS, null, name + ":" + value);
				}
			}
		}
		void IInternalAnnotationObject.SetAnnotation(string name, string value, bool undoable) {
			this.SetAnnotation(name, value, undoable);
		}
		///<summary>Remove an annotation by the given name.</summary>
		[IntelliSense("Remove an annotation by the given name.")]
		public void RemoveAnnotation(string name) {
		    RemoveAnnotation(name, true);
		}
		internal void RemoveAnnotation(string name, bool undoable) {
			if(MetadataObject.Annotations.Contains(name)) {
				if(undoable) 
				{
				    bool undoable2 = true;
				    bool cancel = false;
				    OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + GetAnnotation(name), ref undoable2, ref cancel);
				    if (cancel) return;
				}

			    var oldValue = MetadataObject.Annotations[name].Value;
				MetadataObject.Annotations.Remove(name);

				if (undoable) 
				{
					Handler.UndoManager.Add(new UndoAnnotationAction(this, name, null, oldValue));
					OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, null);
			    }
			}
		}
		void IInternalAnnotationObject.RemoveAnnotation(string name, bool undoable) {
			this.RemoveAnnotation(name, undoable);
		}
		///<summary>Gets the number of annotations on the current Hierarchy.</summary>
		[IntelliSense("Gets the number of annotations on the current Hierarchy.")]
		public int GetAnnotationsCount() {
			return MetadataObject.Annotations.Count;
		}
		///<summary>Gets a collection of all annotation names on the current Hierarchy.</summary>
		[IntelliSense("Gets a collection of all annotation names on the current Hierarchy.")]
		public IEnumerable<string> GetAnnotations() {
			return MetadataObject.Annotations.Select(a => a.Name);
		}

		        private bool CanClearExtendedProperties() => GetExtendedPropertyCount() > 0;
        ///<summary>Removes all Extended Properties from this object.</summary>
        [IntelliSense("Removes all Extended Properties from this object.")]
        public void ClearExtendedProperties()
        {
            Handler.BeginUpdate("Clear extended properties");
            foreach(var extendedProperty in GetExtendedProperties().ToList()) {
                RemoveExtendedProperty(extendedProperty);
            }
            Handler.EndUpdate();
        }

		///<summary>The collection of Extended Properties on the current Hierarchy.</summary>
        [DisplayName("Extended Properties"),NoMultiselect,Category("Metadata"),Description("The collection of Extended Properties on the current Hierarchy."),Editor(typeof(ExtendedPropertyCollectionEditor), typeof(UITypeEditor))]
        [PropertyAction(nameof(ClearExtendedProperties))]
		public ExtendedPropertyCollection ExtendedProperties { get; private set; }

		///<summary>Returns true if an ExtendedProperty with the given name exists. Otherwise false.</summary>
		[IntelliSense("Returns true if an ExtendedProperty with the given name exists. Otherwise false.")]
		public bool HasExtendedProperty(string name) {
		    return MetadataObject.ExtendedProperties.ContainsName(name);
		}
		///<summary>Gets the type of the ExtendedProperty with the given index, assuming it exists.</summary>
		public ExtendedPropertyType GetExtendedPropertyType(int index) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[index].Type;
		}
		///<summary>Gets the type of the ExtendedProperty with the given name, assuming it exists.</summary>
		public ExtendedPropertyType GetExtendedPropertyType(string name) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[name].Type;
		}
		///<summary>Gets the value of the ExtendedProperty with the given index, assuming it exists.</summary>
		public string GetExtendedProperty(int index) {
			var ep = MetadataObject.ExtendedProperties[index];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		///<summary>Gets the value of the ExtendedProperty with the given name. Returns null if no such ExtendedProperty exists.</summary>
		[IntelliSense("Gets the value of the ExtendedProperty with the given name. Returns null if no such ExtendedProperty exists.")]
		public string GetExtendedProperty(string name) {
		    if(!HasExtendedProperty(name)) return null;
			var ep = MetadataObject.ExtendedProperties[name];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		///<summary>Sets the value of the ExtendedProperty with the given index, optionally specifiying the type (string or JSON) of the ExtendedProperty.</summary>
		public void SetExtendedProperty(int index, string value, ExtendedPropertyType type) {
			SetExtendedProperty(index, value, type, true);
		}
		void IInternalExtendedPropertyObject.SetExtendedProperty(int index, string value, ExtendedPropertyType type, bool undoable) {
			SetExtendedProperty(index, value, type, undoable);
		}
		internal void SetExtendedProperty(int index, string value, ExtendedPropertyType type, bool undoable) {
			var name = MetadataObject.ExtendedProperties[index].Name;
			SetExtendedProperty(name, value, type, undoable);
		}
		///<summary>Returns a unique name for a new ExtendedProperty.</summary>
		public string GetNewExtendedPropertyName() {
			return MetadataObject.ExtendedProperties.GetNewName("New ExtendedProperty");
		}
		///<summary>Sets the value of the ExtendedProperty having the given name. If no such ExtendedProperty exists, it will be created. If value is set to null, the ExtendedProperty will be removed.</summary>
		[IntelliSense("Sets the value of the ExtendedProperty having the given name. If no such ExtendedProperty exists, it will be created. If value is set to null, the ExtendedProperty will be removed.")]
		public void SetExtendedProperty(string name, string value, ExtendedPropertyType type) {
			SetExtendedProperty(name, value, type, true);
		}
		internal void SetExtendedProperty(string name, string value, ExtendedPropertyType type, bool undoable) {
			if(name == null) name = GetNewExtendedPropertyName();

			if(value == null) {
				// Remove ExtendedProperty if set to null:
				RemoveExtendedProperty(name);
				return;
			}

			if(GetExtendedProperty(name) == value) return;
			if(undoable) {
				bool cancel = false;
				OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + value, ref undoable, ref cancel);
				if (cancel) return;
			}

			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Change existing ExtendedProperty:
				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				var ep = MetadataObject.ExtendedProperties[name];
				if (ep is TOM.JsonExtendedProperty)
					(ep as TOM.JsonExtendedProperty).Value = value;
				else 
					(ep as TOM.StringExtendedProperty).Value = value;
					
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, name + ":" + value);
			} else {
				// Add new ExtendedProperty:
				if (type == ExtendedPropertyType.Json)
					MetadataObject.ExtendedProperties.Add(new TOM.JsonExtendedProperty{ Name = name, Value = value });
				else
					MetadataObject.ExtendedProperties.Add(new TOM.StringExtendedProperty{ Name = name, Value = value });

				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, null, type));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, null, name + ":" + value);
			}
		}
		void IInternalExtendedPropertyObject.SetExtendedProperty(string name, string value, ExtendedPropertyType type, bool undoable) {
			this.SetExtendedProperty(name, value, type, undoable);
		}

		///<summary>Remove an ExtendedProperty by the given name.</summary>
		[IntelliSense("Remove an ExtendedProperty by the given name.")]
		public void RemoveExtendedProperty(string name) {
			RemoveExtendedProperty(name, true);
		}

		internal void RemoveExtendedProperty(string name, bool undoable) {
			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Get current value:
				if(undoable) {
					bool cancel = false;
					OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + GetExtendedProperty(name), ref undoable, ref cancel);
					if (cancel) return;
				}

				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				MetadataObject.ExtendedProperties.Remove(name);

				// Undo-handling:
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, null, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, null);
			}
		}
		void IInternalExtendedPropertyObject.RemoveExtendedProperty(string name, bool undoable) {
			this.RemoveExtendedProperty(name, undoable);
		}
		///<summary>Gets the number of ExtendedProperties on the current object.</summary>
		[IntelliSense("Gets the number of ExtendedProperties on the current object.")]
		public int GetExtendedPropertyCount() {
			return MetadataObject.ExtendedProperties.Count;
		}
		///<summary>Gets a collection of all ExtendedProperty names on the current object.</summary>
		[IntelliSense("Gets a collection of all ExtendedProperty names on the current object.")]
		public IEnumerable<string> GetExtendedProperties() {
			return MetadataObject.ExtendedProperties.Select(a => a.Name);
		}

		/// <summary>
///             The description of the hierarchy, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio.
///             </summary>
		[DisplayName("Description")]
		[Category("Basic"),Description(@"The description of the hierarchy, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio."),IntelliSense(@"The description of the hierarchy, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio.")][Editor(typeof(System.ComponentModel.Design.MultilineStringEditor), typeof(System.Drawing.Design.UITypeEditor))]
		public string Description {
			get {
			    return MetadataObject.Description;
			}
			set {
				
				var oldValue = Description;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DESCRIPTION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.Description = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DESCRIPTION, oldValue, newValue));
				OnPropertyChanged(Properties.DESCRIPTION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeDescription() { return false; }
/// <summary>
///             A boolean value that indicates whether the hierarchy is treated as hidden by client visualization tools. True if the hierarchy is treated as hidden; otherwise false.
///             </summary>
		[DisplayName("Hidden")]
		[Category("Basic"),Description(@"A boolean value that indicates whether the hierarchy is treated as hidden by client visualization tools. True if the hierarchy is treated as hidden; otherwise false."),IntelliSense(@"A boolean value that indicates whether the hierarchy is treated as hidden by client visualization tools. True if the hierarchy is treated as hidden; otherwise false.")]
		public bool IsHidden {
			get {
			    return MetadataObject.IsHidden;
			}
			set {
				
				var oldValue = IsHidden;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ISHIDDEN, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.IsHidden = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.ISHIDDEN, oldValue, newValue));
				OnPropertyChanged(Properties.ISHIDDEN, oldValue, newValue);
				Handler.UpdateObject(this);
			}
		}
		private bool ShouldSerializeIsHidden() { return false; }
/// <summary>
///             Provides information on the state of the hierarchy. Possible values and their interpretation are as follows. Ready (1) The hierarchy is queryable and has up-to-date data. NoData (3) Not applicable to Hierarchy. CalculationNeeded (4) The hierarchy does not contain any data because it was not refreshed. There is no error associated with the hierarchy. SemanticError (5) Not applicable to Hierarchy. EvaluationError (6) Not applicable to Hierarchy. DependencyError (7) A dependency associated with the hierarchy is in an error state (SemanticError, EvaluationError, or DependencyError). Incomplete (8) Not applicable to Hierarchy.
///             </summary>
		[DisplayName("State")]
		[Category("Metadata"),Description(@"Provides information on the state of the hierarchy. Possible values and their interpretation are as follows. Ready (1) The hierarchy is queryable and has up-to-date data. NoData (3) Not applicable to Hierarchy. CalculationNeeded (4) The hierarchy does not contain any data because it was not refreshed. There is no error associated with the hierarchy. SemanticError (5) Not applicable to Hierarchy. EvaluationError (6) Not applicable to Hierarchy. DependencyError (7) A dependency associated with the hierarchy is in an error state (SemanticError, EvaluationError, or DependencyError). Incomplete (8) Not applicable to Hierarchy."),IntelliSense(@"Provides information on the state of the hierarchy. Possible values and their interpretation are as follows. Ready (1) The hierarchy is queryable and has up-to-date data. NoData (3) Not applicable to Hierarchy. CalculationNeeded (4) The hierarchy does not contain any data because it was not refreshed. There is no error associated with the hierarchy. SemanticError (5) Not applicable to Hierarchy. EvaluationError (6) Not applicable to Hierarchy. DependencyError (7) A dependency associated with the hierarchy is in an error state (SemanticError, EvaluationError, or DependencyError). Incomplete (8) Not applicable to Hierarchy.")]
		public ObjectState State {
			get {
			    return (ObjectState)MetadataObject.State;
			}
			
		}
		private bool ShouldSerializeState() { return false; }
/// <summary>
///             Defines the display folder for the hierarchy, for use by clients.
///             </summary>
		[DisplayName("Display Folder")]
		[Category("Basic"),Description(@"Defines the display folder for the hierarchy, for use by clients."),IntelliSense(@"Defines the display folder for the hierarchy, for use by clients.")][Editor(typeof(CustomDialogEditor), typeof(System.Drawing.Design.UITypeEditor))]
		public string DisplayFolder {
			get {
			    return MetadataObject.DisplayFolder;
			}
			set {
				if(value.Contains(@"\\")) throw new Exception("Display Folder names cannot be blank.");
				var oldValue = DisplayFolder;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DISPLAYFOLDER, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.DisplayFolder = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DISPLAYFOLDER, oldValue, newValue));
				OnPropertyChanged(Properties.DISPLAYFOLDER, oldValue, newValue);
				Handler.UpdateFolders(Table);
			}
		}
		private bool ShouldSerializeDisplayFolder() { return false; }
        /// <summary>
        /// Collection of localized Display Folders for the current Hierarchy.
        /// </summary>
        [Browsable(true),DisplayName("Translated Display Folders"),Description("Shows all translated Display Folders of the current Hierarchy."),Category("Translations, Perspectives, Security")]
	    public TranslationIndexer TranslatedDisplayFolders { private set; get; }
/// <summary>
///             Ragged/unbalanced hierarchies can be enabled by hiding members using this property.
///             </summary><remarks>This property is only supported when the compatibility level of the database is at 1400 or above.</remarks>
		[DisplayName("Hide Members")]
		[Category("Options"),Description(@"Ragged/unbalanced hierarchies can be enabled by hiding members using this property."),IntelliSense(@"Ragged/unbalanced hierarchies can be enabled by hiding members using this property.")]
		public HierarchyHideMembersType HideMembers {
			get {
			    return (HierarchyHideMembersType)MetadataObject.HideMembers;
			}
			set {
				
				var oldValue = HideMembers;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.HIDEMEMBERS, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.HideMembers = (TOM.HierarchyHideMembersType)newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.HIDEMEMBERS, oldValue, newValue));
				OnPropertyChanged(Properties.HIDEMEMBERS, oldValue, newValue);
			}
		}
		private bool ShouldSerializeHideMembers() { return false; }
/// <summary>
///             A tag that represents the lineage of the object.
///             </summary><remarks>This property is only supported when the compatibility level of the database is at 1540 or above.</remarks>
		[DisplayName("Lineage Tag")]
		[Category("Options"),Description(@"A tag that represents the lineage of the object."),IntelliSense(@"A tag that represents the lineage of the object.")]
		public string LineageTag {
			get {
			    return MetadataObject.LineageTag;
			}
			set {
				
				var oldValue = LineageTag;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.LINEAGETAG, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.LineageTag = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.LINEAGETAG, oldValue, newValue));
				OnPropertyChanged(Properties.LINEAGETAG, oldValue, newValue);
			}
		}
		private bool ShouldSerializeLineageTag() { return false; }
/// <summary>
///             A tag that represents the lineage of the source for the object.
///             </summary><remarks>This property is only supported when the compatibility level of the database is at 1550 or above.</remarks>
		[DisplayName("Source Lineage Tag")]
		[Category("Options"),Description(@"A tag that represents the lineage of the source for the object."),IntelliSense(@"A tag that represents the lineage of the source for the object.")]
		public string SourceLineageTag {
			get {
			    return MetadataObject.SourceLineageTag;
			}
			set {
				
				var oldValue = SourceLineageTag;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.SOURCELINEAGETAG, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.SourceLineageTag = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.SOURCELINEAGETAG, oldValue, newValue));
				OnPropertyChanged(Properties.SOURCELINEAGETAG, oldValue, newValue);
			}
		}
		private bool ShouldSerializeSourceLineageTag() { return false; }
		///<summary>The parent table of the current Hierarchy.</summary>
		[Browsable(false)]
		public Table Table
		{ 
			get 
			{ 
				TabularObject t = null;
				if(MetadataObject == null || MetadataObject.Table == null) return null;
				if(!Handler.WrapperLookup.TryGetValue(MetadataObject.Table, out t)) {
				    if(!MetadataObject.Table.IsRemoved)
						t = Model.Tables[MetadataObject.Table.Name];
				}
				return t as Table;
			} 
		}

        /// <Summary>
		/// Collection of perspectives in which this Hierarchy is visible.
		/// </Summary>
		[Browsable(true),DisplayName("Shown in Perspective"), Description("Provides an easy way to include or exclude the current Hierarchy from the perspectives of the model."), Category("Translations, Perspectives, Security")]
        public PerspectiveHierarchyIndexer InPerspective { get; private set; }
		PerspectiveIndexer ITabularPerspectiveObject.InPerspective { get { return this.InPerspective; } }
        /// <summary>
        /// Collection of localized descriptions for this Hierarchy.
        /// </summary>
        [Browsable(true),DisplayName("Translated Descriptions"),Description("Shows all translated descriptions of the current Hierarchy."),Category("Translations, Perspectives, Security")]
	    public TranslationIndexer TranslatedDescriptions { private set; get; }
        /// <summary>
        /// Collection of localized names for this Hierarchy.
        /// </summary>
        [Browsable(true),DisplayName("Translated Names"),Description("Shows all translated names of the current Hierarchy."),Category("Translations, Perspectives, Security")]
	    public TranslationIndexer TranslatedNames { private set; get; }

        /// <summary>
        /// Collection of localized synonyms for this Hierarchy.
        /// </summary>
        [Browsable(true),DisplayName("Synonyms"),Description("Shows all translated synonyms of the current Hierarchy."),Category("Translations, Perspectives, Security")]
	    public SynonymIndexer Synonyms { private set; get; }
		internal static Hierarchy CreateFromMetadata(Table parent, TOM.Hierarchy metadataObject) {
            // Generate a new LineageTag if an object with the provided lineage tag already exists:
            if(!string.IsNullOrEmpty(metadataObject.LineageTag)) {
                if (parent.Handler.CompatibilityLevel < 1540) metadataObject.LineageTag = null;
                else if (parent.MetadataObject.Hierarchies.FindByLineageTag(metadataObject.LineageTag) != metadataObject) {
                    metadataObject.LineageTag = Guid.NewGuid().ToString();
                }
            }
			var obj = new Hierarchy(metadataObject);
			parent.Hierarchies.Add(obj);
			
			obj.Init();

			return obj;
		}


		/// <summary>
		/// Creates a new Hierarchy and adds it to the parent Table.
		/// Also creates the underlying metadataobject and adds it to the TOM tree.
		/// </summary>
		public static Hierarchy CreateNew(Table parent, string name = null)
		{
			if(!parent.Handler.PowerBIGovernance.AllowCreate(typeof(Hierarchy))) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(Hierarchy).GetTypeName()));
			}

			var metadataObject = new TOM.Hierarchy();
            if(parent.Model.Database.CompatibilityLevel >= 1540) metadataObject.LineageTag = Guid.NewGuid().ToString();
			metadataObject.Name = parent.Hierarchies.GetNewName(string.IsNullOrWhiteSpace(name) ? "New " + typeof(Hierarchy).GetTypeName() : name);
            InitMetadata(metadataObject, parent);
            var obj = new Hierarchy(metadataObject);

			parent.Hierarchies.Add(obj);
			
			obj.Init();

			return obj;
		}

        static partial void InitMetadata(TOM.Hierarchy metadataObject, Table parent);


		/// <summary>
		/// Creates an exact copy of this Hierarchy object.
		/// </summary>
		[IntelliSense("Creates an exact copy of this Hierarchy object.")]
		public Hierarchy Clone(string newName = null, bool includeTranslations = true, Table newParent = null) {
			if(!Handler.PowerBIGovernance.AllowCreate(this.GetType())) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(Hierarchy).GetTypeName()));
			}

		    Handler.BeginUpdate("Clone Hierarchy");

			// Create a clone of the underlying metadataobject:
			var tom = MetadataObject.Clone() as TOM.Hierarchy;

            if(Model.Database.CompatibilityLevel >= 1540 && !string.IsNullOrEmpty(LineageTag)) {
                tom.LineageTag = Guid.NewGuid().ToString();
                foreach(var l in tom.Levels) l.LineageTag = Guid.NewGuid().ToString();
            }

			// Assign a new, unique name:
			tom.Name = Parent.Hierarchies.GetNewName(string.IsNullOrEmpty(newName) ? tom.Name + " copy" : newName);
				
			// Create the TOM Wrapper object, representing the metadataobject
			Hierarchy obj = CreateFromMetadata(newParent ?? Parent, tom);

			// Copy translations, if applicable:
			if(includeTranslations) {
				obj.CopyTranslationsFrom(this);
				foreach(var objChild in obj.Levels) objChild.CopyTranslationsFrom(obj.Levels[objChild.MetadataIndex]);
			}
				
			// Copy perspectives:
			obj.InPerspective.CopyFrom(InPerspective);

            Handler.EndUpdate();

            return obj;
		}

		TabularNamedObject IClonableObject.Clone(string newName, bool includeTranslations, TabularNamedObject newParent) 
		{
			return Clone(newName, includeTranslations);
		}

	
        internal override void RenewMetadataObject()
        {
            Handler.WrapperLookup.Remove(MetadataObject);
            var json = TOM.JsonSerializer.SerializeObject(MetadataObject, RenewMetadataOptions);
            MetadataObject = TOM.JsonSerializer.DeserializeObject<TOM.Hierarchy>(json);
            Handler.WrapperLookup.Add(MetadataObject, this);
        }

		///<summary>The parent Table of the current Hierarchy.</summary>
		public Table Parent { 
			get {
				return Handler.WrapperLookup[MetadataObject.Parent] as Table;
			}
		}

        internal override ITabularObjectCollection GetCollectionForChild(TabularObject child)
        {
			if (child is Level) return Levels;
            return base.GetCollectionForChild(child);
        }

        /// <summary>
        /// The collection of Level objects on this Hierarchy.
        /// </summary>
		[DisplayName("Levels")]
		[Category("Options"),IntelliSense("The collection of Level objects on the current Hierarchy.")][Browsable(false)]
		public LevelCollection Levels { get; private set; }

		/// <summary>
		/// CTOR - only called from static factory methods on the class
		/// </summary>
		Hierarchy(TOM.Hierarchy metadataObject) : base(metadataObject)
		{
			// Create indexers for translations:
			TranslatedNames = new TranslationIndexer(this, TOM.TranslatedProperty.Caption);
			TranslatedDescriptions = new TranslationIndexer(this, TOM.TranslatedProperty.Description);
			Synonyms = new SynonymIndexer(this);
			TranslatedDisplayFolders = new TranslationIndexer(this, TOM.TranslatedProperty.DisplayFolder);

			// Create indexer for perspectives:
			InPerspective = new PerspectiveHierarchyIndexer(this);
			
			// Create indexer for annotations:
			Annotations = new AnnotationCollection(this);
			
			// Create indexer for extended properties:
			ExtendedProperties = new ExtendedPropertyCollection(this);
			
			// Instantiate child collections:
			Levels = new LevelCollection(this.GetObjectPath() + ".Levels", MetadataObject.Levels, this);

			// Populate child collections:
			Levels.CreateChildrenFromMetadata();

			// Hook up event handlers on child collections:
			Levels.CollectionChanged += Children_CollectionChanged;
		}


		internal override void Reinit() {
			Levels.Reinit();
		}

		internal override void Undelete(ITabularObjectCollection collection, Type tomObjectType, string tomJson) {
			base.Undelete(collection, tomObjectType, tomJson);
			Reinit();
			ReapplyReferences();
		}
		internal override sealed bool Browsable(string propertyName) {
			// Allow custom overrides to hide a property regardless of its compatibility level requirements:
			if(!base.Browsable(propertyName)) return false;

			switch (propertyName) {

				// Hide properties based on compatibility requirements (inferred from TOM):
				case Properties.EXTENDEDPROPERTIES:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1400 : Handler.CompatibilityLevel >= 1400;
				case Properties.HIDEMEMBERS:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1400 : Handler.CompatibilityLevel >= 1400;
				case Properties.LINEAGETAG:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1540 : Handler.CompatibilityLevel >= 1540;
				case Properties.SOURCELINEAGETAG:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1550 : Handler.CompatibilityLevel >= 1550;
				case Properties.PARENT:
					return false;
				case nameof(Synonyms):
					return Synonyms.LinguisticCultures.Any();
				
				// Hides translation properties in the grid, unless the model actually contains translations:
				case Properties.TRANSLATEDNAMES:
				case Properties.TRANSLATEDDESCRIPTIONS:
				case Properties.TRANSLATEDDISPLAYFOLDERS:
					return Model.Cultures.Any();
				
				// Hides the perspective property in the grid, unless the model actually contains perspectives:
				case Properties.INPERSPECTIVE:
					return Model.Perspectives.Any();
				
				default:
					return true;
			}
		}

    }


	/// <summary>
	/// Collection class for Hierarchy. Provides convenient properties for setting a property on multiple objects at once.
	/// </summary>
	public sealed partial class HierarchyCollection: TabularObjectCollection<Hierarchy>
	{
		internal Table Table { get { return Parent as Table; } }
		TOM.HierarchyCollection TOM_Collection;
		internal HierarchyCollection(string collectionName, TOM.HierarchyCollection metadataObjectCollection, Table parent) : base(collectionName, parent)
		{
			TOM_Collection = metadataObjectCollection;
		}
		internal override Type GetItemType() { return typeof(Hierarchy); }
        internal override void TOM_Add(TOM.MetadataObject obj) { TOM_Collection.Add(obj as TOM.Hierarchy); }
        internal override bool TOM_Contains(TOM.MetadataObject obj) { return TOM_Collection.Contains(obj as TOM.Hierarchy); }
        internal override void TOM_Remove(TOM.MetadataObject obj) { TOM_Collection.Remove(obj as TOM.Hierarchy); }
        internal override void TOM_Clear() { TOM_Collection.Clear(); }
        internal override bool TOM_ContainsName(string name) { return TOM_Collection.ContainsName(name); }
		internal override TOM.MetadataObject TOM_Get(int index) { return TOM_Collection[index]; }
        internal override TOM.MetadataObject TOM_Get(string name) { return TOM_Collection[name]; }
        internal override TOM.MetadataObject TOM_Find(string name) { return TOM_Collection.Find(name); }
        internal override string GetNewName(string prefix = null) { return string.IsNullOrEmpty(prefix) ? TOM_Collection.GetNewName() : TOM_Collection.GetNewName(prefix); }
        internal override int IndexOf(TOM.MetadataObject obj) { return TOM_Collection.IndexOf(obj as TOM.Hierarchy); }
        /// <summary>The number of items in this collection.</summary>
		public override int Count { get { return TOM_Collection.Count; } }
		/// <summary>Returns an enumerator that iterates through the collection.</summary>
        public override IEnumerator<Hierarchy> GetEnumerator() { return TOM_Collection.Select(h => Handler.WrapperLookup[h]).OfType<Hierarchy>().GetEnumerator(); }
		internal override void Reinit() {
			var ixOffset = 0;
			for(int i = 0; i < Count; i++) {
				var metadataObj = TOM_Get(i) as TOM.Hierarchy;
				var item = Handler.WrapperLookup.TryGetValue(metadataObj, out var existingItem) ? existingItem as Hierarchy : CreateFromMetadata(metadataObj);
				Handler.WrapperLookup.Remove(item.MetadataObject);
				item.MetadataObject = Table.MetadataObject.Hierarchies[i + ixOffset] as TOM.Hierarchy;
				Handler.WrapperLookup.Add(item.MetadataObject, item);
				item.Collection = this;
			}
			TOM_Collection = Table.MetadataObject.Hierarchies;
			foreach(var item in this) item.Reinit();
		}

		internal override void ReapplyReferences() {
			foreach(var item in this) item.ReapplyReferences();
		}

		private Hierarchy CreateFromMetadata(TOM.Hierarchy obj)
		{
			if(obj is TOM.Hierarchy hierarchyObj) return Hierarchy.CreateFromMetadata(Table, hierarchyObj);
		    return null;
		}

		/// <summary>
		/// Calling this method will populate the HierarchyCollection with objects based on the MetadataObjects in the corresponding MetadataObjectCollection.
		/// </summary>
		internal override void CreateChildrenFromMetadata()
		{
			// Construct child objects (they are automatically added to the Handler's WrapperLookup dictionary):
			foreach(var obj in TOM_Collection)
			{
				CreateFromMetadata(obj);
			}
		}

		/// <summary>
		/// Sets the Description property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the Description property of all objects in the collection at once.")]
		public string Description {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("Description"));
				this.ToList().ForEach(item => { item.Description = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the IsHidden property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the IsHidden property of all objects in the collection at once.")]
		public bool IsHidden {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("IsHidden"));
				this.ToList().ForEach(item => { item.IsHidden = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the DisplayFolder property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the DisplayFolder property of all objects in the collection at once.")]
		public string DisplayFolder {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("DisplayFolder"));
				this.ToList().ForEach(item => { item.DisplayFolder = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the HideMembers property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the HideMembers property of all objects in the collection at once.")]
		public HierarchyHideMembersType HideMembers {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("HideMembers"));
				this.ToList().ForEach(item => { item.HideMembers = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the SourceLineageTag property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the SourceLineageTag property of all objects in the collection at once.")]
		public string SourceLineageTag {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("SourceLineageTag"));
				this.ToList().ForEach(item => { item.SourceLineageTag = value; });
				Handler.UndoManager.EndBatch();
			}
		}
	}
  
	/// <summary>
///             Represents a Key Performance Indicator object. It is a child of a Measure object.
///             </summary>
	[TypeConverter(typeof(DynamicPropertyConverter))]
	public sealed partial class KPI: TabularObject
			, IDescriptionObject
			, IInternalAnnotationObject
			, IInternalExtendedPropertyObject
	{
	    internal new TOM.KPI MetadataObject 
		{ 
			get 
			{ 
				return base.MetadataObject as TOM.KPI; 
		    } 
			set 
			{ 
				base.MetadataObject = value; 
			}
		}

        private bool CanClearAnnotations() => GetAnnotationsCount() > 0;
        ///<summary>Removes all annotations from this object.</summary>
        [IntelliSense("Removes all annotations from this object.")]
        public void ClearAnnotations()
        {
            Handler.BeginUpdate("Clear annotations");
            foreach(var annotation in GetAnnotations().ToList()) {
                RemoveAnnotation(annotation);
            }
            Handler.EndUpdate();
        }

		///<summary>The collection of Annotations on the current KPI.</summary>
        [Browsable(true),NoMultiselect,Category("Metadata"),Description("The collection of Annotations on the current KPI."),Editor(typeof(AnnotationCollectionEditor), typeof(UITypeEditor))]
        [PropertyAction(nameof(ClearAnnotations))]
		public AnnotationCollection Annotations { get; private set; }
		///<summary>Gets the value of the annotation with the given index, assuming it exists.</summary>
		[IntelliSense("Gets the value of the annotation with the given index, assuming it exists.")]
		public string GetAnnotation(int index) {
			return MetadataObject.Annotations[index].Value;
		}
		///<summary>Returns true if an annotation with the given name exists. Otherwise false.</summary>
		[IntelliSense("Returns true if an annotation with the given name exists. Otherwise false.")]
		public bool HasAnnotation(string name) {
		    return MetadataObject.Annotations.ContainsName(name);
		}
		///<summary>Gets the value of the annotation with the given name. Returns null if no such annotation exists.</summary>
		[IntelliSense("Gets the value of the annotation with the given name. Returns null if no such annotation exists.")]
		public string GetAnnotation(string name) {
		    return HasAnnotation(name) ? MetadataObject.Annotations[name].Value : null;
		}
		///<summary>Sets the value of the annotation with the given index, assuming it exists.</summary>
		[IntelliSense("Sets the value of the annotation with the given index, assuming it exists.")]
		public void SetAnnotation(int index, string value) {
		    SetAnnotation(index, value, true);
		}
		internal void SetAnnotation(int index, string value, bool undoable) {
		    var name = MetadataObject.Annotations[index].Name;
			SetAnnotation(name, value, undoable);
		}
		void IInternalAnnotationObject.SetAnnotation(int index, string value, bool undoable) {
			SetAnnotation(index, value, undoable);
		}
		///<summary>Returns a unique name for a new annotation.</summary>
		public string GetNewAnnotationName() {
			return MetadataObject.Annotations.GetNewName("New Annotation");
		}
		///<summary>Sets the value of the annotation having the given name. If no such annotation exists, it will be created. If value is set to null, the annotation will be removed.</summary>
		[IntelliSense("Sets the value of the annotation having the given name. If no such annotation exists, it will be created. If value is set to null, the annotation will be removed.")]
		public void SetAnnotation(string name, string value) {
		    SetAnnotation(name, value, true);
		}
		internal void SetAnnotation(string name, string value, bool undoable) {
			if(name == null) name = GetNewAnnotationName();

			if(value == null) {
				// Remove annotation if set to null:
				RemoveAnnotation(name, undoable);
				return;
			}

			if(undoable) {
 				if(GetAnnotation(name) == value) return;
				bool undoable2 = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + value, ref undoable2, ref cancel);
				if (cancel) return;
			}

			if(MetadataObject.Annotations.Contains(name)) {
				// Change existing annotation:

				var oldValue = GetAnnotation(name);
				MetadataObject.Annotations[name].Value = value;
				if (undoable) {
					Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, oldValue));
					OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, name + ":" + value);
				}
			} else {
				// Add new annotation:

				MetadataObject.Annotations.Add(new TOM.Annotation{ Name = name, Value = value });
				if (undoable) {
					Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, null));
					OnPropertyChanged(Properties.ANNOTATIONS, null, name + ":" + value);
				}
			}
		}
		void IInternalAnnotationObject.SetAnnotation(string name, string value, bool undoable) {
			this.SetAnnotation(name, value, undoable);
		}
		///<summary>Remove an annotation by the given name.</summary>
		[IntelliSense("Remove an annotation by the given name.")]
		public void RemoveAnnotation(string name) {
		    RemoveAnnotation(name, true);
		}
		internal void RemoveAnnotation(string name, bool undoable) {
			if(MetadataObject.Annotations.Contains(name)) {
				if(undoable) 
				{
				    bool undoable2 = true;
				    bool cancel = false;
				    OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + GetAnnotation(name), ref undoable2, ref cancel);
				    if (cancel) return;
				}

			    var oldValue = MetadataObject.Annotations[name].Value;
				MetadataObject.Annotations.Remove(name);

				if (undoable) 
				{
					Handler.UndoManager.Add(new UndoAnnotationAction(this, name, null, oldValue));
					OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, null);
			    }
			}
		}
		void IInternalAnnotationObject.RemoveAnnotation(string name, bool undoable) {
			this.RemoveAnnotation(name, undoable);
		}
		///<summary>Gets the number of annotations on the current KPI.</summary>
		[IntelliSense("Gets the number of annotations on the current KPI.")]
		public int GetAnnotationsCount() {
			return MetadataObject.Annotations.Count;
		}
		///<summary>Gets a collection of all annotation names on the current KPI.</summary>
		[IntelliSense("Gets a collection of all annotation names on the current KPI.")]
		public IEnumerable<string> GetAnnotations() {
			return MetadataObject.Annotations.Select(a => a.Name);
		}

		        private bool CanClearExtendedProperties() => GetExtendedPropertyCount() > 0;
        ///<summary>Removes all Extended Properties from this object.</summary>
        [IntelliSense("Removes all Extended Properties from this object.")]
        public void ClearExtendedProperties()
        {
            Handler.BeginUpdate("Clear extended properties");
            foreach(var extendedProperty in GetExtendedProperties().ToList()) {
                RemoveExtendedProperty(extendedProperty);
            }
            Handler.EndUpdate();
        }

		///<summary>The collection of Extended Properties on the current KPI.</summary>
        [DisplayName("Extended Properties"),NoMultiselect,Category("Metadata"),Description("The collection of Extended Properties on the current KPI."),Editor(typeof(ExtendedPropertyCollectionEditor), typeof(UITypeEditor))]
        [PropertyAction(nameof(ClearExtendedProperties))]
		public ExtendedPropertyCollection ExtendedProperties { get; private set; }

		///<summary>Returns true if an ExtendedProperty with the given name exists. Otherwise false.</summary>
		[IntelliSense("Returns true if an ExtendedProperty with the given name exists. Otherwise false.")]
		public bool HasExtendedProperty(string name) {
		    return MetadataObject.ExtendedProperties.ContainsName(name);
		}
		///<summary>Gets the type of the ExtendedProperty with the given index, assuming it exists.</summary>
		public ExtendedPropertyType GetExtendedPropertyType(int index) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[index].Type;
		}
		///<summary>Gets the type of the ExtendedProperty with the given name, assuming it exists.</summary>
		public ExtendedPropertyType GetExtendedPropertyType(string name) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[name].Type;
		}
		///<summary>Gets the value of the ExtendedProperty with the given index, assuming it exists.</summary>
		public string GetExtendedProperty(int index) {
			var ep = MetadataObject.ExtendedProperties[index];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		///<summary>Gets the value of the ExtendedProperty with the given name. Returns null if no such ExtendedProperty exists.</summary>
		[IntelliSense("Gets the value of the ExtendedProperty with the given name. Returns null if no such ExtendedProperty exists.")]
		public string GetExtendedProperty(string name) {
		    if(!HasExtendedProperty(name)) return null;
			var ep = MetadataObject.ExtendedProperties[name];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		///<summary>Sets the value of the ExtendedProperty with the given index, optionally specifiying the type (string or JSON) of the ExtendedProperty.</summary>
		public void SetExtendedProperty(int index, string value, ExtendedPropertyType type) {
			SetExtendedProperty(index, value, type, true);
		}
		void IInternalExtendedPropertyObject.SetExtendedProperty(int index, string value, ExtendedPropertyType type, bool undoable) {
			SetExtendedProperty(index, value, type, undoable);
		}
		internal void SetExtendedProperty(int index, string value, ExtendedPropertyType type, bool undoable) {
			var name = MetadataObject.ExtendedProperties[index].Name;
			SetExtendedProperty(name, value, type, undoable);
		}
		///<summary>Returns a unique name for a new ExtendedProperty.</summary>
		public string GetNewExtendedPropertyName() {
			return MetadataObject.ExtendedProperties.GetNewName("New ExtendedProperty");
		}
		///<summary>Sets the value of the ExtendedProperty having the given name. If no such ExtendedProperty exists, it will be created. If value is set to null, the ExtendedProperty will be removed.</summary>
		[IntelliSense("Sets the value of the ExtendedProperty having the given name. If no such ExtendedProperty exists, it will be created. If value is set to null, the ExtendedProperty will be removed.")]
		public void SetExtendedProperty(string name, string value, ExtendedPropertyType type) {
			SetExtendedProperty(name, value, type, true);
		}
		internal void SetExtendedProperty(string name, string value, ExtendedPropertyType type, bool undoable) {
			if(name == null) name = GetNewExtendedPropertyName();

			if(value == null) {
				// Remove ExtendedProperty if set to null:
				RemoveExtendedProperty(name);
				return;
			}

			if(GetExtendedProperty(name) == value) return;
			if(undoable) {
				bool cancel = false;
				OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + value, ref undoable, ref cancel);
				if (cancel) return;
			}

			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Change existing ExtendedProperty:
				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				var ep = MetadataObject.ExtendedProperties[name];
				if (ep is TOM.JsonExtendedProperty)
					(ep as TOM.JsonExtendedProperty).Value = value;
				else 
					(ep as TOM.StringExtendedProperty).Value = value;
					
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, name + ":" + value);
			} else {
				// Add new ExtendedProperty:
				if (type == ExtendedPropertyType.Json)
					MetadataObject.ExtendedProperties.Add(new TOM.JsonExtendedProperty{ Name = name, Value = value });
				else
					MetadataObject.ExtendedProperties.Add(new TOM.StringExtendedProperty{ Name = name, Value = value });

				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, null, type));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, null, name + ":" + value);
			}
		}
		void IInternalExtendedPropertyObject.SetExtendedProperty(string name, string value, ExtendedPropertyType type, bool undoable) {
			this.SetExtendedProperty(name, value, type, undoable);
		}

		///<summary>Remove an ExtendedProperty by the given name.</summary>
		[IntelliSense("Remove an ExtendedProperty by the given name.")]
		public void RemoveExtendedProperty(string name) {
			RemoveExtendedProperty(name, true);
		}

		internal void RemoveExtendedProperty(string name, bool undoable) {
			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Get current value:
				if(undoable) {
					bool cancel = false;
					OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + GetExtendedProperty(name), ref undoable, ref cancel);
					if (cancel) return;
				}

				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				MetadataObject.ExtendedProperties.Remove(name);

				// Undo-handling:
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, null, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, null);
			}
		}
		void IInternalExtendedPropertyObject.RemoveExtendedProperty(string name, bool undoable) {
			this.RemoveExtendedProperty(name, undoable);
		}
		///<summary>Gets the number of ExtendedProperties on the current object.</summary>
		[IntelliSense("Gets the number of ExtendedProperties on the current object.")]
		public int GetExtendedPropertyCount() {
			return MetadataObject.ExtendedProperties.Count;
		}
		///<summary>Gets a collection of all ExtendedProperty names on the current object.</summary>
		[IntelliSense("Gets a collection of all ExtendedProperty names on the current object.")]
		public IEnumerable<string> GetExtendedProperties() {
			return MetadataObject.ExtendedProperties.Select(a => a.Name);
		}

		/// <summary>
///             The description of the KPI, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio.
///             </summary>
		[DisplayName("Description")]
		[Category("Basic"),Description(@"The description of the KPI, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio."),IntelliSense(@"The description of the KPI, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio.")][Editor(typeof(System.ComponentModel.Design.MultilineStringEditor), typeof(System.Drawing.Design.UITypeEditor))]
		public string Description {
			get {
			    return MetadataObject.Description;
			}
			set {
				
				var oldValue = Description;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DESCRIPTION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.Description = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DESCRIPTION, oldValue, newValue));
				OnPropertyChanged(Properties.DESCRIPTION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeDescription() { return false; }
/// <summary>
///             The description of the target value of the KPI.
///             </summary>
		[DisplayName("Target Description")]
		[Category("Options"),Description(@"The description of the target value of the KPI."),IntelliSense(@"The description of the target value of the KPI.")][Editor(typeof(System.ComponentModel.Design.MultilineStringEditor), typeof(System.Drawing.Design.UITypeEditor))]
		public string TargetDescription {
			get {
			    return MetadataObject.TargetDescription;
			}
			set {
				
				var oldValue = TargetDescription;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.TARGETDESCRIPTION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.TargetDescription = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.TARGETDESCRIPTION, oldValue, newValue));
				OnPropertyChanged(Properties.TARGETDESCRIPTION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeTargetDescription() { return false; }
/// <summary>
///             An expression that evaluates to a number and indicates the goal for the KPI.
///             </summary>
		[DisplayName("Target Expression")]
		[Category("Options"),Description(@"An expression that evaluates to a number and indicates the goal for the KPI."),IntelliSense(@"An expression that evaluates to a number and indicates the goal for the KPI.")][Editor(typeof(System.ComponentModel.Design.MultilineStringEditor), typeof(System.Drawing.Design.UITypeEditor))]
		public string TargetExpression {
			get {
			    return MetadataObject.TargetExpression;
			}
			set {
				
				var oldValue = TargetExpression;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.TARGETEXPRESSION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.TargetExpression = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.TARGETEXPRESSION, oldValue, newValue));
				OnPropertyChanged(Properties.TARGETEXPRESSION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeTargetExpression() { return false; }
/// <summary>
///             The format string to be used when presenting the target value for the KPI.
///             </summary>
		[DisplayName("Target Format String")]
		[Category("Options"),Description(@"The format string to be used when presenting the target value for the KPI."),IntelliSense(@"The format string to be used when presenting the target value for the KPI.")][TypeConverter(typeof(FormatStringConverter))]
		public string TargetFormatString {
			get {
			    return MetadataObject.TargetFormatString;
			}
			set {
				
				var oldValue = TargetFormatString;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.TARGETFORMATSTRING, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.TargetFormatString = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.TARGETFORMATSTRING, oldValue, newValue));
				OnPropertyChanged(Properties.TARGETFORMATSTRING, oldValue, newValue);
			}
		}
		private bool ShouldSerializeTargetFormatString() { return false; }
/// <summary>
///             The recommended graphic to represent the status of this KPI.
///             </summary>
		[DisplayName("Status Graphic")]
		[Category("Options"),Description(@"The recommended graphic to represent the status of this KPI."),IntelliSense(@"The recommended graphic to represent the status of this KPI.")][TypeConverter(typeof(KPIStatusGraphicConverter))]
		public string StatusGraphic {
			get {
			    return MetadataObject.StatusGraphic;
			}
			set {
				
				var oldValue = StatusGraphic;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.STATUSGRAPHIC, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.StatusGraphic = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.STATUSGRAPHIC, oldValue, newValue));
				OnPropertyChanged(Properties.STATUSGRAPHIC, oldValue, newValue);
			}
		}
		private bool ShouldSerializeStatusGraphic() { return false; }
/// <summary>
///             A description of the Status value for the KPI.
///             </summary>
		[DisplayName("Status Description")]
		[Category("Options"),Description(@"A description of the Status value for the KPI."),IntelliSense(@"A description of the Status value for the KPI.")][Editor(typeof(System.ComponentModel.Design.MultilineStringEditor), typeof(System.Drawing.Design.UITypeEditor))]
		public string StatusDescription {
			get {
			    return MetadataObject.StatusDescription;
			}
			set {
				
				var oldValue = StatusDescription;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.STATUSDESCRIPTION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.StatusDescription = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.STATUSDESCRIPTION, oldValue, newValue));
				OnPropertyChanged(Properties.STATUSDESCRIPTION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeStatusDescription() { return false; }
/// <summary>
///             An expression that is used to calculate the status of the KPI.
///             </summary>
		[DisplayName("Status Expression")]
		[Category("Options"),Description(@"An expression that is used to calculate the status of the KPI."),IntelliSense(@"An expression that is used to calculate the status of the KPI.")][Editor(typeof(System.ComponentModel.Design.MultilineStringEditor), typeof(System.Drawing.Design.UITypeEditor))]
		public string StatusExpression {
			get {
			    return MetadataObject.StatusExpression;
			}
			set {
				
				var oldValue = StatusExpression;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.STATUSEXPRESSION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.StatusExpression = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.STATUSEXPRESSION, oldValue, newValue));
				OnPropertyChanged(Properties.STATUSEXPRESSION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeStatusExpression() { return false; }
/// <summary>
///             A string that identifies the graphic to show for the trend of the KPI.
///             </summary>
		[DisplayName("Trend Graphic")]
		[Category("Options"),Description(@"A string that identifies the graphic to show for the trend of the KPI."),IntelliSense(@"A string that identifies the graphic to show for the trend of the KPI.")][TypeConverter(typeof(KPITrendGraphicConverter))]
		public string TrendGraphic {
			get {
			    return MetadataObject.TrendGraphic;
			}
			set {
				
				var oldValue = TrendGraphic;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.TRENDGRAPHIC, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.TrendGraphic = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.TRENDGRAPHIC, oldValue, newValue));
				OnPropertyChanged(Properties.TRENDGRAPHIC, oldValue, newValue);
			}
		}
		private bool ShouldSerializeTrendGraphic() { return false; }
/// <summary>
///             A description of the trend value of the KPI.
///             </summary>
		[DisplayName("Trend Description")]
		[Category("Options"),Description(@"A description of the trend value of the KPI."),IntelliSense(@"A description of the trend value of the KPI.")][Editor(typeof(System.ComponentModel.Design.MultilineStringEditor), typeof(System.Drawing.Design.UITypeEditor))]
		public string TrendDescription {
			get {
			    return MetadataObject.TrendDescription;
			}
			set {
				
				var oldValue = TrendDescription;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.TRENDDESCRIPTION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.TrendDescription = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.TRENDDESCRIPTION, oldValue, newValue));
				OnPropertyChanged(Properties.TRENDDESCRIPTION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeTrendDescription() { return false; }
/// <summary>
///             An expression representing the trend of the KPI.
///             </summary>
		[DisplayName("Trend Expression")]
		[Category("Options"),Description(@"An expression representing the trend of the KPI."),IntelliSense(@"An expression representing the trend of the KPI.")][Editor(typeof(System.ComponentModel.Design.MultilineStringEditor), typeof(System.Drawing.Design.UITypeEditor))]
		public string TrendExpression {
			get {
			    return MetadataObject.TrendExpression;
			}
			set {
				
				var oldValue = TrendExpression;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.TRENDEXPRESSION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.TrendExpression = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.TRENDEXPRESSION, oldValue, newValue));
				OnPropertyChanged(Properties.TRENDEXPRESSION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeTrendExpression() { return false; }
/// <summary>
///             A reference to a Measure object that owns this KPI.
///             </summary>
		[DisplayName("Measure")]
		[Category("Options"),Description(@"A reference to a Measure object that owns this KPI."),IntelliSense(@"A reference to a Measure object that owns this KPI.")]
		public Measure Measure {
			get {
				if (MetadataObject.Measure == null) return null;
			    return Handler.WrapperLookup[MetadataObject.Measure] as Measure;
            }
			
		}
		private bool ShouldSerializeMeasure() { return false; }

	
        internal override void RenewMetadataObject()
        {
            Handler.WrapperLookup.Remove(MetadataObject);
            var json = TOM.JsonSerializer.SerializeObject(MetadataObject, RenewMetadataOptions);
            MetadataObject = TOM.JsonSerializer.DeserializeObject<TOM.KPI>(json);
            Handler.WrapperLookup.Add(MetadataObject, this);
        }




		/// <summary>
		/// CTOR - only called from static factory methods on the class
		/// </summary>
		KPI(TOM.KPI metadataObject) : base(metadataObject)
		{
			
			// Create indexer for annotations:
			Annotations = new AnnotationCollection(this);
			
			// Create indexer for extended properties:
			ExtendedProperties = new ExtendedPropertyCollection(this);
		}



		internal override void Undelete(ITabularObjectCollection collection, Type tomObjectType, string tomJson) {
			base.Undelete(collection, tomObjectType, tomJson);
			Reinit();
			ReapplyReferences();
		}
		internal override sealed bool Browsable(string propertyName) {
			// Allow custom overrides to hide a property regardless of its compatibility level requirements:
			if(!base.Browsable(propertyName)) return false;

			switch (propertyName) {

				// Hide properties based on compatibility requirements (inferred from TOM):
				case Properties.EXTENDEDPROPERTIES:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1400 : Handler.CompatibilityLevel >= 1400;
				
				default:
					return true;
			}
		}

    }

  
	/// <summary>
///             Represents a AlternativeSource object. It is a child of either a Table or a Column object.
///             </summary><remarks>This metadata object is only supported when the compatibility level of the database is at 1460 or above.</remarks>
	[TypeConverter(typeof(DynamicPropertyConverter))]
	public sealed partial class AlternateOf: TabularObject
			, IInternalAnnotationObject
	{
	    internal new TOM.AlternateOf MetadataObject 
		{ 
			get 
			{ 
				return base.MetadataObject as TOM.AlternateOf; 
		    } 
			set 
			{ 
				base.MetadataObject = value; 
			}
		}

        private bool CanClearAnnotations() => GetAnnotationsCount() > 0;
        ///<summary>Removes all annotations from this object.</summary>
        [IntelliSense("Removes all annotations from this object.")]
        public void ClearAnnotations()
        {
            Handler.BeginUpdate("Clear annotations");
            foreach(var annotation in GetAnnotations().ToList()) {
                RemoveAnnotation(annotation);
            }
            Handler.EndUpdate();
        }

		///<summary>The collection of Annotations on the current Alternate Of.</summary>
        [Browsable(true),NoMultiselect,Category("Metadata"),Description("The collection of Annotations on the current Alternate Of."),Editor(typeof(AnnotationCollectionEditor), typeof(UITypeEditor))]
        [PropertyAction(nameof(ClearAnnotations))]
		public AnnotationCollection Annotations { get; private set; }
		///<summary>Gets the value of the annotation with the given index, assuming it exists.</summary>
		[IntelliSense("Gets the value of the annotation with the given index, assuming it exists.")]
		public string GetAnnotation(int index) {
			return MetadataObject.Annotations[index].Value;
		}
		///<summary>Returns true if an annotation with the given name exists. Otherwise false.</summary>
		[IntelliSense("Returns true if an annotation with the given name exists. Otherwise false.")]
		public bool HasAnnotation(string name) {
		    return MetadataObject.Annotations.ContainsName(name);
		}
		///<summary>Gets the value of the annotation with the given name. Returns null if no such annotation exists.</summary>
		[IntelliSense("Gets the value of the annotation with the given name. Returns null if no such annotation exists.")]
		public string GetAnnotation(string name) {
		    return HasAnnotation(name) ? MetadataObject.Annotations[name].Value : null;
		}
		///<summary>Sets the value of the annotation with the given index, assuming it exists.</summary>
		[IntelliSense("Sets the value of the annotation with the given index, assuming it exists.")]
		public void SetAnnotation(int index, string value) {
		    SetAnnotation(index, value, true);
		}
		internal void SetAnnotation(int index, string value, bool undoable) {
		    var name = MetadataObject.Annotations[index].Name;
			SetAnnotation(name, value, undoable);
		}
		void IInternalAnnotationObject.SetAnnotation(int index, string value, bool undoable) {
			SetAnnotation(index, value, undoable);
		}
		///<summary>Returns a unique name for a new annotation.</summary>
		public string GetNewAnnotationName() {
			return MetadataObject.Annotations.GetNewName("New Annotation");
		}
		///<summary>Sets the value of the annotation having the given name. If no such annotation exists, it will be created. If value is set to null, the annotation will be removed.</summary>
		[IntelliSense("Sets the value of the annotation having the given name. If no such annotation exists, it will be created. If value is set to null, the annotation will be removed.")]
		public void SetAnnotation(string name, string value) {
		    SetAnnotation(name, value, true);
		}
		internal void SetAnnotation(string name, string value, bool undoable) {
			if(name == null) name = GetNewAnnotationName();

			if(value == null) {
				// Remove annotation if set to null:
				RemoveAnnotation(name, undoable);
				return;
			}

			if(undoable) {
 				if(GetAnnotation(name) == value) return;
				bool undoable2 = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + value, ref undoable2, ref cancel);
				if (cancel) return;
			}

			if(MetadataObject.Annotations.Contains(name)) {
				// Change existing annotation:

				var oldValue = GetAnnotation(name);
				MetadataObject.Annotations[name].Value = value;
				if (undoable) {
					Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, oldValue));
					OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, name + ":" + value);
				}
			} else {
				// Add new annotation:

				MetadataObject.Annotations.Add(new TOM.Annotation{ Name = name, Value = value });
				if (undoable) {
					Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, null));
					OnPropertyChanged(Properties.ANNOTATIONS, null, name + ":" + value);
				}
			}
		}
		void IInternalAnnotationObject.SetAnnotation(string name, string value, bool undoable) {
			this.SetAnnotation(name, value, undoable);
		}
		///<summary>Remove an annotation by the given name.</summary>
		[IntelliSense("Remove an annotation by the given name.")]
		public void RemoveAnnotation(string name) {
		    RemoveAnnotation(name, true);
		}
		internal void RemoveAnnotation(string name, bool undoable) {
			if(MetadataObject.Annotations.Contains(name)) {
				if(undoable) 
				{
				    bool undoable2 = true;
				    bool cancel = false;
				    OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + GetAnnotation(name), ref undoable2, ref cancel);
				    if (cancel) return;
				}

			    var oldValue = MetadataObject.Annotations[name].Value;
				MetadataObject.Annotations.Remove(name);

				if (undoable) 
				{
					Handler.UndoManager.Add(new UndoAnnotationAction(this, name, null, oldValue));
					OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, null);
			    }
			}
		}
		void IInternalAnnotationObject.RemoveAnnotation(string name, bool undoable) {
			this.RemoveAnnotation(name, undoable);
		}
		///<summary>Gets the number of annotations on the current Alternate Of.</summary>
		[IntelliSense("Gets the number of annotations on the current Alternate Of.")]
		public int GetAnnotationsCount() {
			return MetadataObject.Annotations.Count;
		}
		///<summary>Gets a collection of all annotation names on the current Alternate Of.</summary>
		[IntelliSense("Gets a collection of all annotation names on the current Alternate Of.")]
		public IEnumerable<string> GetAnnotations() {
			return MetadataObject.Annotations.Select(a => a.Name);
		}

		/// <summary>
///             A value indicating the summarization type used by this alternative sources' column. The possible values are GroupBy (0), Sum (1), Count (2), Min (3), Max (4).
///             </summary>
		[DisplayName("Summarization")]
		[Category("Options"),Description(@"A value indicating the summarization type used by this alternative sources' column. The possible values are GroupBy (0), Sum (1), Count (2), Min (3), Max (4)."),IntelliSense(@"A value indicating the summarization type used by this alternative sources' column. The possible values are GroupBy (0), Sum (1), Count (2), Min (3), Max (4).")]
		public SummarizationType Summarization {
			get {
			    return (SummarizationType)MetadataObject.Summarization;
			}
			set {
				
				var oldValue = Summarization;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.SUMMARIZATION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.Summarization = (TOM.SummarizationType)newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.SUMMARIZATION, oldValue, newValue));
				OnPropertyChanged(Properties.SUMMARIZATION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeSummarization() { return false; }
/// <summary>
///             ID of the owning/parent column.
///             </summary>
		[DisplayName("Column")]
		[Category("Options"),Description(@"ID of the owning/parent column."),IntelliSense(@"ID of the owning/parent column.")]
		public Column Column {
			get {
				if (MetadataObject.Column == null) return null;
			    return Handler.WrapperLookup[MetadataObject.Column] as Column;
            }
			
		}
		private bool ShouldSerializeColumn() { return false; }
/// <summary>
///             A reference ID to the referenced source column.
///             </summary>
		[DisplayName("Base Column")]
		[Category("Options"),Description(@"A reference ID to the referenced source column."),IntelliSense(@"A reference ID to the referenced source column.")][TypeConverter(typeof(AllOtherTablesColumnConverter))]
		public Column BaseColumn {
			get {
				if (MetadataObject.BaseColumn == null) return null;
			    return Handler.WrapperLookup[MetadataObject.BaseColumn] as Column;
            }
			set {
				
				var oldValue = BaseColumn;
				var newValue = value;
				if (oldValue?.MetadataObject == newValue?.MetadataObject) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.BASECOLUMN, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.BaseColumn = value?.MetadataObject;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.BASECOLUMN, oldValue, newValue));
				OnPropertyChanged(Properties.BASECOLUMN, oldValue, newValue);
			}
		}
		private bool ShouldSerializeBaseColumn() { return false; }
/// <summary>
///             A reference ID to the referenced source table. You may either define BaseTable or BaseColumn, but not both.
///             </summary>
		[DisplayName("Base Table")]
		[Category("Options"),Description(@"A reference ID to the referenced source table. You may either define BaseTable or BaseColumn, but not both."),IntelliSense(@"A reference ID to the referenced source table. You may either define BaseTable or BaseColumn, but not both.")][TypeConverter(typeof(OtherTablesConverter))]
		public Table BaseTable {
			get {
				if (MetadataObject.BaseTable == null) return null;
			    return Handler.WrapperLookup[MetadataObject.BaseTable] as Table;
            }
			set {
				
				var oldValue = BaseTable;
				var newValue = value;
				if (oldValue?.MetadataObject == newValue?.MetadataObject) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.BASETABLE, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.BaseTable = value?.MetadataObject;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.BASETABLE, oldValue, newValue));
				OnPropertyChanged(Properties.BASETABLE, oldValue, newValue);
			}
		}
		private bool ShouldSerializeBaseTable() { return false; }

	
        internal override void RenewMetadataObject()
        {
            Handler.WrapperLookup.Remove(MetadataObject);
            var json = TOM.JsonSerializer.SerializeObject(MetadataObject, RenewMetadataOptions);
            MetadataObject = TOM.JsonSerializer.DeserializeObject<TOM.AlternateOf>(json);
            Handler.WrapperLookup.Add(MetadataObject, this);
        }




		/// <summary>
		/// CTOR - only called from static factory methods on the class
		/// </summary>
		AlternateOf(TOM.AlternateOf metadataObject) : base(metadataObject)
		{
			
			// Create indexer for annotations:
			Annotations = new AnnotationCollection(this);
		}



		internal override void Undelete(ITabularObjectCollection collection, Type tomObjectType, string tomJson) {
			base.Undelete(collection, tomObjectType, tomJson);
			Reinit();
			ReapplyReferences();
		}
		internal override sealed bool Browsable(string propertyName) {
			// Allow custom overrides to hide a property regardless of its compatibility level requirements:
			if(!base.Browsable(propertyName)) return false;

			switch (propertyName) {

				// Hide properties based on compatibility requirements (inferred from TOM):
				
				default:
					return true;
			}
		}

    }

  
	/// <summary>
///             Represents a level in a hierarchy that provides a logical hierarchical drilldown path for client applications. It is a child of a Hierarchy object. The level is based on the values in a column.
///             </summary>
	[TypeConverter(typeof(DynamicPropertyConverter))]
	public sealed partial class Level: TabularNamedObject
			, IDescriptionObject
			, ILineageTagObject
			, IInternalAnnotationObject
			, IInternalExtendedPropertyObject
			, IInternalTranslatableObject
			, ISynonymObject
			, IClonableObject
	{
	    internal new TOM.Level MetadataObject 
		{ 
			get 
			{ 
				return base.MetadataObject as TOM.Level; 
		    } 
			set 
			{ 
				base.MetadataObject = value; 
			}
		}

        private bool CanClearAnnotations() => GetAnnotationsCount() > 0;
        ///<summary>Removes all annotations from this object.</summary>
        [IntelliSense("Removes all annotations from this object.")]
        public void ClearAnnotations()
        {
            Handler.BeginUpdate("Clear annotations");
            foreach(var annotation in GetAnnotations().ToList()) {
                RemoveAnnotation(annotation);
            }
            Handler.EndUpdate();
        }

		///<summary>The collection of Annotations on the current Level.</summary>
        [Browsable(true),NoMultiselect,Category("Metadata"),Description("The collection of Annotations on the current Level."),Editor(typeof(AnnotationCollectionEditor), typeof(UITypeEditor))]
        [PropertyAction(nameof(ClearAnnotations))]
		public AnnotationCollection Annotations { get; private set; }
		///<summary>Gets the value of the annotation with the given index, assuming it exists.</summary>
		[IntelliSense("Gets the value of the annotation with the given index, assuming it exists.")]
		public string GetAnnotation(int index) {
			return MetadataObject.Annotations[index].Value;
		}
		///<summary>Returns true if an annotation with the given name exists. Otherwise false.</summary>
		[IntelliSense("Returns true if an annotation with the given name exists. Otherwise false.")]
		public bool HasAnnotation(string name) {
		    return MetadataObject.Annotations.ContainsName(name);
		}
		///<summary>Gets the value of the annotation with the given name. Returns null if no such annotation exists.</summary>
		[IntelliSense("Gets the value of the annotation with the given name. Returns null if no such annotation exists.")]
		public string GetAnnotation(string name) {
		    return HasAnnotation(name) ? MetadataObject.Annotations[name].Value : null;
		}
		///<summary>Sets the value of the annotation with the given index, assuming it exists.</summary>
		[IntelliSense("Sets the value of the annotation with the given index, assuming it exists.")]
		public void SetAnnotation(int index, string value) {
		    SetAnnotation(index, value, true);
		}
		internal void SetAnnotation(int index, string value, bool undoable) {
		    var name = MetadataObject.Annotations[index].Name;
			SetAnnotation(name, value, undoable);
		}
		void IInternalAnnotationObject.SetAnnotation(int index, string value, bool undoable) {
			SetAnnotation(index, value, undoable);
		}
		///<summary>Returns a unique name for a new annotation.</summary>
		public string GetNewAnnotationName() {
			return MetadataObject.Annotations.GetNewName("New Annotation");
		}
		///<summary>Sets the value of the annotation having the given name. If no such annotation exists, it will be created. If value is set to null, the annotation will be removed.</summary>
		[IntelliSense("Sets the value of the annotation having the given name. If no such annotation exists, it will be created. If value is set to null, the annotation will be removed.")]
		public void SetAnnotation(string name, string value) {
		    SetAnnotation(name, value, true);
		}
		internal void SetAnnotation(string name, string value, bool undoable) {
			if(name == null) name = GetNewAnnotationName();

			if(value == null) {
				// Remove annotation if set to null:
				RemoveAnnotation(name, undoable);
				return;
			}

			if(undoable) {
 				if(GetAnnotation(name) == value) return;
				bool undoable2 = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + value, ref undoable2, ref cancel);
				if (cancel) return;
			}

			if(MetadataObject.Annotations.Contains(name)) {
				// Change existing annotation:

				var oldValue = GetAnnotation(name);
				MetadataObject.Annotations[name].Value = value;
				if (undoable) {
					Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, oldValue));
					OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, name + ":" + value);
				}
			} else {
				// Add new annotation:

				MetadataObject.Annotations.Add(new TOM.Annotation{ Name = name, Value = value });
				if (undoable) {
					Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, null));
					OnPropertyChanged(Properties.ANNOTATIONS, null, name + ":" + value);
				}
			}
		}
		void IInternalAnnotationObject.SetAnnotation(string name, string value, bool undoable) {
			this.SetAnnotation(name, value, undoable);
		}
		///<summary>Remove an annotation by the given name.</summary>
		[IntelliSense("Remove an annotation by the given name.")]
		public void RemoveAnnotation(string name) {
		    RemoveAnnotation(name, true);
		}
		internal void RemoveAnnotation(string name, bool undoable) {
			if(MetadataObject.Annotations.Contains(name)) {
				if(undoable) 
				{
				    bool undoable2 = true;
				    bool cancel = false;
				    OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + GetAnnotation(name), ref undoable2, ref cancel);
				    if (cancel) return;
				}

			    var oldValue = MetadataObject.Annotations[name].Value;
				MetadataObject.Annotations.Remove(name);

				if (undoable) 
				{
					Handler.UndoManager.Add(new UndoAnnotationAction(this, name, null, oldValue));
					OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, null);
			    }
			}
		}
		void IInternalAnnotationObject.RemoveAnnotation(string name, bool undoable) {
			this.RemoveAnnotation(name, undoable);
		}
		///<summary>Gets the number of annotations on the current Level.</summary>
		[IntelliSense("Gets the number of annotations on the current Level.")]
		public int GetAnnotationsCount() {
			return MetadataObject.Annotations.Count;
		}
		///<summary>Gets a collection of all annotation names on the current Level.</summary>
		[IntelliSense("Gets a collection of all annotation names on the current Level.")]
		public IEnumerable<string> GetAnnotations() {
			return MetadataObject.Annotations.Select(a => a.Name);
		}

		        private bool CanClearExtendedProperties() => GetExtendedPropertyCount() > 0;
        ///<summary>Removes all Extended Properties from this object.</summary>
        [IntelliSense("Removes all Extended Properties from this object.")]
        public void ClearExtendedProperties()
        {
            Handler.BeginUpdate("Clear extended properties");
            foreach(var extendedProperty in GetExtendedProperties().ToList()) {
                RemoveExtendedProperty(extendedProperty);
            }
            Handler.EndUpdate();
        }

		///<summary>The collection of Extended Properties on the current Level.</summary>
        [DisplayName("Extended Properties"),NoMultiselect,Category("Metadata"),Description("The collection of Extended Properties on the current Level."),Editor(typeof(ExtendedPropertyCollectionEditor), typeof(UITypeEditor))]
        [PropertyAction(nameof(ClearExtendedProperties))]
		public ExtendedPropertyCollection ExtendedProperties { get; private set; }

		///<summary>Returns true if an ExtendedProperty with the given name exists. Otherwise false.</summary>
		[IntelliSense("Returns true if an ExtendedProperty with the given name exists. Otherwise false.")]
		public bool HasExtendedProperty(string name) {
		    return MetadataObject.ExtendedProperties.ContainsName(name);
		}
		///<summary>Gets the type of the ExtendedProperty with the given index, assuming it exists.</summary>
		public ExtendedPropertyType GetExtendedPropertyType(int index) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[index].Type;
		}
		///<summary>Gets the type of the ExtendedProperty with the given name, assuming it exists.</summary>
		public ExtendedPropertyType GetExtendedPropertyType(string name) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[name].Type;
		}
		///<summary>Gets the value of the ExtendedProperty with the given index, assuming it exists.</summary>
		public string GetExtendedProperty(int index) {
			var ep = MetadataObject.ExtendedProperties[index];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		///<summary>Gets the value of the ExtendedProperty with the given name. Returns null if no such ExtendedProperty exists.</summary>
		[IntelliSense("Gets the value of the ExtendedProperty with the given name. Returns null if no such ExtendedProperty exists.")]
		public string GetExtendedProperty(string name) {
		    if(!HasExtendedProperty(name)) return null;
			var ep = MetadataObject.ExtendedProperties[name];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		///<summary>Sets the value of the ExtendedProperty with the given index, optionally specifiying the type (string or JSON) of the ExtendedProperty.</summary>
		public void SetExtendedProperty(int index, string value, ExtendedPropertyType type) {
			SetExtendedProperty(index, value, type, true);
		}
		void IInternalExtendedPropertyObject.SetExtendedProperty(int index, string value, ExtendedPropertyType type, bool undoable) {
			SetExtendedProperty(index, value, type, undoable);
		}
		internal void SetExtendedProperty(int index, string value, ExtendedPropertyType type, bool undoable) {
			var name = MetadataObject.ExtendedProperties[index].Name;
			SetExtendedProperty(name, value, type, undoable);
		}
		///<summary>Returns a unique name for a new ExtendedProperty.</summary>
		public string GetNewExtendedPropertyName() {
			return MetadataObject.ExtendedProperties.GetNewName("New ExtendedProperty");
		}
		///<summary>Sets the value of the ExtendedProperty having the given name. If no such ExtendedProperty exists, it will be created. If value is set to null, the ExtendedProperty will be removed.</summary>
		[IntelliSense("Sets the value of the ExtendedProperty having the given name. If no such ExtendedProperty exists, it will be created. If value is set to null, the ExtendedProperty will be removed.")]
		public void SetExtendedProperty(string name, string value, ExtendedPropertyType type) {
			SetExtendedProperty(name, value, type, true);
		}
		internal void SetExtendedProperty(string name, string value, ExtendedPropertyType type, bool undoable) {
			if(name == null) name = GetNewExtendedPropertyName();

			if(value == null) {
				// Remove ExtendedProperty if set to null:
				RemoveExtendedProperty(name);
				return;
			}

			if(GetExtendedProperty(name) == value) return;
			if(undoable) {
				bool cancel = false;
				OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + value, ref undoable, ref cancel);
				if (cancel) return;
			}

			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Change existing ExtendedProperty:
				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				var ep = MetadataObject.ExtendedProperties[name];
				if (ep is TOM.JsonExtendedProperty)
					(ep as TOM.JsonExtendedProperty).Value = value;
				else 
					(ep as TOM.StringExtendedProperty).Value = value;
					
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, name + ":" + value);
			} else {
				// Add new ExtendedProperty:
				if (type == ExtendedPropertyType.Json)
					MetadataObject.ExtendedProperties.Add(new TOM.JsonExtendedProperty{ Name = name, Value = value });
				else
					MetadataObject.ExtendedProperties.Add(new TOM.StringExtendedProperty{ Name = name, Value = value });

				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, null, type));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, null, name + ":" + value);
			}
		}
		void IInternalExtendedPropertyObject.SetExtendedProperty(string name, string value, ExtendedPropertyType type, bool undoable) {
			this.SetExtendedProperty(name, value, type, undoable);
		}

		///<summary>Remove an ExtendedProperty by the given name.</summary>
		[IntelliSense("Remove an ExtendedProperty by the given name.")]
		public void RemoveExtendedProperty(string name) {
			RemoveExtendedProperty(name, true);
		}

		internal void RemoveExtendedProperty(string name, bool undoable) {
			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Get current value:
				if(undoable) {
					bool cancel = false;
					OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + GetExtendedProperty(name), ref undoable, ref cancel);
					if (cancel) return;
				}

				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				MetadataObject.ExtendedProperties.Remove(name);

				// Undo-handling:
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, null, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, null);
			}
		}
		void IInternalExtendedPropertyObject.RemoveExtendedProperty(string name, bool undoable) {
			this.RemoveExtendedProperty(name, undoable);
		}
		///<summary>Gets the number of ExtendedProperties on the current object.</summary>
		[IntelliSense("Gets the number of ExtendedProperties on the current object.")]
		public int GetExtendedPropertyCount() {
			return MetadataObject.ExtendedProperties.Count;
		}
		///<summary>Gets a collection of all ExtendedProperty names on the current object.</summary>
		[IntelliSense("Gets a collection of all ExtendedProperty names on the current object.")]
		public IEnumerable<string> GetExtendedProperties() {
			return MetadataObject.ExtendedProperties.Select(a => a.Name);
		}

		/// <summary>
///             The position of the level within the hierarchy. The levels in the hierarchy must be properly ordered, starting with 1 and increasing monotonically.
///             </summary>
		[DisplayName("Ordinal")]
		[Category("Basic"),Description(@"The position of the level within the hierarchy. The levels in the hierarchy must be properly ordered, starting with 1 and increasing monotonically."),IntelliSense(@"The position of the level within the hierarchy. The levels in the hierarchy must be properly ordered, starting with 1 and increasing monotonically.")][NoMultiselect()]
		public int Ordinal {
			get {
			    return MetadataObject.Ordinal;
			}
			set {
				
				var oldValue = Ordinal;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ORDINAL, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.Ordinal = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.ORDINAL, oldValue, newValue));
				OnPropertyChanged(Properties.ORDINAL, oldValue, newValue);
			}
		}
		private bool ShouldSerializeOrdinal() { return false; }
/// <summary>
///             The description of the level, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio.
///             </summary>
		[DisplayName("Description")]
		[Category("Basic"),Description(@"The description of the level, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio."),IntelliSense(@"The description of the level, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio.")][Editor(typeof(System.ComponentModel.Design.MultilineStringEditor), typeof(System.Drawing.Design.UITypeEditor))]
		public string Description {
			get {
			    return MetadataObject.Description;
			}
			set {
				
				var oldValue = Description;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DESCRIPTION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.Description = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DESCRIPTION, oldValue, newValue));
				OnPropertyChanged(Properties.DESCRIPTION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeDescription() { return false; }
/// <summary>
///             A tag that represents the lineage of the object.
///             </summary><remarks>This property is only supported when the compatibility level of the database is at 1540 or above.</remarks>
		[DisplayName("Lineage Tag")]
		[Category("Options"),Description(@"A tag that represents the lineage of the object."),IntelliSense(@"A tag that represents the lineage of the object.")]
		public string LineageTag {
			get {
			    return MetadataObject.LineageTag;
			}
			set {
				
				var oldValue = LineageTag;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.LINEAGETAG, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.LineageTag = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.LINEAGETAG, oldValue, newValue));
				OnPropertyChanged(Properties.LINEAGETAG, oldValue, newValue);
			}
		}
		private bool ShouldSerializeLineageTag() { return false; }
/// <summary>
///             A tag that represents the lineage of the source for the object.
///             </summary><remarks>This property is only supported when the compatibility level of the database is at 1550 or above.</remarks>
		[DisplayName("Source Lineage Tag")]
		[Category("Options"),Description(@"A tag that represents the lineage of the source for the object."),IntelliSense(@"A tag that represents the lineage of the source for the object.")]
		public string SourceLineageTag {
			get {
			    return MetadataObject.SourceLineageTag;
			}
			set {
				
				var oldValue = SourceLineageTag;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.SOURCELINEAGETAG, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.SourceLineageTag = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.SOURCELINEAGETAG, oldValue, newValue));
				OnPropertyChanged(Properties.SOURCELINEAGETAG, oldValue, newValue);
			}
		}
		private bool ShouldSerializeSourceLineageTag() { return false; }
/// <summary>
///             A reference to a Hierarchy object that owns this level.
///             </summary>
		[DisplayName("Hierarchy")]
		[Category("Options"),Description(@"A reference to a Hierarchy object that owns this level."),IntelliSense(@"A reference to a Hierarchy object that owns this level.")][Browsable(false)]
		public Hierarchy Hierarchy {
			get {
				if (MetadataObject.Hierarchy == null) return null;
			    return Handler.WrapperLookup[MetadataObject.Hierarchy] as Hierarchy;
            }
			
		}
		private bool ShouldSerializeHierarchy() { return false; }
/// <summary>
///             A reference to a Column object associated with this Level.
///             </summary>
		[DisplayName("Column")]
		[Category("Basic"),Description(@"A reference to a Column object associated with this Level."),IntelliSense(@"A reference to a Column object associated with this Level.")][TypeConverter(typeof(HierarchyColumnConverter)),NoMultiselect()]
		public Column Column {
			get {
				if (MetadataObject.Column == null) return null;
			    return Handler.WrapperLookup[MetadataObject.Column] as Column;
            }
			set {
				
				var oldValue = Column;
				var newValue = value;
				if (oldValue?.MetadataObject == newValue?.MetadataObject) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.COLUMN, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.Column = value == null ? null : Hierarchy.Table.Columns[value.MetadataObject.Name].MetadataObject;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.COLUMN, oldValue, newValue));
				OnPropertyChanged(Properties.COLUMN, oldValue, newValue);
			}
		}
		private bool ShouldSerializeColumn() { return false; }

        /// <summary>
        /// Collection of localized descriptions for this Level.
        /// </summary>
        [Browsable(true),DisplayName("Translated Descriptions"),Description("Shows all translated descriptions of the current Level."),Category("Translations, Perspectives, Security")]
	    public TranslationIndexer TranslatedDescriptions { private set; get; }
        /// <summary>
        /// Collection of localized names for this Level.
        /// </summary>
        [Browsable(true),DisplayName("Translated Names"),Description("Shows all translated names of the current Level."),Category("Translations, Perspectives, Security")]
	    public TranslationIndexer TranslatedNames { private set; get; }

        /// <summary>
        /// Collection of localized synonyms for this Level.
        /// </summary>
        [Browsable(true),DisplayName("Synonyms"),Description("Shows all translated synonyms of the current Level."),Category("Translations, Perspectives, Security")]
	    public SynonymIndexer Synonyms { private set; get; }
		internal static Level CreateFromMetadata(Hierarchy parent, TOM.Level metadataObject) {
            // Generate a new LineageTag if an object with the provided lineage tag already exists:
            if(!string.IsNullOrEmpty(metadataObject.LineageTag)) {
                if (parent.Handler.CompatibilityLevel < 1540) metadataObject.LineageTag = null;
                else if (parent.MetadataObject.Levels.FindByLineageTag(metadataObject.LineageTag) != metadataObject) {
                    metadataObject.LineageTag = Guid.NewGuid().ToString();
                }
            }
			var obj = new Level(metadataObject);
			parent.Levels.Add(obj);
			
			obj.Init();

			return obj;
		}


		/// <summary>
		/// Creates a new Level and adds it to the parent Hierarchy.
		/// Also creates the underlying metadataobject and adds it to the TOM tree.
		/// </summary>
		public static Level CreateNew(Hierarchy parent, string name = null)
		{
			if(!parent.Handler.PowerBIGovernance.AllowCreate(typeof(Level))) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(Level).GetTypeName()));
			}

			var metadataObject = new TOM.Level();
            if(parent.Model.Database.CompatibilityLevel >= 1540) metadataObject.LineageTag = Guid.NewGuid().ToString();
			metadataObject.Name = parent.Levels.GetNewName(string.IsNullOrWhiteSpace(name) ? "New " + typeof(Level).GetTypeName() : name);
            InitMetadata(metadataObject, parent);
            var obj = new Level(metadataObject);

			parent.Levels.Add(obj);
			
			obj.Init();

			return obj;
		}

        static partial void InitMetadata(TOM.Level metadataObject, Hierarchy parent);


		/// <summary>
		/// Creates an exact copy of this Level object.
		/// </summary>
		[IntelliSense("Creates an exact copy of this Level object.")]
		public Level Clone(string newName = null, bool includeTranslations = true, Hierarchy newParent = null) {
			if(!Handler.PowerBIGovernance.AllowCreate(this.GetType())) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(Level).GetTypeName()));
			}

		    Handler.BeginUpdate("Clone Level");

			// Create a clone of the underlying metadataobject:
			var tom = MetadataObject.Clone() as TOM.Level;

            if(Model.Database.CompatibilityLevel >= 1540 && !string.IsNullOrEmpty(LineageTag)) {
                tom.LineageTag = Guid.NewGuid().ToString();
            }

			// Assign a new, unique name:
			tom.Name = Parent.Levels.GetNewName(string.IsNullOrEmpty(newName) ? tom.Name + " copy" : newName);
				
			// Create the TOM Wrapper object, representing the metadataobject
			Level obj = CreateFromMetadata(newParent ?? Parent, tom);

			// Copy translations, if applicable:
			if(includeTranslations) {
				obj.CopyTranslationsFrom(this);
			}
            Handler.EndUpdate();

            return obj;
		}

		TabularNamedObject IClonableObject.Clone(string newName, bool includeTranslations, TabularNamedObject newParent) 
		{
			return Clone(newName, includeTranslations);
		}

	
        internal override void RenewMetadataObject()
        {
            Handler.WrapperLookup.Remove(MetadataObject);
            var json = TOM.JsonSerializer.SerializeObject(MetadataObject, RenewMetadataOptions);
            MetadataObject = TOM.JsonSerializer.DeserializeObject<TOM.Level>(json);
            Handler.WrapperLookup.Add(MetadataObject, this);
        }

		///<summary>The parent Hierarchy of the current Level.</summary>
		public Hierarchy Parent { 
			get {
				return Handler.WrapperLookup[MetadataObject.Parent] as Hierarchy;
			}
		}



		/// <summary>
		/// CTOR - only called from static factory methods on the class
		/// </summary>
		Level(TOM.Level metadataObject) : base(metadataObject)
		{
			// Create indexers for translations:
			TranslatedNames = new TranslationIndexer(this, TOM.TranslatedProperty.Caption);
			TranslatedDescriptions = new TranslationIndexer(this, TOM.TranslatedProperty.Description);
			Synonyms = new SynonymIndexer(this);
			
			// Create indexer for annotations:
			Annotations = new AnnotationCollection(this);
			
			// Create indexer for extended properties:
			ExtendedProperties = new ExtendedPropertyCollection(this);
		}



		internal override void Undelete(ITabularObjectCollection collection, Type tomObjectType, string tomJson) {
			base.Undelete(collection, tomObjectType, tomJson);
			Reinit();
			ReapplyReferences();
		}
		internal override sealed bool Browsable(string propertyName) {
			// Allow custom overrides to hide a property regardless of its compatibility level requirements:
			if(!base.Browsable(propertyName)) return false;

			switch (propertyName) {

				// Hide properties based on compatibility requirements (inferred from TOM):
				case Properties.EXTENDEDPROPERTIES:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1400 : Handler.CompatibilityLevel >= 1400;
				case Properties.LINEAGETAG:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1540 : Handler.CompatibilityLevel >= 1540;
				case Properties.SOURCELINEAGETAG:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1550 : Handler.CompatibilityLevel >= 1550;
				case Properties.PARENT:
					return false;
				case nameof(Synonyms):
					return Synonyms.LinguisticCultures.Any();
				
				// Hides translation properties in the grid, unless the model actually contains translations:
				case Properties.TRANSLATEDNAMES:
				case Properties.TRANSLATEDDESCRIPTIONS:
					return Model.Cultures.Any();
				
				default:
					return true;
			}
		}

    }


	/// <summary>
	/// Collection class for Level. Provides convenient properties for setting a property on multiple objects at once.
	/// </summary>
	public sealed partial class LevelCollection: TabularObjectCollection<Level>
	{
		internal Hierarchy Hierarchy { get { return Parent as Hierarchy; } }
		TOM.LevelCollection TOM_Collection;
		internal LevelCollection(string collectionName, TOM.LevelCollection metadataObjectCollection, Hierarchy parent) : base(collectionName, parent)
		{
			TOM_Collection = metadataObjectCollection;
		}
		internal override Type GetItemType() { return typeof(Level); }
        internal override void TOM_Add(TOM.MetadataObject obj) { TOM_Collection.Add(obj as TOM.Level); }
        internal override bool TOM_Contains(TOM.MetadataObject obj) { return TOM_Collection.Contains(obj as TOM.Level); }
        internal override void TOM_Remove(TOM.MetadataObject obj) { TOM_Collection.Remove(obj as TOM.Level); }
        internal override void TOM_Clear() { TOM_Collection.Clear(); }
        internal override bool TOM_ContainsName(string name) { return TOM_Collection.ContainsName(name); }
		internal override TOM.MetadataObject TOM_Get(int index) { return TOM_Collection[index]; }
        internal override TOM.MetadataObject TOM_Get(string name) { return TOM_Collection[name]; }
        internal override TOM.MetadataObject TOM_Find(string name) { return TOM_Collection.Find(name); }
        internal override string GetNewName(string prefix = null) { return string.IsNullOrEmpty(prefix) ? TOM_Collection.GetNewName() : TOM_Collection.GetNewName(prefix); }
        internal override int IndexOf(TOM.MetadataObject obj) { return TOM_Collection.IndexOf(obj as TOM.Level); }
        /// <summary>The number of items in this collection.</summary>
		public override int Count { get { return TOM_Collection.Count; } }
		/// <summary>Returns an enumerator that iterates through the collection.</summary>
        public override IEnumerator<Level> GetEnumerator() { return TOM_Collection.Select(h => Handler.WrapperLookup[h]).OfType<Level>().GetEnumerator(); }
		internal override void Reinit() {
			var ixOffset = 0;
			for(int i = 0; i < Count; i++) {
				var metadataObj = TOM_Get(i) as TOM.Level;
				var item = Handler.WrapperLookup.TryGetValue(metadataObj, out var existingItem) ? existingItem as Level : CreateFromMetadata(metadataObj);
				Handler.WrapperLookup.Remove(item.MetadataObject);
				item.MetadataObject = Hierarchy.MetadataObject.Levels[i + ixOffset] as TOM.Level;
				Handler.WrapperLookup.Add(item.MetadataObject, item);
				item.Collection = this;
			}
			TOM_Collection = Hierarchy.MetadataObject.Levels;
			foreach(var item in this) item.Reinit();
		}

		internal override void ReapplyReferences() {
			foreach(var item in this) item.ReapplyReferences();
		}

		private Level CreateFromMetadata(TOM.Level obj)
		{
			if(obj is TOM.Level levelObj) return Level.CreateFromMetadata(Hierarchy, levelObj);
		    return null;
		}

		/// <summary>
		/// Calling this method will populate the LevelCollection with objects based on the MetadataObjects in the corresponding MetadataObjectCollection.
		/// </summary>
		internal override void CreateChildrenFromMetadata()
		{
			// Construct child objects (they are automatically added to the Handler's WrapperLookup dictionary):
			foreach(var obj in TOM_Collection)
			{
				CreateFromMetadata(obj);
			}
		}

		/// <summary>
		/// Sets the Description property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the Description property of all objects in the collection at once.")]
		public string Description {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("Description"));
				this.ToList().ForEach(item => { item.Description = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the SourceLineageTag property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the SourceLineageTag property of all objects in the collection at once.")]
		public string SourceLineageTag {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("SourceLineageTag"));
				this.ToList().ForEach(item => { item.SourceLineageTag = value; });
				Handler.UndoManager.EndBatch();
			}
		}
	}
  
	/// <summary>
///             Represents a value that is calculated based on an expression. It is a child of a Table object.
///             </summary>
	[TypeConverter(typeof(DynamicPropertyConverter))]
	public sealed partial class Measure: TabularNamedObject
			, IFolderObject
			, IHideableObject
			, IErrorMessageObject
			, ITabularTableObject
			, IDescriptionObject
			, IExpressionObject
			, IFormattableObject
			, ILineageTagObject
			, IInternalAnnotationObject
			, IInternalExtendedPropertyObject
			, IInternalTabularPerspectiveObject
			, IInternalTranslatableObject
			, ISynonymObject
			, IClonableObject
	{
	    internal new TOM.Measure MetadataObject 
		{ 
			get 
			{ 
				return base.MetadataObject as TOM.Measure; 
		    } 
			set 
			{ 
				base.MetadataObject = value; 
			}
		}

        private bool CanClearAnnotations() => GetAnnotationsCount() > 0;
        ///<summary>Removes all annotations from this object.</summary>
        [IntelliSense("Removes all annotations from this object.")]
        public void ClearAnnotations()
        {
            Handler.BeginUpdate("Clear annotations");
            foreach(var annotation in GetAnnotations().ToList()) {
                RemoveAnnotation(annotation);
            }
            Handler.EndUpdate();
        }

		///<summary>The collection of Annotations on the current Measure.</summary>
        [Browsable(true),NoMultiselect,Category("Metadata"),Description("The collection of Annotations on the current Measure."),Editor(typeof(AnnotationCollectionEditor), typeof(UITypeEditor))]
        [PropertyAction(nameof(ClearAnnotations))]
		public AnnotationCollection Annotations { get; private set; }
		///<summary>Gets the value of the annotation with the given index, assuming it exists.</summary>
		[IntelliSense("Gets the value of the annotation with the given index, assuming it exists.")]
		public string GetAnnotation(int index) {
			return MetadataObject.Annotations[index].Value;
		}
		///<summary>Returns true if an annotation with the given name exists. Otherwise false.</summary>
		[IntelliSense("Returns true if an annotation with the given name exists. Otherwise false.")]
		public bool HasAnnotation(string name) {
		    return MetadataObject.Annotations.ContainsName(name);
		}
		///<summary>Gets the value of the annotation with the given name. Returns null if no such annotation exists.</summary>
		[IntelliSense("Gets the value of the annotation with the given name. Returns null if no such annotation exists.")]
		public string GetAnnotation(string name) {
		    return HasAnnotation(name) ? MetadataObject.Annotations[name].Value : null;
		}
		///<summary>Sets the value of the annotation with the given index, assuming it exists.</summary>
		[IntelliSense("Sets the value of the annotation with the given index, assuming it exists.")]
		public void SetAnnotation(int index, string value) {
		    SetAnnotation(index, value, true);
		}
		internal void SetAnnotation(int index, string value, bool undoable) {
		    var name = MetadataObject.Annotations[index].Name;
			SetAnnotation(name, value, undoable);
		}
		void IInternalAnnotationObject.SetAnnotation(int index, string value, bool undoable) {
			SetAnnotation(index, value, undoable);
		}
		///<summary>Returns a unique name for a new annotation.</summary>
		public string GetNewAnnotationName() {
			return MetadataObject.Annotations.GetNewName("New Annotation");
		}
		///<summary>Sets the value of the annotation having the given name. If no such annotation exists, it will be created. If value is set to null, the annotation will be removed.</summary>
		[IntelliSense("Sets the value of the annotation having the given name. If no such annotation exists, it will be created. If value is set to null, the annotation will be removed.")]
		public void SetAnnotation(string name, string value) {
		    SetAnnotation(name, value, true);
		}
		internal void SetAnnotation(string name, string value, bool undoable) {
			if(name == null) name = GetNewAnnotationName();

			if(value == null) {
				// Remove annotation if set to null:
				RemoveAnnotation(name, undoable);
				return;
			}

			if(undoable) {
 				if(GetAnnotation(name) == value) return;
				bool undoable2 = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + value, ref undoable2, ref cancel);
				if (cancel) return;
			}

			if(MetadataObject.Annotations.Contains(name)) {
				// Change existing annotation:

				var oldValue = GetAnnotation(name);
				MetadataObject.Annotations[name].Value = value;
				if (undoable) {
					Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, oldValue));
					OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, name + ":" + value);
				}
			} else {
				// Add new annotation:

				MetadataObject.Annotations.Add(new TOM.Annotation{ Name = name, Value = value });
				if (undoable) {
					Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, null));
					OnPropertyChanged(Properties.ANNOTATIONS, null, name + ":" + value);
				}
			}
		}
		void IInternalAnnotationObject.SetAnnotation(string name, string value, bool undoable) {
			this.SetAnnotation(name, value, undoable);
		}
		///<summary>Remove an annotation by the given name.</summary>
		[IntelliSense("Remove an annotation by the given name.")]
		public void RemoveAnnotation(string name) {
		    RemoveAnnotation(name, true);
		}
		internal void RemoveAnnotation(string name, bool undoable) {
			if(MetadataObject.Annotations.Contains(name)) {
				if(undoable) 
				{
				    bool undoable2 = true;
				    bool cancel = false;
				    OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + GetAnnotation(name), ref undoable2, ref cancel);
				    if (cancel) return;
				}

			    var oldValue = MetadataObject.Annotations[name].Value;
				MetadataObject.Annotations.Remove(name);

				if (undoable) 
				{
					Handler.UndoManager.Add(new UndoAnnotationAction(this, name, null, oldValue));
					OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, null);
			    }
			}
		}
		void IInternalAnnotationObject.RemoveAnnotation(string name, bool undoable) {
			this.RemoveAnnotation(name, undoable);
		}
		///<summary>Gets the number of annotations on the current Measure.</summary>
		[IntelliSense("Gets the number of annotations on the current Measure.")]
		public int GetAnnotationsCount() {
			return MetadataObject.Annotations.Count;
		}
		///<summary>Gets a collection of all annotation names on the current Measure.</summary>
		[IntelliSense("Gets a collection of all annotation names on the current Measure.")]
		public IEnumerable<string> GetAnnotations() {
			return MetadataObject.Annotations.Select(a => a.Name);
		}

		        private bool CanClearExtendedProperties() => GetExtendedPropertyCount() > 0;
        ///<summary>Removes all Extended Properties from this object.</summary>
        [IntelliSense("Removes all Extended Properties from this object.")]
        public void ClearExtendedProperties()
        {
            Handler.BeginUpdate("Clear extended properties");
            foreach(var extendedProperty in GetExtendedProperties().ToList()) {
                RemoveExtendedProperty(extendedProperty);
            }
            Handler.EndUpdate();
        }

		///<summary>The collection of Extended Properties on the current Measure.</summary>
        [DisplayName("Extended Properties"),NoMultiselect,Category("Metadata"),Description("The collection of Extended Properties on the current Measure."),Editor(typeof(ExtendedPropertyCollectionEditor), typeof(UITypeEditor))]
        [PropertyAction(nameof(ClearExtendedProperties))]
		public ExtendedPropertyCollection ExtendedProperties { get; private set; }

		///<summary>Returns true if an ExtendedProperty with the given name exists. Otherwise false.</summary>
		[IntelliSense("Returns true if an ExtendedProperty with the given name exists. Otherwise false.")]
		public bool HasExtendedProperty(string name) {
		    return MetadataObject.ExtendedProperties.ContainsName(name);
		}
		///<summary>Gets the type of the ExtendedProperty with the given index, assuming it exists.</summary>
		public ExtendedPropertyType GetExtendedPropertyType(int index) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[index].Type;
		}
		///<summary>Gets the type of the ExtendedProperty with the given name, assuming it exists.</summary>
		public ExtendedPropertyType GetExtendedPropertyType(string name) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[name].Type;
		}
		///<summary>Gets the value of the ExtendedProperty with the given index, assuming it exists.</summary>
		public string GetExtendedProperty(int index) {
			var ep = MetadataObject.ExtendedProperties[index];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		///<summary>Gets the value of the ExtendedProperty with the given name. Returns null if no such ExtendedProperty exists.</summary>
		[IntelliSense("Gets the value of the ExtendedProperty with the given name. Returns null if no such ExtendedProperty exists.")]
		public string GetExtendedProperty(string name) {
		    if(!HasExtendedProperty(name)) return null;
			var ep = MetadataObject.ExtendedProperties[name];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		///<summary>Sets the value of the ExtendedProperty with the given index, optionally specifiying the type (string or JSON) of the ExtendedProperty.</summary>
		public void SetExtendedProperty(int index, string value, ExtendedPropertyType type) {
			SetExtendedProperty(index, value, type, true);
		}
		void IInternalExtendedPropertyObject.SetExtendedProperty(int index, string value, ExtendedPropertyType type, bool undoable) {
			SetExtendedProperty(index, value, type, undoable);
		}
		internal void SetExtendedProperty(int index, string value, ExtendedPropertyType type, bool undoable) {
			var name = MetadataObject.ExtendedProperties[index].Name;
			SetExtendedProperty(name, value, type, undoable);
		}
		///<summary>Returns a unique name for a new ExtendedProperty.</summary>
		public string GetNewExtendedPropertyName() {
			return MetadataObject.ExtendedProperties.GetNewName("New ExtendedProperty");
		}
		///<summary>Sets the value of the ExtendedProperty having the given name. If no such ExtendedProperty exists, it will be created. If value is set to null, the ExtendedProperty will be removed.</summary>
		[IntelliSense("Sets the value of the ExtendedProperty having the given name. If no such ExtendedProperty exists, it will be created. If value is set to null, the ExtendedProperty will be removed.")]
		public void SetExtendedProperty(string name, string value, ExtendedPropertyType type) {
			SetExtendedProperty(name, value, type, true);
		}
		internal void SetExtendedProperty(string name, string value, ExtendedPropertyType type, bool undoable) {
			if(name == null) name = GetNewExtendedPropertyName();

			if(value == null) {
				// Remove ExtendedProperty if set to null:
				RemoveExtendedProperty(name);
				return;
			}

			if(GetExtendedProperty(name) == value) return;
			if(undoable) {
				bool cancel = false;
				OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + value, ref undoable, ref cancel);
				if (cancel) return;
			}

			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Change existing ExtendedProperty:
				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				var ep = MetadataObject.ExtendedProperties[name];
				if (ep is TOM.JsonExtendedProperty)
					(ep as TOM.JsonExtendedProperty).Value = value;
				else 
					(ep as TOM.StringExtendedProperty).Value = value;
					
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, name + ":" + value);
			} else {
				// Add new ExtendedProperty:
				if (type == ExtendedPropertyType.Json)
					MetadataObject.ExtendedProperties.Add(new TOM.JsonExtendedProperty{ Name = name, Value = value });
				else
					MetadataObject.ExtendedProperties.Add(new TOM.StringExtendedProperty{ Name = name, Value = value });

				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, null, type));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, null, name + ":" + value);
			}
		}
		void IInternalExtendedPropertyObject.SetExtendedProperty(string name, string value, ExtendedPropertyType type, bool undoable) {
			this.SetExtendedProperty(name, value, type, undoable);
		}

		///<summary>Remove an ExtendedProperty by the given name.</summary>
		[IntelliSense("Remove an ExtendedProperty by the given name.")]
		public void RemoveExtendedProperty(string name) {
			RemoveExtendedProperty(name, true);
		}

		internal void RemoveExtendedProperty(string name, bool undoable) {
			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Get current value:
				if(undoable) {
					bool cancel = false;
					OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + GetExtendedProperty(name), ref undoable, ref cancel);
					if (cancel) return;
				}

				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				MetadataObject.ExtendedProperties.Remove(name);

				// Undo-handling:
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, null, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, null);
			}
		}
		void IInternalExtendedPropertyObject.RemoveExtendedProperty(string name, bool undoable) {
			this.RemoveExtendedProperty(name, undoable);
		}
		///<summary>Gets the number of ExtendedProperties on the current object.</summary>
		[IntelliSense("Gets the number of ExtendedProperties on the current object.")]
		public int GetExtendedPropertyCount() {
			return MetadataObject.ExtendedProperties.Count;
		}
		///<summary>Gets a collection of all ExtendedProperty names on the current object.</summary>
		[IntelliSense("Gets a collection of all ExtendedProperty names on the current object.")]
		public IEnumerable<string> GetExtendedProperties() {
			return MetadataObject.ExtendedProperties.Select(a => a.Name);
		}

		/// <summary>
///             The description of the measure, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio.
///             </summary>
		[DisplayName("Description")]
		[Category("Basic"),Description(@"The description of the measure, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio."),IntelliSense(@"The description of the measure, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio.")][Editor(typeof(System.ComponentModel.Design.MultilineStringEditor), typeof(System.Drawing.Design.UITypeEditor))]
		public string Description {
			get {
			    return MetadataObject.Description;
			}
			set {
				
				var oldValue = Description;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DESCRIPTION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.Description = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DESCRIPTION, oldValue, newValue));
				OnPropertyChanged(Properties.DESCRIPTION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeDescription() { return false; }
/// <summary>
///             Describes the type of data contained in the column. Possible values are as follows. String (2). Int64 (6). Double (8). DateTime (9). Decimal (10). Boolean (11). Binary (17). Unknown (19) A measure in an error state. Variant (20) A measure with varying data type.
///             </summary>
		[DisplayName("Data Type")]
		[Category("Metadata"),Description(@"Describes the type of data contained in the column. Possible values are as follows. String (2). Int64 (6). Double (8). DateTime (9). Decimal (10). Boolean (11). Binary (17). Unknown (19) A measure in an error state. Variant (20) A measure with varying data type."),IntelliSense(@"Describes the type of data contained in the column. Possible values are as follows. String (2). Int64 (6). Double (8). DateTime (9). Decimal (10). Boolean (11). Binary (17). Unknown (19) A measure in an error state. Variant (20) A measure with varying data type.")][TypeConverter(typeof(DataTypeEnumConverter))]
		public DataType DataType {
			get {
			    return (DataType)MetadataObject.DataType;
			}
			
		}
		private bool ShouldSerializeDataType() { return false; }
/// <summary>
///             The DAX expression that is evaluated for the calculated measure.
///             </summary>
		[DisplayName("Expression")]
		[Category("Options"),Description(@"The DAX expression that is evaluated for the calculated measure."),IntelliSense(@"The DAX expression that is evaluated for the calculated measure.")][Editor(typeof(System.ComponentModel.Design.MultilineStringEditor), typeof(System.Drawing.Design.UITypeEditor))]
		public string Expression {
			get {
			    return MetadataObject.Expression;
			}
			set {
				
				var oldValue = Expression;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.EXPRESSION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.Expression = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.EXPRESSION, oldValue, newValue));
				OnPropertyChanged(Properties.EXPRESSION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeExpression() { return false; }
/// <summary>
///             A string that specifies the format of the measure contents. For 
///             </summary>
		[DisplayName("Format String")]
		[Category("Basic"),Description(@"A string that specifies the format of the measure contents. For"),IntelliSense(@"A string that specifies the format of the measure contents. For")][TypeConverter(typeof(FormatStringConverter))]
		public string FormatString {
			get {
			    return MetadataObject.FormatString;
			}
			set {
				
				var oldValue = FormatString;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.FORMATSTRING, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.FormatString = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.FORMATSTRING, oldValue, newValue));
				OnPropertyChanged(Properties.FORMATSTRING, oldValue, newValue);
			}
		}
		private bool ShouldSerializeFormatString() { return false; }
/// <summary>
///             A boolean value that indicates whether the measure is treated as hidden by client visualization tools. True if the measure is treated as hidden by client visualization tools; otherwise false.
///             </summary>
		[DisplayName("Hidden")]
		[Category("Basic"),Description(@"A boolean value that indicates whether the measure is treated as hidden by client visualization tools. True if the measure is treated as hidden by client visualization tools; otherwise false."),IntelliSense(@"A boolean value that indicates whether the measure is treated as hidden by client visualization tools. True if the measure is treated as hidden by client visualization tools; otherwise false.")]
		public bool IsHidden {
			get {
			    return MetadataObject.IsHidden;
			}
			set {
				
				var oldValue = IsHidden;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ISHIDDEN, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.IsHidden = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.ISHIDDEN, oldValue, newValue));
				OnPropertyChanged(Properties.ISHIDDEN, oldValue, newValue);
				Handler.UpdateObject(this);
			}
		}
		private bool ShouldSerializeIsHidden() { return false; }
/// <summary>
///             Provides information on the state of the measure. Possible values and their interpretation are as follows. Ready (1) The measure is queryable and has up-to-date data. NoData (3) Not applicable to Measure. CalculationNeeded (4) Not applicable to Measure. SemanticError (5) The measure expression has a semantic error. EvaluationError (6) Not applicable to Measure. DependencyError (7) A dependency associated with this measure is in an error state (SemanticError, EvaluationError, or DependencyError). Incomplete (8) Not applicable to Measure. SyntaxError (9) The measure has a syntax error in its expression.
///             </summary>
		[DisplayName("State")]
		[Category("Metadata"),Description(@"Provides information on the state of the measure. Possible values and their interpretation are as follows. Ready (1) The measure is queryable and has up-to-date data. NoData (3) Not applicable to Measure. CalculationNeeded (4) Not applicable to Measure. SemanticError (5) The measure expression has a semantic error. EvaluationError (6) Not applicable to Measure. DependencyError (7) A dependency associated with this measure is in an error state (SemanticError, EvaluationError, or DependencyError). Incomplete (8) Not applicable to Measure. SyntaxError (9) The measure has a syntax error in its expression."),IntelliSense(@"Provides information on the state of the measure. Possible values and their interpretation are as follows. Ready (1) The measure is queryable and has up-to-date data. NoData (3) Not applicable to Measure. CalculationNeeded (4) Not applicable to Measure. SemanticError (5) The measure expression has a semantic error. EvaluationError (6) Not applicable to Measure. DependencyError (7) A dependency associated with this measure is in an error state (SemanticError, EvaluationError, or DependencyError). Incomplete (8) Not applicable to Measure. SyntaxError (9) The measure has a syntax error in its expression.")]
		public ObjectState State {
			get {
			    return (ObjectState)MetadataObject.State;
			}
			
		}
		private bool ShouldSerializeState() { return false; }
/// <summary>
///             A boolean value that indicates whether the measure is an implicit measure that is automatically created by client tools to aggregate a field. Client applications can hide measures that have this flag set.
///             </summary>
		[DisplayName("Simple Measure")]
		[Category("Options"),Description(@"A boolean value that indicates whether the measure is an implicit measure that is automatically created by client tools to aggregate a field. Client applications can hide measures that have this flag set."),IntelliSense(@"A boolean value that indicates whether the measure is an implicit measure that is automatically created by client tools to aggregate a field. Client applications can hide measures that have this flag set.")][Browsable(false)]
		public bool IsSimpleMeasure {
			get {
			    return MetadataObject.IsSimpleMeasure;
			}
			set {
				
				var oldValue = IsSimpleMeasure;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ISSIMPLEMEASURE, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.IsSimpleMeasure = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.ISSIMPLEMEASURE, oldValue, newValue));
				OnPropertyChanged(Properties.ISSIMPLEMEASURE, oldValue, newValue);
			}
		}
		private bool ShouldSerializeIsSimpleMeasure() { return false; }
/// <summary>
///             Defines the display folder for the Measure, for use by clients.
///             </summary>
		[DisplayName("Display Folder")]
		[Category("Basic"),Description(@"Defines the display folder for the Measure, for use by clients."),IntelliSense(@"Defines the display folder for the Measure, for use by clients.")][Editor(typeof(CustomDialogEditor), typeof(System.Drawing.Design.UITypeEditor))]
		public string DisplayFolder {
			get {
			    return MetadataObject.DisplayFolder;
			}
			set {
				if(value.Contains(@"\\")) throw new Exception("Display Folder names cannot be blank.");
				var oldValue = DisplayFolder;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DISPLAYFOLDER, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.DisplayFolder = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DISPLAYFOLDER, oldValue, newValue));
				OnPropertyChanged(Properties.DISPLAYFOLDER, oldValue, newValue);
				Handler.UpdateFolders(Table);
			}
		}
		private bool ShouldSerializeDisplayFolder() { return false; }
        /// <summary>
        /// Collection of localized Display Folders for the current Measure.
        /// </summary>
        [Browsable(true),DisplayName("Translated Display Folders"),Description("Shows all translated Display Folders of the current Measure."),Category("Translations, Perspectives, Security")]
	    public TranslationIndexer TranslatedDisplayFolders { private set; get; }
/// <summary>
///             Specifies the type of data contained in the measure so that you can add custom behaviors based on measure type.
///             </summary><remarks>This property is only supported when the compatibility level of the database is at 1455 or above.</remarks>
		[DisplayName("Data Category")]
		[Category("Options"),Description(@"Specifies the type of data contained in the measure so that you can add custom behaviors based on measure type."),IntelliSense(@"Specifies the type of data contained in the measure so that you can add custom behaviors based on measure type.")]
		public string DataCategory {
			get {
			    return MetadataObject.DataCategory;
			}
			set {
				
				var oldValue = DataCategory;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DATACATEGORY, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.DataCategory = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DATACATEGORY, oldValue, newValue));
				OnPropertyChanged(Properties.DATACATEGORY, oldValue, newValue);
			}
		}
		private bool ShouldSerializeDataCategory() { return false; }
/// <summary>
///             A tag that represents the lineage of the object.
///             </summary><remarks>This property is only supported when the compatibility level of the database is at 1540 or above.</remarks>
		[DisplayName("Lineage Tag")]
		[Category("Options"),Description(@"A tag that represents the lineage of the object."),IntelliSense(@"A tag that represents the lineage of the object.")]
		public string LineageTag {
			get {
			    return MetadataObject.LineageTag;
			}
			set {
				
				var oldValue = LineageTag;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.LINEAGETAG, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.LineageTag = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.LINEAGETAG, oldValue, newValue));
				OnPropertyChanged(Properties.LINEAGETAG, oldValue, newValue);
			}
		}
		private bool ShouldSerializeLineageTag() { return false; }
/// <summary>
///             A tag that represents the lineage of the source for the object.
///             </summary><remarks>This property is only supported when the compatibility level of the database is at 1550 or above.</remarks>
		[DisplayName("Source Lineage Tag")]
		[Category("Options"),Description(@"A tag that represents the lineage of the source for the object."),IntelliSense(@"A tag that represents the lineage of the source for the object.")]
		public string SourceLineageTag {
			get {
			    return MetadataObject.SourceLineageTag;
			}
			set {
				
				var oldValue = SourceLineageTag;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.SOURCELINEAGETAG, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.SourceLineageTag = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.SOURCELINEAGETAG, oldValue, newValue));
				OnPropertyChanged(Properties.SOURCELINEAGETAG, oldValue, newValue);
			}
		}
		private bool ShouldSerializeSourceLineageTag() { return false; }
		///<summary>The parent table of the current Measure.</summary>
		[Browsable(false)]
		public Table Table
		{ 
			get 
			{ 
				TabularObject t = null;
				if(MetadataObject == null || MetadataObject.Table == null) return null;
				if(!Handler.WrapperLookup.TryGetValue(MetadataObject.Table, out t)) {
				    if(!MetadataObject.Table.IsRemoved)
						t = Model.Tables[MetadataObject.Table.Name];
				}
				return t as Table;
			} 
		}

        /// <Summary>
		/// Collection of perspectives in which this Measure is visible.
		/// </Summary>
		[Browsable(true),DisplayName("Shown in Perspective"), Description("Provides an easy way to include or exclude the current Measure from the perspectives of the model."), Category("Translations, Perspectives, Security")]
        public PerspectiveMeasureIndexer InPerspective { get; private set; }
		PerspectiveIndexer ITabularPerspectiveObject.InPerspective { get { return this.InPerspective; } }
        /// <summary>
        /// Collection of localized descriptions for this Measure.
        /// </summary>
        [Browsable(true),DisplayName("Translated Descriptions"),Description("Shows all translated descriptions of the current Measure."),Category("Translations, Perspectives, Security")]
	    public TranslationIndexer TranslatedDescriptions { private set; get; }
        /// <summary>
        /// Collection of localized names for this Measure.
        /// </summary>
        [Browsable(true),DisplayName("Translated Names"),Description("Shows all translated names of the current Measure."),Category("Translations, Perspectives, Security")]
	    public TranslationIndexer TranslatedNames { private set; get; }

        /// <summary>
        /// Collection of localized synonyms for this Measure.
        /// </summary>
        [Browsable(true),DisplayName("Synonyms"),Description("Shows all translated synonyms of the current Measure."),Category("Translations, Perspectives, Security")]
	    public SynonymIndexer Synonyms { private set; get; }
		internal static Measure CreateFromMetadata(Table parent, TOM.Measure metadataObject) {
            // Generate a new LineageTag if an object with the provided lineage tag already exists:
            if(!string.IsNullOrEmpty(metadataObject.LineageTag)) {
                if (parent.Handler.CompatibilityLevel < 1540) metadataObject.LineageTag = null;
                else if (parent.MetadataObject.Measures.FindByLineageTag(metadataObject.LineageTag) != metadataObject) {
                    metadataObject.LineageTag = Guid.NewGuid().ToString();
                }
            }
			var obj = new Measure(metadataObject);
			parent.Measures.Add(obj);
			
			obj.Init();

			return obj;
		}


		/// <summary>
		/// Creates a new Measure and adds it to the parent Table.
		/// Also creates the underlying metadataobject and adds it to the TOM tree.
		/// </summary>
		public static Measure CreateNew(Table parent, string name = null)
		{
			if(!parent.Handler.PowerBIGovernance.AllowCreate(typeof(Measure))) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(Measure).GetTypeName()));
			}

			var metadataObject = new TOM.Measure();
            if(parent.Model.Database.CompatibilityLevel >= 1540) metadataObject.LineageTag = Guid.NewGuid().ToString();
			metadataObject.Name = parent.Measures.GetNewName(string.IsNullOrWhiteSpace(name) ? "New " + typeof(Measure).GetTypeName() : name);
            InitMetadata(metadataObject, parent);
            var obj = new Measure(metadataObject);

			parent.Measures.Add(obj);
			
			obj.Init();

			return obj;
		}

        static partial void InitMetadata(TOM.Measure metadataObject, Table parent);


		/// <summary>
		/// Creates an exact copy of this Measure object.
		/// </summary>
		[IntelliSense("Creates an exact copy of this Measure object.")]
		public Measure Clone(string newName = null, bool includeTranslations = true, Table newParent = null) {
			if(!Handler.PowerBIGovernance.AllowCreate(this.GetType())) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(Measure).GetTypeName()));
			}

		    Handler.BeginUpdate("Clone Measure");

			// Create a clone of the underlying metadataobject:
			var tom = MetadataObject.Clone() as TOM.Measure;

            if(Model.Database.CompatibilityLevel >= 1540 && !string.IsNullOrEmpty(LineageTag)) {
                tom.LineageTag = Guid.NewGuid().ToString();
            }

			// Assign a new, unique name:
			tom.Name = Parent.Measures.GetNewName(string.IsNullOrEmpty(newName) ? tom.Name + " copy" : newName);
				
			// Create the TOM Wrapper object, representing the metadataobject
			Measure obj = CreateFromMetadata(newParent ?? Parent, tom);

			// Copy translations, if applicable:
			if(includeTranslations) {
				obj.CopyTranslationsFrom(this);
			}
				
			// Copy perspectives:
			obj.InPerspective.CopyFrom(InPerspective);

			// TODO: Make sure that dependency trees are properly rebuilt when IDaxDependantObjects are cloned
			// FormulaFixup.BuildDependencyTree(this);
            Handler.EndUpdate();

            return obj;
		}

		TabularNamedObject IClonableObject.Clone(string newName, bool includeTranslations, TabularNamedObject newParent) 
		{
			return Clone(newName, includeTranslations);
		}

	
        internal override void RenewMetadataObject()
        {
            Handler.WrapperLookup.Remove(MetadataObject);
            var json = TOM.JsonSerializer.SerializeObject(MetadataObject, RenewMetadataOptions);
            MetadataObject = TOM.JsonSerializer.DeserializeObject<TOM.Measure>(json);
            Handler.WrapperLookup.Add(MetadataObject, this);
        }

		///<summary>The parent Table of the current Measure.</summary>
		public Table Parent { 
			get {
				return Handler.WrapperLookup[MetadataObject.Parent] as Table;
			}
		}



		/// <summary>
		/// CTOR - only called from static factory methods on the class
		/// </summary>
		Measure(TOM.Measure metadataObject) : base(metadataObject)
		{
			// Create indexers for translations:
			TranslatedNames = new TranslationIndexer(this, TOM.TranslatedProperty.Caption);
			TranslatedDescriptions = new TranslationIndexer(this, TOM.TranslatedProperty.Description);
			Synonyms = new SynonymIndexer(this);
			TranslatedDisplayFolders = new TranslationIndexer(this, TOM.TranslatedProperty.DisplayFolder);

			// Create indexer for perspectives:
			InPerspective = new PerspectiveMeasureIndexer(this);
			
			// Create indexer for annotations:
			Annotations = new AnnotationCollection(this);
			
			// Create indexer for extended properties:
			ExtendedProperties = new ExtendedPropertyCollection(this);
		}



		internal override void Undelete(ITabularObjectCollection collection, Type tomObjectType, string tomJson) {
			base.Undelete(collection, tomObjectType, tomJson);
			Reinit();
			ReapplyReferences();
		}
		internal override sealed bool Browsable(string propertyName) {
			// Allow custom overrides to hide a property regardless of its compatibility level requirements:
			if(!base.Browsable(propertyName)) return false;

			switch (propertyName) {

				// Hide properties based on compatibility requirements (inferred from TOM):
				case Properties.DATACATEGORY:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1455 : Handler.CompatibilityLevel >= 1455;
				case Properties.DETAILROWSDEFINITION:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1400 : Handler.CompatibilityLevel >= 1400;
				case Properties.EXTENDEDPROPERTIES:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1400 : Handler.CompatibilityLevel >= 1400;
				case Properties.FORMATSTRINGDEFINITION:
					return false;
				case Properties.LINEAGETAG:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1540 : Handler.CompatibilityLevel >= 1540;
				case Properties.SOURCELINEAGETAG:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1550 : Handler.CompatibilityLevel >= 1550;
				case Properties.PARENT:
					return false;
				case nameof(Synonyms):
					return Synonyms.LinguisticCultures.Any();
				
				// Hides translation properties in the grid, unless the model actually contains translations:
				case Properties.TRANSLATEDNAMES:
				case Properties.TRANSLATEDDESCRIPTIONS:
				case Properties.TRANSLATEDDISPLAYFOLDERS:
					return Model.Cultures.Any();
				
				// Hides the perspective property in the grid, unless the model actually contains perspectives:
				case Properties.INPERSPECTIVE:
					return Model.Perspectives.Any();
				
				default:
					return true;
			}
		}

    }


	/// <summary>
	/// Collection class for Measure. Provides convenient properties for setting a property on multiple objects at once.
	/// </summary>
	public sealed partial class MeasureCollection: TabularObjectCollection<Measure>
	{
		internal Table Table { get { return Parent as Table; } }
		TOM.MeasureCollection TOM_Collection;
		internal MeasureCollection(string collectionName, TOM.MeasureCollection metadataObjectCollection, Table parent) : base(collectionName, parent)
		{
			TOM_Collection = metadataObjectCollection;
		}
		internal override Type GetItemType() { return typeof(Measure); }
        internal override void TOM_Add(TOM.MetadataObject obj) { TOM_Collection.Add(obj as TOM.Measure); }
        internal override bool TOM_Contains(TOM.MetadataObject obj) { return TOM_Collection.Contains(obj as TOM.Measure); }
        internal override void TOM_Remove(TOM.MetadataObject obj) { TOM_Collection.Remove(obj as TOM.Measure); }
        internal override void TOM_Clear() { TOM_Collection.Clear(); }
        internal override bool TOM_ContainsName(string name) { return TOM_Collection.ContainsName(name); }
		internal override TOM.MetadataObject TOM_Get(int index) { return TOM_Collection[index]; }
        internal override TOM.MetadataObject TOM_Get(string name) { return TOM_Collection[name]; }
        internal override TOM.MetadataObject TOM_Find(string name) { return TOM_Collection.Find(name); }
        internal override int IndexOf(TOM.MetadataObject obj) { return TOM_Collection.IndexOf(obj as TOM.Measure); }
        /// <summary>The number of items in this collection.</summary>
		public override int Count { get { return TOM_Collection.Count; } }
		/// <summary>Returns an enumerator that iterates through the collection.</summary>
        public override IEnumerator<Measure> GetEnumerator() { return TOM_Collection.Select(h => Handler.WrapperLookup[h]).OfType<Measure>().GetEnumerator(); }
		internal override void Reinit() {
			var ixOffset = 0;
			for(int i = 0; i < Count; i++) {
				var metadataObj = TOM_Get(i) as TOM.Measure;
				var item = Handler.WrapperLookup.TryGetValue(metadataObj, out var existingItem) ? existingItem as Measure : CreateFromMetadata(metadataObj);
				Handler.WrapperLookup.Remove(item.MetadataObject);
				item.MetadataObject = Table.MetadataObject.Measures[i + ixOffset] as TOM.Measure;
				Handler.WrapperLookup.Add(item.MetadataObject, item);
				item.Collection = this;
			}
			TOM_Collection = Table.MetadataObject.Measures;
			foreach(var item in this) item.Reinit();
		}

		internal override void ReapplyReferences() {
			foreach(var item in this) item.ReapplyReferences();
		}

		private Measure CreateFromMetadata(TOM.Measure obj)
		{
			if(obj is TOM.Measure measureObj) return Measure.CreateFromMetadata(Table, measureObj);
		    return null;
		}

		/// <summary>
		/// Calling this method will populate the MeasureCollection with objects based on the MetadataObjects in the corresponding MetadataObjectCollection.
		/// </summary>
		internal override void CreateChildrenFromMetadata()
		{
			// Construct child objects (they are automatically added to the Handler's WrapperLookup dictionary):
			foreach(var obj in TOM_Collection)
			{
				CreateFromMetadata(obj);
			}
		}

		/// <summary>
		/// Sets the Description property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the Description property of all objects in the collection at once.")]
		public string Description {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("Description"));
				this.ToList().ForEach(item => { item.Description = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the Expression property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the Expression property of all objects in the collection at once.")]
		public string Expression {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("Expression"));
				this.ToList().ForEach(item => { item.Expression = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the FormatString property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the FormatString property of all objects in the collection at once.")]
		public string FormatString {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("FormatString"));
				this.ToList().ForEach(item => { item.FormatString = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the IsHidden property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the IsHidden property of all objects in the collection at once.")]
		public bool IsHidden {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("IsHidden"));
				this.ToList().ForEach(item => { item.IsHidden = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the IsSimpleMeasure property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the IsSimpleMeasure property of all objects in the collection at once.")]
		public bool IsSimpleMeasure {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("IsSimpleMeasure"));
				this.ToList().ForEach(item => { item.IsSimpleMeasure = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the DisplayFolder property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the DisplayFolder property of all objects in the collection at once.")]
		public string DisplayFolder {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("DisplayFolder"));
				this.ToList().ForEach(item => { item.DisplayFolder = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the DataCategory property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the DataCategory property of all objects in the collection at once.")]
		public string DataCategory {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("DataCategory"));
				this.ToList().ForEach(item => { item.DataCategory = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the SourceLineageTag property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the SourceLineageTag property of all objects in the collection at once.")]
		public string SourceLineageTag {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("SourceLineageTag"));
				this.ToList().ForEach(item => { item.SourceLineageTag = value; });
				Handler.UndoManager.EndBatch();
			}
		}
	}
  
	/// <summary>
///             A Tabular model created at compatibility level 1200 or above.
///             </summary>
	[TypeConverter(typeof(DynamicPropertyConverter))]
	public sealed partial class Model: TabularNamedObject
			, IDescriptionObject
			, IInternalAnnotationObject
			, IInternalExtendedPropertyObject
			, IInternalTranslatableObject
	{
	    internal new TOM.Model MetadataObject 
		{ 
			get 
			{ 
				return base.MetadataObject as TOM.Model; 
		    } 
			set 
			{ 
				base.MetadataObject = value; 
			}
		}

/// <summary> 
///             Returns the status of local changes made to the model, which haven't been saved to the server.  
///             <para>If the model is not connected, this value is always <b>False</b>.</para></summary>
		[DisplayName("Has Local Changes")]
		[Category("Options"),Description(@"Returns the status of local changes made to the model, which haven't been saved to the server.  
            <para>If the model is not connected, this value is always <b>False</b>.</para>"),IntelliSense(@"Returns the status of local changes made to the model, which haven't been saved to the server.  
            <para>If the model is not connected, this value is always <b>False</b>.</para>")]
		public bool HasLocalChanges {
			get {
			    return MetadataObject.HasLocalChanges;
			}
			
		}
		private bool ShouldSerializeHasLocalChanges() { return false; }
        private bool CanClearAnnotations() => GetAnnotationsCount() > 0;
        ///<summary>Removes all annotations from this object.</summary>
        [IntelliSense("Removes all annotations from this object.")]
        public void ClearAnnotations()
        {
            Handler.BeginUpdate("Clear annotations");
            foreach(var annotation in GetAnnotations().ToList()) {
                RemoveAnnotation(annotation);
            }
            Handler.EndUpdate();
        }

		///<summary>The collection of Annotations on the current Model.</summary>
        [Browsable(true),NoMultiselect,Category("Metadata"),Description("The collection of Annotations on the current Model."),Editor(typeof(AnnotationCollectionEditor), typeof(UITypeEditor))]
        [PropertyAction(nameof(ClearAnnotations))]
		public AnnotationCollection Annotations { get; private set; }
		///<summary>Gets the value of the annotation with the given index, assuming it exists.</summary>
		[IntelliSense("Gets the value of the annotation with the given index, assuming it exists.")]
		public string GetAnnotation(int index) {
			return MetadataObject.Annotations[index].Value;
		}
		///<summary>Returns true if an annotation with the given name exists. Otherwise false.</summary>
		[IntelliSense("Returns true if an annotation with the given name exists. Otherwise false.")]
		public bool HasAnnotation(string name) {
		    return MetadataObject.Annotations.ContainsName(name);
		}
		///<summary>Gets the value of the annotation with the given name. Returns null if no such annotation exists.</summary>
		[IntelliSense("Gets the value of the annotation with the given name. Returns null if no such annotation exists.")]
		public string GetAnnotation(string name) {
		    return HasAnnotation(name) ? MetadataObject.Annotations[name].Value : null;
		}
		///<summary>Sets the value of the annotation with the given index, assuming it exists.</summary>
		[IntelliSense("Sets the value of the annotation with the given index, assuming it exists.")]
		public void SetAnnotation(int index, string value) {
		    SetAnnotation(index, value, true);
		}
		internal void SetAnnotation(int index, string value, bool undoable) {
		    var name = MetadataObject.Annotations[index].Name;
			SetAnnotation(name, value, undoable);
		}
		void IInternalAnnotationObject.SetAnnotation(int index, string value, bool undoable) {
			SetAnnotation(index, value, undoable);
		}
		///<summary>Returns a unique name for a new annotation.</summary>
		public string GetNewAnnotationName() {
			return MetadataObject.Annotations.GetNewName("New Annotation");
		}
		///<summary>Sets the value of the annotation having the given name. If no such annotation exists, it will be created. If value is set to null, the annotation will be removed.</summary>
		[IntelliSense("Sets the value of the annotation having the given name. If no such annotation exists, it will be created. If value is set to null, the annotation will be removed.")]
		public void SetAnnotation(string name, string value) {
		    SetAnnotation(name, value, true);
		}
		internal void SetAnnotation(string name, string value, bool undoable) {
			if(name == null) name = GetNewAnnotationName();

			if(value == null) {
				// Remove annotation if set to null:
				RemoveAnnotation(name, undoable);
				return;
			}

			if(undoable) {
 				if(GetAnnotation(name) == value) return;
				bool undoable2 = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + value, ref undoable2, ref cancel);
				if (cancel) return;
			}

			if(MetadataObject.Annotations.Contains(name)) {
				// Change existing annotation:

				var oldValue = GetAnnotation(name);
				MetadataObject.Annotations[name].Value = value;
				if (undoable) {
					Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, oldValue));
					OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, name + ":" + value);
				}
			} else {
				// Add new annotation:

				MetadataObject.Annotations.Add(new TOM.Annotation{ Name = name, Value = value });
				if (undoable) {
					Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, null));
					OnPropertyChanged(Properties.ANNOTATIONS, null, name + ":" + value);
				}
			}
		}
		void IInternalAnnotationObject.SetAnnotation(string name, string value, bool undoable) {
			this.SetAnnotation(name, value, undoable);
		}
		///<summary>Remove an annotation by the given name.</summary>
		[IntelliSense("Remove an annotation by the given name.")]
		public void RemoveAnnotation(string name) {
		    RemoveAnnotation(name, true);
		}
		internal void RemoveAnnotation(string name, bool undoable) {
			if(MetadataObject.Annotations.Contains(name)) {
				if(undoable) 
				{
				    bool undoable2 = true;
				    bool cancel = false;
				    OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + GetAnnotation(name), ref undoable2, ref cancel);
				    if (cancel) return;
				}

			    var oldValue = MetadataObject.Annotations[name].Value;
				MetadataObject.Annotations.Remove(name);

				if (undoable) 
				{
					Handler.UndoManager.Add(new UndoAnnotationAction(this, name, null, oldValue));
					OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, null);
			    }
			}
		}
		void IInternalAnnotationObject.RemoveAnnotation(string name, bool undoable) {
			this.RemoveAnnotation(name, undoable);
		}
		///<summary>Gets the number of annotations on the current Model.</summary>
		[IntelliSense("Gets the number of annotations on the current Model.")]
		public int GetAnnotationsCount() {
			return MetadataObject.Annotations.Count;
		}
		///<summary>Gets a collection of all annotation names on the current Model.</summary>
		[IntelliSense("Gets a collection of all annotation names on the current Model.")]
		public IEnumerable<string> GetAnnotations() {
			return MetadataObject.Annotations.Select(a => a.Name);
		}

		        private bool CanClearExtendedProperties() => GetExtendedPropertyCount() > 0;
        ///<summary>Removes all Extended Properties from this object.</summary>
        [IntelliSense("Removes all Extended Properties from this object.")]
        public void ClearExtendedProperties()
        {
            Handler.BeginUpdate("Clear extended properties");
            foreach(var extendedProperty in GetExtendedProperties().ToList()) {
                RemoveExtendedProperty(extendedProperty);
            }
            Handler.EndUpdate();
        }

		///<summary>The collection of Extended Properties on the current Model.</summary>
        [DisplayName("Extended Properties"),NoMultiselect,Category("Metadata"),Description("The collection of Extended Properties on the current Model."),Editor(typeof(ExtendedPropertyCollectionEditor), typeof(UITypeEditor))]
        [PropertyAction(nameof(ClearExtendedProperties))]
		public ExtendedPropertyCollection ExtendedProperties { get; private set; }

		///<summary>Returns true if an ExtendedProperty with the given name exists. Otherwise false.</summary>
		[IntelliSense("Returns true if an ExtendedProperty with the given name exists. Otherwise false.")]
		public bool HasExtendedProperty(string name) {
		    return MetadataObject.ExtendedProperties.ContainsName(name);
		}
		///<summary>Gets the type of the ExtendedProperty with the given index, assuming it exists.</summary>
		public ExtendedPropertyType GetExtendedPropertyType(int index) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[index].Type;
		}
		///<summary>Gets the type of the ExtendedProperty with the given name, assuming it exists.</summary>
		public ExtendedPropertyType GetExtendedPropertyType(string name) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[name].Type;
		}
		///<summary>Gets the value of the ExtendedProperty with the given index, assuming it exists.</summary>
		public string GetExtendedProperty(int index) {
			var ep = MetadataObject.ExtendedProperties[index];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		///<summary>Gets the value of the ExtendedProperty with the given name. Returns null if no such ExtendedProperty exists.</summary>
		[IntelliSense("Gets the value of the ExtendedProperty with the given name. Returns null if no such ExtendedProperty exists.")]
		public string GetExtendedProperty(string name) {
		    if(!HasExtendedProperty(name)) return null;
			var ep = MetadataObject.ExtendedProperties[name];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		///<summary>Sets the value of the ExtendedProperty with the given index, optionally specifiying the type (string or JSON) of the ExtendedProperty.</summary>
		public void SetExtendedProperty(int index, string value, ExtendedPropertyType type) {
			SetExtendedProperty(index, value, type, true);
		}
		void IInternalExtendedPropertyObject.SetExtendedProperty(int index, string value, ExtendedPropertyType type, bool undoable) {
			SetExtendedProperty(index, value, type, undoable);
		}
		internal void SetExtendedProperty(int index, string value, ExtendedPropertyType type, bool undoable) {
			var name = MetadataObject.ExtendedProperties[index].Name;
			SetExtendedProperty(name, value, type, undoable);
		}
		///<summary>Returns a unique name for a new ExtendedProperty.</summary>
		public string GetNewExtendedPropertyName() {
			return MetadataObject.ExtendedProperties.GetNewName("New ExtendedProperty");
		}
		///<summary>Sets the value of the ExtendedProperty having the given name. If no such ExtendedProperty exists, it will be created. If value is set to null, the ExtendedProperty will be removed.</summary>
		[IntelliSense("Sets the value of the ExtendedProperty having the given name. If no such ExtendedProperty exists, it will be created. If value is set to null, the ExtendedProperty will be removed.")]
		public void SetExtendedProperty(string name, string value, ExtendedPropertyType type) {
			SetExtendedProperty(name, value, type, true);
		}
		internal void SetExtendedProperty(string name, string value, ExtendedPropertyType type, bool undoable) {
			if(name == null) name = GetNewExtendedPropertyName();

			if(value == null) {
				// Remove ExtendedProperty if set to null:
				RemoveExtendedProperty(name);
				return;
			}

			if(GetExtendedProperty(name) == value) return;
			if(undoable) {
				bool cancel = false;
				OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + value, ref undoable, ref cancel);
				if (cancel) return;
			}

			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Change existing ExtendedProperty:
				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				var ep = MetadataObject.ExtendedProperties[name];
				if (ep is TOM.JsonExtendedProperty)
					(ep as TOM.JsonExtendedProperty).Value = value;
				else 
					(ep as TOM.StringExtendedProperty).Value = value;
					
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, name + ":" + value);
			} else {
				// Add new ExtendedProperty:
				if (type == ExtendedPropertyType.Json)
					MetadataObject.ExtendedProperties.Add(new TOM.JsonExtendedProperty{ Name = name, Value = value });
				else
					MetadataObject.ExtendedProperties.Add(new TOM.StringExtendedProperty{ Name = name, Value = value });

				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, null, type));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, null, name + ":" + value);
			}
		}
		void IInternalExtendedPropertyObject.SetExtendedProperty(string name, string value, ExtendedPropertyType type, bool undoable) {
			this.SetExtendedProperty(name, value, type, undoable);
		}

		///<summary>Remove an ExtendedProperty by the given name.</summary>
		[IntelliSense("Remove an ExtendedProperty by the given name.")]
		public void RemoveExtendedProperty(string name) {
			RemoveExtendedProperty(name, true);
		}

		internal void RemoveExtendedProperty(string name, bool undoable) {
			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Get current value:
				if(undoable) {
					bool cancel = false;
					OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + GetExtendedProperty(name), ref undoable, ref cancel);
					if (cancel) return;
				}

				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				MetadataObject.ExtendedProperties.Remove(name);

				// Undo-handling:
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, null, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, null);
			}
		}
		void IInternalExtendedPropertyObject.RemoveExtendedProperty(string name, bool undoable) {
			this.RemoveExtendedProperty(name, undoable);
		}
		///<summary>Gets the number of ExtendedProperties on the current object.</summary>
		[IntelliSense("Gets the number of ExtendedProperties on the current object.")]
		public int GetExtendedPropertyCount() {
			return MetadataObject.ExtendedProperties.Count;
		}
		///<summary>Gets a collection of all ExtendedProperty names on the current object.</summary>
		[IntelliSense("Gets a collection of all ExtendedProperty names on the current object.")]
		public IEnumerable<string> GetExtendedProperties() {
			return MetadataObject.ExtendedProperties.Select(a => a.Name);
		}

		/// <summary>
///             The description of the model, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio.
///             </summary>
		[DisplayName("Description")]
		[Category("Basic"),Description(@"The description of the model, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio."),IntelliSense(@"The description of the model, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio.")][Editor(typeof(System.ComponentModel.Design.MultilineStringEditor), typeof(System.Drawing.Design.UITypeEditor))]
		public string Description {
			get {
			    return MetadataObject.Description;
			}
			set {
				
				var oldValue = Description;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DESCRIPTION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.Description = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DESCRIPTION, oldValue, newValue));
				OnPropertyChanged(Properties.DESCRIPTION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeDescription() { return false; }
/// <summary>
///             The location on disk to place the model.
///             </summary>
		[DisplayName("Storage Location")]
		[Category("Options"),Description(@"The location on disk to place the model."),IntelliSense(@"The location on disk to place the model.")]
		public string StorageLocation {
			get {
			    return MetadataObject.StorageLocation;
			}
			set {
				
				var oldValue = StorageLocation;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.STORAGELOCATION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.StorageLocation = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.STORAGELOCATION, oldValue, newValue));
				OnPropertyChanged(Properties.STORAGELOCATION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeStorageLocation() { return false; }
/// <summary>
///             The default method for making data available in the partition.
///             </summary>
		[DisplayName("Default Mode")]
		[Category("Options"),Description(@"The default method for making data available in the partition."),IntelliSense(@"The default method for making data available in the partition.")]
		public ModeType DefaultMode {
			get {
			    return (ModeType)MetadataObject.DefaultMode;
			}
			set {
				
				var oldValue = DefaultMode;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DEFAULTMODE, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.DefaultMode = (TOM.ModeType)newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DEFAULTMODE, oldValue, newValue));
				OnPropertyChanged(Properties.DEFAULTMODE, oldValue, newValue);
			}
		}
		private bool ShouldSerializeDefaultMode() { return false; }
/// <summary>
///             Used by partitions in the model to determine the type of query that retrieves data. A Full dataview retrieves an unfiltered rowset, used for in-memory models and deployed DirectQuery models. A Sample data view is a subset of data used during DirectQuery model design.
///             </summary>
		[DisplayName("Default Data View")]
		[Category("Options"),Description(@"Used by partitions in the model to determine the type of query that retrieves data. A Full dataview retrieves an unfiltered rowset, used for in-memory models and deployed DirectQuery models. A Sample data view is a subset of data used during DirectQuery model design."),IntelliSense(@"Used by partitions in the model to determine the type of query that retrieves data. A Full dataview retrieves an unfiltered rowset, used for in-memory models and deployed DirectQuery models. A Sample data view is a subset of data used during DirectQuery model design.")]
		public DataViewType DefaultDataView {
			get {
			    return (DataViewType)MetadataObject.DefaultDataView;
			}
			set {
				
				var oldValue = DefaultDataView;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DEFAULTDATAVIEW, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.DefaultDataView = (TOM.DataViewType)newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DEFAULTDATAVIEW, oldValue, newValue));
				OnPropertyChanged(Properties.DEFAULTDATAVIEW, oldValue, newValue);
			}
		}
		private bool ShouldSerializeDefaultDataView() { return false; }
/// <summary>
///             The name of the Culture used for formatting. Once it's used by a child object, this value can't be changed.
///             </summary>
		[DisplayName("Culture")]
		[Category("Options"),Description(@"The name of the Culture used for formatting. Once it's used by a child object, this value can't be changed."),IntelliSense(@"The name of the Culture used for formatting. Once it's used by a child object, this value can't be changed.")][TypeConverter(typeof(CultureConverter))]
		public string Culture {
			get {
			    return MetadataObject.Culture;
			}
			set {
				
				var oldValue = Culture;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.CULTURE, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.Culture = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.CULTURE, oldValue, newValue));
				OnPropertyChanged(Properties.CULTURE, oldValue, newValue);
			}
		}
		private bool ShouldSerializeCulture() { return false; }
/// <summary>
///             The collation sequence. Analysis Services uses Windows collations.
///             </summary>
		[DisplayName("Collation")]
		[Category("Options"),Description(@"The collation sequence. Analysis Services uses Windows collations."),IntelliSense(@"The collation sequence. Analysis Services uses Windows collations.")]
		public string Collation {
			get {
			    return MetadataObject.Collation;
			}
			set {
				
				var oldValue = Collation;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.COLLATION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.Collation = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.COLLATION, oldValue, newValue));
				OnPropertyChanged(Properties.COLLATION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeCollation() { return false; }
/// <summary>
///             Used by PBIX data source format conversion.
///             </summary><remarks>This property is only supported when the compatibility level of the database is at 1450 or above.</remarks>
		[DisplayName("Default Power BI Data Source Version")]
		[Category("Options"),Description(@"Used by PBIX data source format conversion."),IntelliSense(@"Used by PBIX data source format conversion.")]
		public PowerBIDataSourceVersion DefaultPowerBIDataSourceVersion {
			get {
			    return (PowerBIDataSourceVersion)MetadataObject.DefaultPowerBIDataSourceVersion;
			}
			set {
				
				var oldValue = DefaultPowerBIDataSourceVersion;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DEFAULTPOWERBIDATASOURCEVERSION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.DefaultPowerBIDataSourceVersion = (TOM.PowerBIDataSourceVersion)newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DEFAULTPOWERBIDATASOURCEVERSION, oldValue, newValue));
				OnPropertyChanged(Properties.DEFAULTPOWERBIDATASOURCEVERSION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeDefaultPowerBIDataSourceVersion() { return false; }
/// <summary>
///             Determines whether measures can have the same names as any column in the model.
///             </summary><remarks>This property is only supported when the compatibility level of the database is at 1465 or above.</remarks>
		[DisplayName("Force Unique Names")]
		[Category("Options"),Description(@"Determines whether measures can have the same names as any column in the model."),IntelliSense(@"Determines whether measures can have the same names as any column in the model.")]
		public bool ForceUniqueNames {
			get {
			    return MetadataObject.ForceUniqueNames;
			}
			set {
				
				var oldValue = ForceUniqueNames;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.FORCEUNIQUENAMES, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.ForceUniqueNames = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.FORCEUNIQUENAMES, oldValue, newValue));
				OnPropertyChanged(Properties.FORCEUNIQUENAMES, oldValue, newValue);
			}
		}
		private bool ShouldSerializeForceUniqueNames() { return false; }
/// <summary>
///             Determines whether to discourage the implicit measures.
///             </summary><remarks>This property is only supported when the compatibility level of the database is at 1470 or above.</remarks>
		[DisplayName("Discourage Implicit Measures")]
		[Category("Options"),Description(@"Determines whether to discourage the implicit measures."),IntelliSense(@"Determines whether to discourage the implicit measures.")]
		public bool DiscourageImplicitMeasures {
			get {
			    return MetadataObject.DiscourageImplicitMeasures;
			}
			set {
				
				var oldValue = DiscourageImplicitMeasures;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DISCOURAGEIMPLICITMEASURES, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.DiscourageImplicitMeasures = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DISCOURAGEIMPLICITMEASURES, oldValue, newValue));
				OnPropertyChanged(Properties.DISCOURAGEIMPLICITMEASURES, oldValue, newValue);
			}
		}
		private bool ShouldSerializeDiscourageImplicitMeasures() { return false; }
/// <summary>
///             Determines whether to discourage the report measures.
///             </summary><remarks>This property is only supported when the compatibility level of the database is at Internal or above.</remarks>
		[DisplayName("Discourage Report Measures")]
		[Category("Options"),Description(@"Determines whether to discourage the report measures."),IntelliSense(@"Determines whether to discourage the report measures.")]
		public bool DiscourageReportMeasures {
			get {
			    return MetadataObject.DiscourageReportMeasures;
			}
			set {
				
				var oldValue = DiscourageReportMeasures;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DISCOURAGEREPORTMEASURES, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.DiscourageReportMeasures = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DISCOURAGEREPORTMEASURES, oldValue, newValue));
				OnPropertyChanged(Properties.DISCOURAGEREPORTMEASURES, oldValue, newValue);
			}
		}
		private bool ShouldSerializeDiscourageReportMeasures() { return false; }
/// <summary>
///             DataSourceDefaultMaxConnections will be used for connections to a data source if MaxConnections is set to -1 on the data source object or if there is no corresponding data source object for the data source.
///             </summary><remarks>This property is only supported when the compatibility level of the database is at 1510 or above.</remarks>
		[DisplayName("Data Source Default Max Connections")]
		[Category("Options"),Description(@"DataSourceDefaultMaxConnections will be used for connections to a data source if MaxConnections is set to -1 on the data source object or if there is no corresponding data source object for the data source."),IntelliSense(@"DataSourceDefaultMaxConnections will be used for connections to a data source if MaxConnections is set to -1 on the data source object or if there is no corresponding data source object for the data source.")]
		public int DataSourceDefaultMaxConnections {
			get {
			    return MetadataObject.DataSourceDefaultMaxConnections;
			}
			set {
				
				var oldValue = DataSourceDefaultMaxConnections;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DATASOURCEDEFAULTMAXCONNECTIONS, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.DataSourceDefaultMaxConnections = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DATASOURCEDEFAULTMAXCONNECTIONS, oldValue, newValue));
				OnPropertyChanged(Properties.DATASOURCEDEFAULTMAXCONNECTIONS, oldValue, newValue);
			}
		}
		private bool ShouldSerializeDataSourceDefaultMaxConnections() { return false; }
/// <summary>
///             The name of the Culture used for formatting during refresh through Mashup.
///             </summary><remarks>This property is only supported when the compatibility level of the database is at 1520 or above.</remarks>
		[DisplayName("Source Query Culture")]
		[Category("Options"),Description(@"The name of the Culture used for formatting during refresh through Mashup."),IntelliSense(@"The name of the Culture used for formatting during refresh through Mashup.")]
		public string SourceQueryCulture {
			get {
			    return MetadataObject.SourceQueryCulture;
			}
			set {
				
				var oldValue = SourceQueryCulture;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.SOURCEQUERYCULTURE, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.SourceQueryCulture = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.SOURCEQUERYCULTURE, oldValue, newValue));
				OnPropertyChanged(Properties.SOURCEQUERYCULTURE, oldValue, newValue);
			}
		}
		private bool ShouldSerializeSourceQueryCulture() { return false; }
/// <summary>
///             The string that has M attributes.
///             </summary><remarks>This property is only supported when the compatibility level of the database is at 1535 or above.</remarks>
		[DisplayName("M Attributes")]
		[Category("Options"),Description(@"The string that has M attributes."),IntelliSense(@"The string that has M attributes.")]
		public string MAttributes {
			get {
			    return MetadataObject.MAttributes;
			}
			set {
				
				var oldValue = MAttributes;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.MATTRIBUTES, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.MAttributes = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.MATTRIBUTES, oldValue, newValue));
				OnPropertyChanged(Properties.MATTRIBUTES, oldValue, newValue);
			}
		}
		private bool ShouldSerializeMAttributes() { return false; }
/// <summary>
///             Determines whether to discourage composite models.
///             </summary><remarks>This property is only supported when the compatibility level of the database is at 1560 or above.</remarks>
		[DisplayName("Discourage Composite Models")]
		[Category("Options"),Description(@"Determines whether to discourage composite models."),IntelliSense(@"Determines whether to discourage composite models.")]
		public bool DiscourageCompositeModels {
			get {
			    return MetadataObject.DiscourageCompositeModels;
			}
			set {
				
				var oldValue = DiscourageCompositeModels;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DISCOURAGECOMPOSITEMODELS, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.DiscourageCompositeModels = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DISCOURAGECOMPOSITEMODELS, oldValue, newValue));
				OnPropertyChanged(Properties.DISCOURAGECOMPOSITEMODELS, oldValue, newValue);
			}
		}
		private bool ShouldSerializeDiscourageCompositeModels() { return false; }
/// <summary>
///             A reference to a default measure.
///             </summary><remarks>This property is only supported when the compatibility level of the database is at 1400 or above.</remarks>
		[DisplayName("Default Measure")]
		[Category("Options"),Description(@"A reference to a default measure."),IntelliSense(@"A reference to a default measure.")]
		public Measure DefaultMeasure {
			get {
				if (MetadataObject.DefaultMeasure == null) return null;
			    return Handler.WrapperLookup[MetadataObject.DefaultMeasure] as Measure;
            }
			set {
				
				var oldValue = DefaultMeasure;
				var newValue = value;
				if (oldValue?.MetadataObject == newValue?.MetadataObject) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DEFAULTMEASURE, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.DefaultMeasure = value?.MetadataObject;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DEFAULTMEASURE, oldValue, newValue));
				OnPropertyChanged(Properties.DEFAULTMEASURE, oldValue, newValue);
			}
		}
		private bool ShouldSerializeDefaultMeasure() { return false; }

        /// <summary>
        /// Collection of localized descriptions for this Model.
        /// </summary>
        [Browsable(true),DisplayName("Translated Descriptions"),Description("Shows all translated descriptions of the current Model."),Category("Translations, Perspectives, Security")]
	    public TranslationIndexer TranslatedDescriptions { private set; get; }
        /// <summary>
        /// Collection of localized names for this Model.
        /// </summary>
        [Browsable(true),DisplayName("Translated Names"),Description("Shows all translated names of the current Model."),Category("Translations, Perspectives, Security")]
	    public TranslationIndexer TranslatedNames { private set; get; }

	
        internal override void RenewMetadataObject()
        {
            Handler.WrapperLookup.Remove(MetadataObject);
            var json = TOM.JsonSerializer.SerializeObject(MetadataObject, RenewMetadataOptions);
            MetadataObject = TOM.JsonSerializer.DeserializeObject<TOM.Model>(json);
            Handler.WrapperLookup.Add(MetadataObject, this);
        }


        internal override ITabularObjectCollection GetCollectionForChild(TabularObject child)
        {
			if (child is Perspective) return Perspectives;
			if (child is Culture) return Cultures;
			if (child is DataSource) return DataSources;
			if (child is ModelRole) return Roles;
			if (child is Table) return Tables;
			if (child is Relationship) return Relationships;
			if (child is NamedExpression) return Expressions;
            return base.GetCollectionForChild(child);
        }

        /// <summary>
        /// The collection of Perspective objects on this Model.
        /// </summary>
		[DisplayName("Perspectives")]
		[Category("Translations, Perspectives, Security"),IntelliSense("The collection of Perspective objects on the current Model.")][Editor(typeof(TabularEditor.PropertyGridUI.ClonableObjectCollectionEditor<Perspective>),typeof(UITypeEditor)),TypeConverter(typeof(StringConverter))]
		public PerspectiveCollection Perspectives { get; private set; }
        /// <summary>
        /// The collection of Culture objects on this Model.
        /// </summary>
		[DisplayName("Cultures")]
		[Category("Translations, Perspectives, Security"),IntelliSense("The collection of Culture objects on the current Model.")][Editor(typeof(TabularEditor.PropertyGridUI.CultureCollectionEditor),typeof(UITypeEditor)),TypeConverter(typeof(StringConverter))]
		public CultureCollection Cultures { get; private set; }
        /// <summary>
        /// The collection of DataSource objects on this Model.
        /// </summary>
		[DisplayName("Data Sources")]
		[Category("Options"),IntelliSense("The collection of Data Source objects on the current Model.")][Browsable(false)]
		public DataSourceCollection DataSources { get; private set; }
        /// <summary>
        /// The collection of ModelRole objects on this Model.
        /// </summary>
		[DisplayName("Roles")]
		[Category("Translations, Perspectives, Security"),IntelliSense("The collection of Model Role objects on the current Model.")][Editor(typeof(TabularEditor.PropertyGridUI.ClonableObjectCollectionEditor<ModelRole>), typeof(UITypeEditor)), TypeConverter(typeof(StringConverter))]
		public ModelRoleCollection Roles { get; private set; }
        /// <summary>
        /// The collection of Table objects on this Model.
        /// </summary>
		[DisplayName("Tables")]
		[Category("Options"),IntelliSense("The collection of Table objects on the current Model.")][Browsable(false)]
		public TableCollection Tables { get; private set; }
        /// <summary>
        /// The collection of Relationship objects on this Model.
        /// </summary>
		[DisplayName("Relationships")]
		[Category("Options"),IntelliSense("The collection of Relationship objects on the current Model.")][Browsable(false)]
		public RelationshipCollection Relationships { get; private set; }
        /// <summary>
        /// The collection of NamedExpression objects on this Model.
        /// </summary>
		[DisplayName("Expressions")]
		[Category("Options"),IntelliSense("The collection of Named Expression objects on the current Model.")][Editor(typeof(TabularEditor.PropertyGridUI.ClonableObjectCollectionEditor<NamedExpression>), typeof(UITypeEditor)), TypeConverter(typeof(StringConverter))]
		public NamedExpressionCollection Expressions { get; private set; }

		/// <summary>
		/// CTOR - only called from static factory methods on the class
		/// </summary>
		Model(TOM.Model metadataObject) : base(metadataObject)
		{
			// Create indexers for translations:
			TranslatedNames = new TranslationIndexer(this, TOM.TranslatedProperty.Caption);
			TranslatedDescriptions = new TranslationIndexer(this, TOM.TranslatedProperty.Description);
			
			// Create indexer for annotations:
			Annotations = new AnnotationCollection(this);
			
			// Create indexer for extended properties:
			ExtendedProperties = new ExtendedPropertyCollection(this);
			
			// Instantiate child collections:
			Perspectives = new PerspectiveCollection(this.GetObjectPath() + ".Perspectives", MetadataObject.Perspectives, this);
			Cultures = new CultureCollection(this.GetObjectPath() + ".Cultures", MetadataObject.Cultures, this);
			DataSources = new DataSourceCollection(this.GetObjectPath() + ".DataSources", MetadataObject.DataSources, this);
			Roles = new ModelRoleCollection(this.GetObjectPath() + ".Roles", MetadataObject.Roles, this);
			Tables = new TableCollection(this.GetObjectPath() + ".Tables", MetadataObject.Tables, this);
			Relationships = new RelationshipCollection(this.GetObjectPath() + ".Relationships", MetadataObject.Relationships, this);
			Expressions = new NamedExpressionCollection(this.GetObjectPath() + ".Expressions", MetadataObject.Expressions, this);

			// Populate child collections:
			Perspectives.CreateChildrenFromMetadata();
			Cultures.CreateChildrenFromMetadata();
			DataSources.CreateChildrenFromMetadata();
			Roles.CreateChildrenFromMetadata();
			Tables.CreateChildrenFromMetadata();
			Relationships.CreateChildrenFromMetadata();
			Expressions.CreateChildrenFromMetadata();

			// Hook up event handlers on child collections:
			Perspectives.CollectionChanged += Children_CollectionChanged;
			Cultures.CollectionChanged += Children_CollectionChanged;
			DataSources.CollectionChanged += Children_CollectionChanged;
			Roles.CollectionChanged += Children_CollectionChanged;
			Tables.CollectionChanged += Children_CollectionChanged;
			Relationships.CollectionChanged += Children_CollectionChanged;
			Expressions.CollectionChanged += Children_CollectionChanged;
		}


		internal override void Reinit() {
			Perspectives.Reinit();
			Cultures.Reinit();
			DataSources.Reinit();
			Roles.Reinit();
			Tables.Reinit();
			Relationships.Reinit();
			Expressions.Reinit();
		}

		internal override void Undelete(ITabularObjectCollection collection, Type tomObjectType, string tomJson) {
			base.Undelete(collection, tomObjectType, tomJson);
			Reinit();
			ReapplyReferences();
		}
		internal override sealed bool Browsable(string propertyName) {
			// Allow custom overrides to hide a property regardless of its compatibility level requirements:
			if(!base.Browsable(propertyName)) return false;

			switch (propertyName) {

				// Hide properties based on compatibility requirements (inferred from TOM):
				case Properties.ANALYTICSAIMETADATA:
					return false;
				case Properties.AUTOMATICAGGREGATIONOPTIONS:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1564 : Handler.CompatibilityLevel >= 1564;
				case Properties.DATAACCESSOPTIONS:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1400 : Handler.CompatibilityLevel >= 1400;
				case Properties.DATASOURCEDEFAULTMAXCONNECTIONS:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1510 : Handler.CompatibilityLevel >= 1510;
				case Properties.DATASOURCEVARIABLESOVERRIDEBEHAVIOR:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1475 : Handler.CompatibilityLevel >= 1475;
				case Properties.DEFAULTMEASURE:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1400 : Handler.CompatibilityLevel >= 1400;
				case Properties.DEFAULTPOWERBIDATASOURCEVERSION:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1450 : Handler.CompatibilityLevel >= 1450;
				case Properties.DISCOURAGECOMPOSITEMODELS:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1560 : Handler.CompatibilityLevel >= 1560;
				case Properties.DISCOURAGEIMPLICITMEASURES:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1470 : Handler.CompatibilityLevel >= 1470;
				case Properties.DISCOURAGEREPORTMEASURES:
					return false;
				case Properties.EXPRESSIONS:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1400 : Handler.CompatibilityLevel >= 1400;
				case Properties.EXTENDEDPROPERTIES:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1400 : Handler.CompatibilityLevel >= 1400;
				case Properties.FORCEUNIQUENAMES:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1465 : Handler.CompatibilityLevel >= 1465;
				case Properties.MATTRIBUTES:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1535 : Handler.CompatibilityLevel >= 1535;
				case Properties.QUERYGROUPS:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1480 : Handler.CompatibilityLevel >= 1480;
				case Properties.SOURCEQUERYCULTURE:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1520 : Handler.CompatibilityLevel >= 1520;
				
				// Hides translation properties in the grid, unless the model actually contains translations:
				case Properties.TRANSLATEDNAMES:
				case Properties.TRANSLATEDDESCRIPTIONS:
					return Model.Cultures.Any();
				
				default:
					return true;
			}
		}

    }

  
	/// <summary>
///             Defines a set of user principals for whom security rules are applied. It is a child of a Model object.
///             </summary>
	[TypeConverter(typeof(DynamicPropertyConverter))]
	public sealed partial class ModelRole: TabularNamedObject
			, IDescriptionObject
			, IInternalAnnotationObject
			, IInternalExtendedPropertyObject
			, IClonableObject
	{
	    internal new TOM.ModelRole MetadataObject 
		{ 
			get 
			{ 
				return base.MetadataObject as TOM.ModelRole; 
		    } 
			set 
			{ 
				base.MetadataObject = value; 
			}
		}

        private bool CanClearAnnotations() => GetAnnotationsCount() > 0;
        ///<summary>Removes all annotations from this object.</summary>
        [IntelliSense("Removes all annotations from this object.")]
        public void ClearAnnotations()
        {
            Handler.BeginUpdate("Clear annotations");
            foreach(var annotation in GetAnnotations().ToList()) {
                RemoveAnnotation(annotation);
            }
            Handler.EndUpdate();
        }

		///<summary>The collection of Annotations on the current Model Role.</summary>
        [Browsable(true),NoMultiselect,Category("Metadata"),Description("The collection of Annotations on the current Model Role."),Editor(typeof(AnnotationCollectionEditor), typeof(UITypeEditor))]
        [PropertyAction(nameof(ClearAnnotations))]
		public AnnotationCollection Annotations { get; private set; }
		///<summary>Gets the value of the annotation with the given index, assuming it exists.</summary>
		[IntelliSense("Gets the value of the annotation with the given index, assuming it exists.")]
		public string GetAnnotation(int index) {
			return MetadataObject.Annotations[index].Value;
		}
		///<summary>Returns true if an annotation with the given name exists. Otherwise false.</summary>
		[IntelliSense("Returns true if an annotation with the given name exists. Otherwise false.")]
		public bool HasAnnotation(string name) {
		    return MetadataObject.Annotations.ContainsName(name);
		}
		///<summary>Gets the value of the annotation with the given name. Returns null if no such annotation exists.</summary>
		[IntelliSense("Gets the value of the annotation with the given name. Returns null if no such annotation exists.")]
		public string GetAnnotation(string name) {
		    return HasAnnotation(name) ? MetadataObject.Annotations[name].Value : null;
		}
		///<summary>Sets the value of the annotation with the given index, assuming it exists.</summary>
		[IntelliSense("Sets the value of the annotation with the given index, assuming it exists.")]
		public void SetAnnotation(int index, string value) {
		    SetAnnotation(index, value, true);
		}
		internal void SetAnnotation(int index, string value, bool undoable) {
		    var name = MetadataObject.Annotations[index].Name;
			SetAnnotation(name, value, undoable);
		}
		void IInternalAnnotationObject.SetAnnotation(int index, string value, bool undoable) {
			SetAnnotation(index, value, undoable);
		}
		///<summary>Returns a unique name for a new annotation.</summary>
		public string GetNewAnnotationName() {
			return MetadataObject.Annotations.GetNewName("New Annotation");
		}
		///<summary>Sets the value of the annotation having the given name. If no such annotation exists, it will be created. If value is set to null, the annotation will be removed.</summary>
		[IntelliSense("Sets the value of the annotation having the given name. If no such annotation exists, it will be created. If value is set to null, the annotation will be removed.")]
		public void SetAnnotation(string name, string value) {
		    SetAnnotation(name, value, true);
		}
		internal void SetAnnotation(string name, string value, bool undoable) {
			if(name == null) name = GetNewAnnotationName();

			if(value == null) {
				// Remove annotation if set to null:
				RemoveAnnotation(name, undoable);
				return;
			}

			if(undoable) {
 				if(GetAnnotation(name) == value) return;
				bool undoable2 = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + value, ref undoable2, ref cancel);
				if (cancel) return;
			}

			if(MetadataObject.Annotations.Contains(name)) {
				// Change existing annotation:

				var oldValue = GetAnnotation(name);
				MetadataObject.Annotations[name].Value = value;
				if (undoable) {
					Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, oldValue));
					OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, name + ":" + value);
				}
			} else {
				// Add new annotation:

				MetadataObject.Annotations.Add(new TOM.Annotation{ Name = name, Value = value });
				if (undoable) {
					Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, null));
					OnPropertyChanged(Properties.ANNOTATIONS, null, name + ":" + value);
				}
			}
		}
		void IInternalAnnotationObject.SetAnnotation(string name, string value, bool undoable) {
			this.SetAnnotation(name, value, undoable);
		}
		///<summary>Remove an annotation by the given name.</summary>
		[IntelliSense("Remove an annotation by the given name.")]
		public void RemoveAnnotation(string name) {
		    RemoveAnnotation(name, true);
		}
		internal void RemoveAnnotation(string name, bool undoable) {
			if(MetadataObject.Annotations.Contains(name)) {
				if(undoable) 
				{
				    bool undoable2 = true;
				    bool cancel = false;
				    OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + GetAnnotation(name), ref undoable2, ref cancel);
				    if (cancel) return;
				}

			    var oldValue = MetadataObject.Annotations[name].Value;
				MetadataObject.Annotations.Remove(name);

				if (undoable) 
				{
					Handler.UndoManager.Add(new UndoAnnotationAction(this, name, null, oldValue));
					OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, null);
			    }
			}
		}
		void IInternalAnnotationObject.RemoveAnnotation(string name, bool undoable) {
			this.RemoveAnnotation(name, undoable);
		}
		///<summary>Gets the number of annotations on the current Model Role.</summary>
		[IntelliSense("Gets the number of annotations on the current Model Role.")]
		public int GetAnnotationsCount() {
			return MetadataObject.Annotations.Count;
		}
		///<summary>Gets a collection of all annotation names on the current Model Role.</summary>
		[IntelliSense("Gets a collection of all annotation names on the current Model Role.")]
		public IEnumerable<string> GetAnnotations() {
			return MetadataObject.Annotations.Select(a => a.Name);
		}

		        private bool CanClearExtendedProperties() => GetExtendedPropertyCount() > 0;
        ///<summary>Removes all Extended Properties from this object.</summary>
        [IntelliSense("Removes all Extended Properties from this object.")]
        public void ClearExtendedProperties()
        {
            Handler.BeginUpdate("Clear extended properties");
            foreach(var extendedProperty in GetExtendedProperties().ToList()) {
                RemoveExtendedProperty(extendedProperty);
            }
            Handler.EndUpdate();
        }

		///<summary>The collection of Extended Properties on the current Model Role.</summary>
        [DisplayName("Extended Properties"),NoMultiselect,Category("Metadata"),Description("The collection of Extended Properties on the current Model Role."),Editor(typeof(ExtendedPropertyCollectionEditor), typeof(UITypeEditor))]
        [PropertyAction(nameof(ClearExtendedProperties))]
		public ExtendedPropertyCollection ExtendedProperties { get; private set; }

		///<summary>Returns true if an ExtendedProperty with the given name exists. Otherwise false.</summary>
		[IntelliSense("Returns true if an ExtendedProperty with the given name exists. Otherwise false.")]
		public bool HasExtendedProperty(string name) {
		    return MetadataObject.ExtendedProperties.ContainsName(name);
		}
		///<summary>Gets the type of the ExtendedProperty with the given index, assuming it exists.</summary>
		public ExtendedPropertyType GetExtendedPropertyType(int index) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[index].Type;
		}
		///<summary>Gets the type of the ExtendedProperty with the given name, assuming it exists.</summary>
		public ExtendedPropertyType GetExtendedPropertyType(string name) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[name].Type;
		}
		///<summary>Gets the value of the ExtendedProperty with the given index, assuming it exists.</summary>
		public string GetExtendedProperty(int index) {
			var ep = MetadataObject.ExtendedProperties[index];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		///<summary>Gets the value of the ExtendedProperty with the given name. Returns null if no such ExtendedProperty exists.</summary>
		[IntelliSense("Gets the value of the ExtendedProperty with the given name. Returns null if no such ExtendedProperty exists.")]
		public string GetExtendedProperty(string name) {
		    if(!HasExtendedProperty(name)) return null;
			var ep = MetadataObject.ExtendedProperties[name];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		///<summary>Sets the value of the ExtendedProperty with the given index, optionally specifiying the type (string or JSON) of the ExtendedProperty.</summary>
		public void SetExtendedProperty(int index, string value, ExtendedPropertyType type) {
			SetExtendedProperty(index, value, type, true);
		}
		void IInternalExtendedPropertyObject.SetExtendedProperty(int index, string value, ExtendedPropertyType type, bool undoable) {
			SetExtendedProperty(index, value, type, undoable);
		}
		internal void SetExtendedProperty(int index, string value, ExtendedPropertyType type, bool undoable) {
			var name = MetadataObject.ExtendedProperties[index].Name;
			SetExtendedProperty(name, value, type, undoable);
		}
		///<summary>Returns a unique name for a new ExtendedProperty.</summary>
		public string GetNewExtendedPropertyName() {
			return MetadataObject.ExtendedProperties.GetNewName("New ExtendedProperty");
		}
		///<summary>Sets the value of the ExtendedProperty having the given name. If no such ExtendedProperty exists, it will be created. If value is set to null, the ExtendedProperty will be removed.</summary>
		[IntelliSense("Sets the value of the ExtendedProperty having the given name. If no such ExtendedProperty exists, it will be created. If value is set to null, the ExtendedProperty will be removed.")]
		public void SetExtendedProperty(string name, string value, ExtendedPropertyType type) {
			SetExtendedProperty(name, value, type, true);
		}
		internal void SetExtendedProperty(string name, string value, ExtendedPropertyType type, bool undoable) {
			if(name == null) name = GetNewExtendedPropertyName();

			if(value == null) {
				// Remove ExtendedProperty if set to null:
				RemoveExtendedProperty(name);
				return;
			}

			if(GetExtendedProperty(name) == value) return;
			if(undoable) {
				bool cancel = false;
				OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + value, ref undoable, ref cancel);
				if (cancel) return;
			}

			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Change existing ExtendedProperty:
				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				var ep = MetadataObject.ExtendedProperties[name];
				if (ep is TOM.JsonExtendedProperty)
					(ep as TOM.JsonExtendedProperty).Value = value;
				else 
					(ep as TOM.StringExtendedProperty).Value = value;
					
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, name + ":" + value);
			} else {
				// Add new ExtendedProperty:
				if (type == ExtendedPropertyType.Json)
					MetadataObject.ExtendedProperties.Add(new TOM.JsonExtendedProperty{ Name = name, Value = value });
				else
					MetadataObject.ExtendedProperties.Add(new TOM.StringExtendedProperty{ Name = name, Value = value });

				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, null, type));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, null, name + ":" + value);
			}
		}
		void IInternalExtendedPropertyObject.SetExtendedProperty(string name, string value, ExtendedPropertyType type, bool undoable) {
			this.SetExtendedProperty(name, value, type, undoable);
		}

		///<summary>Remove an ExtendedProperty by the given name.</summary>
		[IntelliSense("Remove an ExtendedProperty by the given name.")]
		public void RemoveExtendedProperty(string name) {
			RemoveExtendedProperty(name, true);
		}

		internal void RemoveExtendedProperty(string name, bool undoable) {
			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Get current value:
				if(undoable) {
					bool cancel = false;
					OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + GetExtendedProperty(name), ref undoable, ref cancel);
					if (cancel) return;
				}

				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				MetadataObject.ExtendedProperties.Remove(name);

				// Undo-handling:
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, null, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, null);
			}
		}
		void IInternalExtendedPropertyObject.RemoveExtendedProperty(string name, bool undoable) {
			this.RemoveExtendedProperty(name, undoable);
		}
		///<summary>Gets the number of ExtendedProperties on the current object.</summary>
		[IntelliSense("Gets the number of ExtendedProperties on the current object.")]
		public int GetExtendedPropertyCount() {
			return MetadataObject.ExtendedProperties.Count;
		}
		///<summary>Gets a collection of all ExtendedProperty names on the current object.</summary>
		[IntelliSense("Gets a collection of all ExtendedProperty names on the current object.")]
		public IEnumerable<string> GetExtendedProperties() {
			return MetadataObject.ExtendedProperties.Select(a => a.Name);
		}

		/// <summary>
///             The description of the role, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio.
///             </summary>
		[DisplayName("Description")]
		[Category("Basic"),Description(@"The description of the role, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio."),IntelliSense(@"The description of the role, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio.")][Editor(typeof(System.ComponentModel.Design.MultilineStringEditor), typeof(System.Drawing.Design.UITypeEditor))]
		public string Description {
			get {
			    return MetadataObject.Description;
			}
			set {
				
				var oldValue = Description;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DESCRIPTION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.Description = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DESCRIPTION, oldValue, newValue));
				OnPropertyChanged(Properties.DESCRIPTION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeDescription() { return false; }
/// <summary>
///             The level of access for this role. Possible values are as follows. None (1): The role has no access to the model. Read (2): The role can read metadata and data of the model. ReadRefresh (3): The role has read and refresh permission. Refresh (4): The role can refresh the data and calculations in the model. Administrator (5): The role can administer the model.
///             </summary>
		[DisplayName("Model Permission")]
		[Category("Translations, Perspectives, Security"),Description(@"The level of access for this role. Possible values are as follows. None (1): The role has no access to the model. Read (2): The role can read metadata and data of the model. ReadRefresh (3): The role has read and refresh permission. Refresh (4): The role can refresh the data and calculations in the model. Administrator (5): The role can administer the model."),IntelliSense(@"The level of access for this role. Possible values are as follows. None (1): The role has no access to the model. Read (2): The role can read metadata and data of the model. ReadRefresh (3): The role has read and refresh permission. Refresh (4): The role can refresh the data and calculations in the model. Administrator (5): The role can administer the model.")]
		public ModelPermission ModelPermission {
			get {
			    return (ModelPermission)MetadataObject.ModelPermission;
			}
			set {
				
				var oldValue = ModelPermission;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.MODELPERMISSION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.ModelPermission = (TOM.ModelPermission)newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.MODELPERMISSION, oldValue, newValue));
				OnPropertyChanged(Properties.MODELPERMISSION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeModelPermission() { return false; }

		internal static ModelRole CreateFromMetadata(Model parent, TOM.ModelRole metadataObject) {
			var obj = new ModelRole(metadataObject);
			parent.Roles.Add(obj);
			
			obj.Init();

			return obj;
		}


		/// <summary>
		/// Creates a new ModelRole and adds it to the parent Model.
		/// Also creates the underlying metadataobject and adds it to the TOM tree.
		/// </summary>
		public static ModelRole CreateNew(Model parent, string name = null)
		{
			if(!parent.Handler.PowerBIGovernance.AllowCreate(typeof(ModelRole))) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(ModelRole).GetTypeName()));
			}

			var metadataObject = new TOM.ModelRole();
			metadataObject.Name = parent.Roles.GetNewName(string.IsNullOrWhiteSpace(name) ? "New " + typeof(ModelRole).GetTypeName() : name);
            InitMetadata(metadataObject, parent);
            var obj = new ModelRole(metadataObject);

			parent.Roles.Add(obj);
			
			obj.Init();

			return obj;
		}

        static partial void InitMetadata(TOM.ModelRole metadataObject, Model parent);

		/// <summary>
		/// Creates a new ModelRole and adds it to the current Model.
		/// Also creates the underlying metadataobject and adds it to the TOM tree.
		/// </summary>		
		public static ModelRole CreateNew(string name = null)
		{
			return CreateNew(TabularModelHandler.Singleton.Model, name);
		}


		/// <summary>
		/// Creates an exact copy of this ModelRole object.
		/// </summary>
		[IntelliSense("Creates an exact copy of this ModelRole object.")]
		public ModelRole Clone(string newName = null) {
			if(!Handler.PowerBIGovernance.AllowCreate(this.GetType())) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(ModelRole).GetTypeName()));
			}

		    Handler.BeginUpdate("Clone ModelRole");

			// Create a clone of the underlying metadataobject:
			var tom = MetadataObject.Clone() as TOM.ModelRole;


			// Assign a new, unique name:
			tom.Name = Parent.Roles.GetNewName(string.IsNullOrEmpty(newName) ? tom.Name + " copy" : newName);
				
			// Create the TOM Wrapper object, representing the metadataobject
			ModelRole obj = CreateFromMetadata(Parent, tom);

            Handler.EndUpdate();

            return obj;
		}

		TabularNamedObject IClonableObject.Clone(string newName, bool includeTranslations, TabularNamedObject newParent) 
		{
			if (newParent != null) throw new ArgumentException("This object can not be cloned to another parent. Argument newParent should be left as null.", "newParent");
			return Clone(newName);
		}

	
        internal override void RenewMetadataObject()
        {
            Handler.WrapperLookup.Remove(MetadataObject);
            var json = TOM.JsonSerializer.SerializeObject(MetadataObject, RenewMetadataOptions);
            MetadataObject = TOM.JsonSerializer.DeserializeObject<TOM.ModelRole>(json);
            Handler.WrapperLookup.Add(MetadataObject, this);
        }

		///<summary>The parent Model of the current Model Role.</summary>
		public Model Parent { 
			get {
				return Handler.WrapperLookup[MetadataObject.Parent] as Model;
			}
		}

        internal override ITabularObjectCollection GetCollectionForChild(TabularObject child)
        {
			if (child is ModelRoleMember) return Members;
			if (child is TablePermission) return TablePermissions;
            return base.GetCollectionForChild(child);
        }

        /// <summary>
        /// The collection of ModelRoleMember objects on this ModelRole.
        /// </summary>
		[DisplayName("Members")]
		[Category("Translations, Perspectives, Security"),IntelliSense("The collection of Model Role Member objects on the current Model Role.")][Editor(typeof(TabularEditor.PropertyGridUI.RoleMemberCollectionEditor), typeof(System.Drawing.Design.UITypeEditor))]
		public ModelRoleMemberCollection Members { get; private set; }
        /// <summary>
        /// The collection of TablePermission objects on this ModelRole.
        /// </summary>
		[DisplayName("Table Permissions")]
		[Category("Translations, Perspectives, Security"),IntelliSense("The collection of Table Permission objects on the current Model Role.")]
		public TablePermissionCollection TablePermissions { get; private set; }

		/// <summary>
		/// CTOR - only called from static factory methods on the class
		/// </summary>
		ModelRole(TOM.ModelRole metadataObject) : base(metadataObject)
		{
			
			// Create indexer for annotations:
			Annotations = new AnnotationCollection(this);
			
			// Create indexer for extended properties:
			ExtendedProperties = new ExtendedPropertyCollection(this);
			
			// Instantiate child collections:
			Members = new ModelRoleMemberCollection(this.GetObjectPath() + ".Members", MetadataObject.Members, this);
			TablePermissions = new TablePermissionCollection(this.GetObjectPath() + ".TablePermissions", MetadataObject.TablePermissions, this);

			// Populate child collections:
			Members.CreateChildrenFromMetadata();
			TablePermissions.CreateChildrenFromMetadata();

			// Hook up event handlers on child collections:
			Members.CollectionChanged += Children_CollectionChanged;
			TablePermissions.CollectionChanged += Children_CollectionChanged;
		}


		internal override void Reinit() {
			Members.Reinit();
			TablePermissions.Reinit();
		}

		internal override void Undelete(ITabularObjectCollection collection, Type tomObjectType, string tomJson) {
			base.Undelete(collection, tomObjectType, tomJson);
			Reinit();
			ReapplyReferences();
		}
		internal override sealed bool Browsable(string propertyName) {
			// Allow custom overrides to hide a property regardless of its compatibility level requirements:
			if(!base.Browsable(propertyName)) return false;

			switch (propertyName) {

				// Hide properties based on compatibility requirements (inferred from TOM):
				case Properties.EXTENDEDPROPERTIES:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1400 : Handler.CompatibilityLevel >= 1400;
				case Properties.PARENT:
					return false;
				
				default:
					return true;
			}
		}

    }


	/// <summary>
	/// Collection class for ModelRole. Provides convenient properties for setting a property on multiple objects at once.
	/// </summary>
	public sealed partial class ModelRoleCollection: TabularObjectCollection<ModelRole>
	{
		internal Model Model { get { return Parent as Model; } }
		TOM.ModelRoleCollection TOM_Collection;
		internal ModelRoleCollection(string collectionName, TOM.ModelRoleCollection metadataObjectCollection, Model parent) : base(collectionName, parent)
		{
			TOM_Collection = metadataObjectCollection;
		}
		internal override Type GetItemType() { return typeof(ModelRole); }
        internal override void TOM_Add(TOM.MetadataObject obj) { TOM_Collection.Add(obj as TOM.ModelRole); }
        internal override bool TOM_Contains(TOM.MetadataObject obj) { return TOM_Collection.Contains(obj as TOM.ModelRole); }
        internal override void TOM_Remove(TOM.MetadataObject obj) { TOM_Collection.Remove(obj as TOM.ModelRole); }
        internal override void TOM_Clear() { TOM_Collection.Clear(); }
        internal override bool TOM_ContainsName(string name) { return TOM_Collection.ContainsName(name); }
		internal override TOM.MetadataObject TOM_Get(int index) { return TOM_Collection[index]; }
        internal override TOM.MetadataObject TOM_Get(string name) { return TOM_Collection[name]; }
        internal override TOM.MetadataObject TOM_Find(string name) { return TOM_Collection.Find(name); }
        internal override string GetNewName(string prefix = null) { return string.IsNullOrEmpty(prefix) ? TOM_Collection.GetNewName() : TOM_Collection.GetNewName(prefix); }
        internal override int IndexOf(TOM.MetadataObject obj) { return TOM_Collection.IndexOf(obj as TOM.ModelRole); }
        /// <summary>The number of items in this collection.</summary>
		public override int Count { get { return TOM_Collection.Count; } }
		/// <summary>Returns an enumerator that iterates through the collection.</summary>
        public override IEnumerator<ModelRole> GetEnumerator() { return TOM_Collection.Select(h => Handler.WrapperLookup[h]).OfType<ModelRole>().GetEnumerator(); }
		internal override void Reinit() {
			var ixOffset = 0;
			for(int i = 0; i < Count; i++) {
				var metadataObj = TOM_Get(i) as TOM.ModelRole;
				var item = Handler.WrapperLookup.TryGetValue(metadataObj, out var existingItem) ? existingItem as ModelRole : CreateFromMetadata(metadataObj);
				Handler.WrapperLookup.Remove(item.MetadataObject);
				item.MetadataObject = Model.MetadataObject.Roles[i + ixOffset] as TOM.ModelRole;
				Handler.WrapperLookup.Add(item.MetadataObject, item);
				item.Collection = this;
			}
			TOM_Collection = Model.MetadataObject.Roles;
			foreach(var item in this) item.Reinit();
		}

		internal override void ReapplyReferences() {
			foreach(var item in this) item.ReapplyReferences();
		}

		private ModelRole CreateFromMetadata(TOM.ModelRole obj)
		{
			if(obj is TOM.ModelRole modelroleObj) return ModelRole.CreateFromMetadata(Model, modelroleObj);
		    return null;
		}

		/// <summary>
		/// Calling this method will populate the ModelRoleCollection with objects based on the MetadataObjects in the corresponding MetadataObjectCollection.
		/// </summary>
		internal override void CreateChildrenFromMetadata()
		{
			// Construct child objects (they are automatically added to the Handler's WrapperLookup dictionary):
			foreach(var obj in TOM_Collection)
			{
				CreateFromMetadata(obj);
			}
		}

		/// <summary>
		/// Sets the Description property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the Description property of all objects in the collection at once.")]
		public string Description {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("Description"));
				this.ToList().ForEach(item => { item.Description = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the ModelPermission property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the ModelPermission property of all objects in the collection at once.")]
		public ModelPermission ModelPermission {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("ModelPermission"));
				this.ToList().ForEach(item => { item.ModelPermission = value; });
				Handler.UndoManager.EndBatch();
			}
		}
	}
  
	/// <summary>
///             Defines a user principal that belongs to the Role. It is a child of a Role object.
///             </summary>
	[TypeConverter(typeof(DynamicPropertyConverter))]
	public abstract partial class ModelRoleMember: TabularNamedObject
			, IInternalAnnotationObject
			, IInternalExtendedPropertyObject
	{
	    internal new TOM.ModelRoleMember MetadataObject 
		{ 
			get 
			{ 
				return base.MetadataObject as TOM.ModelRoleMember; 
		    } 
			set 
			{ 
				base.MetadataObject = value; 
			}
		}

        private bool CanClearAnnotations() => GetAnnotationsCount() > 0;
        ///<summary>Removes all annotations from this object.</summary>
        [IntelliSense("Removes all annotations from this object.")]
        public void ClearAnnotations()
        {
            Handler.BeginUpdate("Clear annotations");
            foreach(var annotation in GetAnnotations().ToList()) {
                RemoveAnnotation(annotation);
            }
            Handler.EndUpdate();
        }

		///<summary>The collection of Annotations on the current Model Role Member.</summary>
        [Browsable(true),NoMultiselect,Category("Metadata"),Description("The collection of Annotations on the current Model Role Member."),Editor(typeof(AnnotationCollectionEditor), typeof(UITypeEditor))]
        [PropertyAction(nameof(ClearAnnotations))]
		public AnnotationCollection Annotations { get; private set; }
		///<summary>Gets the value of the annotation with the given index, assuming it exists.</summary>
		[IntelliSense("Gets the value of the annotation with the given index, assuming it exists.")]
		public string GetAnnotation(int index) {
			return MetadataObject.Annotations[index].Value;
		}
		///<summary>Returns true if an annotation with the given name exists. Otherwise false.</summary>
		[IntelliSense("Returns true if an annotation with the given name exists. Otherwise false.")]
		public bool HasAnnotation(string name) {
		    return MetadataObject.Annotations.ContainsName(name);
		}
		///<summary>Gets the value of the annotation with the given name. Returns null if no such annotation exists.</summary>
		[IntelliSense("Gets the value of the annotation with the given name. Returns null if no such annotation exists.")]
		public string GetAnnotation(string name) {
		    return HasAnnotation(name) ? MetadataObject.Annotations[name].Value : null;
		}
		///<summary>Sets the value of the annotation with the given index, assuming it exists.</summary>
		[IntelliSense("Sets the value of the annotation with the given index, assuming it exists.")]
		public void SetAnnotation(int index, string value) {
		    SetAnnotation(index, value, true);
		}
		internal void SetAnnotation(int index, string value, bool undoable) {
		    var name = MetadataObject.Annotations[index].Name;
			SetAnnotation(name, value, undoable);
		}
		void IInternalAnnotationObject.SetAnnotation(int index, string value, bool undoable) {
			SetAnnotation(index, value, undoable);
		}
		///<summary>Returns a unique name for a new annotation.</summary>
		public string GetNewAnnotationName() {
			return MetadataObject.Annotations.GetNewName("New Annotation");
		}
		///<summary>Sets the value of the annotation having the given name. If no such annotation exists, it will be created. If value is set to null, the annotation will be removed.</summary>
		[IntelliSense("Sets the value of the annotation having the given name. If no such annotation exists, it will be created. If value is set to null, the annotation will be removed.")]
		public void SetAnnotation(string name, string value) {
		    SetAnnotation(name, value, true);
		}
		internal void SetAnnotation(string name, string value, bool undoable) {
			if(name == null) name = GetNewAnnotationName();

			if(value == null) {
				// Remove annotation if set to null:
				RemoveAnnotation(name, undoable);
				return;
			}

			if(undoable) {
 				if(GetAnnotation(name) == value) return;
				bool undoable2 = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + value, ref undoable2, ref cancel);
				if (cancel) return;
			}

			if(MetadataObject.Annotations.Contains(name)) {
				// Change existing annotation:

				var oldValue = GetAnnotation(name);
				MetadataObject.Annotations[name].Value = value;
				if (undoable) {
					Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, oldValue));
					OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, name + ":" + value);
				}
			} else {
				// Add new annotation:

				MetadataObject.Annotations.Add(new TOM.Annotation{ Name = name, Value = value });
				if (undoable) {
					Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, null));
					OnPropertyChanged(Properties.ANNOTATIONS, null, name + ":" + value);
				}
			}
		}
		void IInternalAnnotationObject.SetAnnotation(string name, string value, bool undoable) {
			this.SetAnnotation(name, value, undoable);
		}
		///<summary>Remove an annotation by the given name.</summary>
		[IntelliSense("Remove an annotation by the given name.")]
		public void RemoveAnnotation(string name) {
		    RemoveAnnotation(name, true);
		}
		internal void RemoveAnnotation(string name, bool undoable) {
			if(MetadataObject.Annotations.Contains(name)) {
				if(undoable) 
				{
				    bool undoable2 = true;
				    bool cancel = false;
				    OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + GetAnnotation(name), ref undoable2, ref cancel);
				    if (cancel) return;
				}

			    var oldValue = MetadataObject.Annotations[name].Value;
				MetadataObject.Annotations.Remove(name);

				if (undoable) 
				{
					Handler.UndoManager.Add(new UndoAnnotationAction(this, name, null, oldValue));
					OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, null);
			    }
			}
		}
		void IInternalAnnotationObject.RemoveAnnotation(string name, bool undoable) {
			this.RemoveAnnotation(name, undoable);
		}
		///<summary>Gets the number of annotations on the current Model Role Member.</summary>
		[IntelliSense("Gets the number of annotations on the current Model Role Member.")]
		public int GetAnnotationsCount() {
			return MetadataObject.Annotations.Count;
		}
		///<summary>Gets a collection of all annotation names on the current Model Role Member.</summary>
		[IntelliSense("Gets a collection of all annotation names on the current Model Role Member.")]
		public IEnumerable<string> GetAnnotations() {
			return MetadataObject.Annotations.Select(a => a.Name);
		}

		        private bool CanClearExtendedProperties() => GetExtendedPropertyCount() > 0;
        ///<summary>Removes all Extended Properties from this object.</summary>
        [IntelliSense("Removes all Extended Properties from this object.")]
        public void ClearExtendedProperties()
        {
            Handler.BeginUpdate("Clear extended properties");
            foreach(var extendedProperty in GetExtendedProperties().ToList()) {
                RemoveExtendedProperty(extendedProperty);
            }
            Handler.EndUpdate();
        }

		///<summary>The collection of Extended Properties on the current Model Role Member.</summary>
        [DisplayName("Extended Properties"),NoMultiselect,Category("Metadata"),Description("The collection of Extended Properties on the current Model Role Member."),Editor(typeof(ExtendedPropertyCollectionEditor), typeof(UITypeEditor))]
        [PropertyAction(nameof(ClearExtendedProperties))]
		public ExtendedPropertyCollection ExtendedProperties { get; private set; }

		///<summary>Returns true if an ExtendedProperty with the given name exists. Otherwise false.</summary>
		[IntelliSense("Returns true if an ExtendedProperty with the given name exists. Otherwise false.")]
		public bool HasExtendedProperty(string name) {
		    return MetadataObject.ExtendedProperties.ContainsName(name);
		}
		///<summary>Gets the type of the ExtendedProperty with the given index, assuming it exists.</summary>
		public ExtendedPropertyType GetExtendedPropertyType(int index) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[index].Type;
		}
		///<summary>Gets the type of the ExtendedProperty with the given name, assuming it exists.</summary>
		public ExtendedPropertyType GetExtendedPropertyType(string name) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[name].Type;
		}
		///<summary>Gets the value of the ExtendedProperty with the given index, assuming it exists.</summary>
		public string GetExtendedProperty(int index) {
			var ep = MetadataObject.ExtendedProperties[index];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		///<summary>Gets the value of the ExtendedProperty with the given name. Returns null if no such ExtendedProperty exists.</summary>
		[IntelliSense("Gets the value of the ExtendedProperty with the given name. Returns null if no such ExtendedProperty exists.")]
		public string GetExtendedProperty(string name) {
		    if(!HasExtendedProperty(name)) return null;
			var ep = MetadataObject.ExtendedProperties[name];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		///<summary>Sets the value of the ExtendedProperty with the given index, optionally specifiying the type (string or JSON) of the ExtendedProperty.</summary>
		public void SetExtendedProperty(int index, string value, ExtendedPropertyType type) {
			SetExtendedProperty(index, value, type, true);
		}
		void IInternalExtendedPropertyObject.SetExtendedProperty(int index, string value, ExtendedPropertyType type, bool undoable) {
			SetExtendedProperty(index, value, type, undoable);
		}
		internal void SetExtendedProperty(int index, string value, ExtendedPropertyType type, bool undoable) {
			var name = MetadataObject.ExtendedProperties[index].Name;
			SetExtendedProperty(name, value, type, undoable);
		}
		///<summary>Returns a unique name for a new ExtendedProperty.</summary>
		public string GetNewExtendedPropertyName() {
			return MetadataObject.ExtendedProperties.GetNewName("New ExtendedProperty");
		}
		///<summary>Sets the value of the ExtendedProperty having the given name. If no such ExtendedProperty exists, it will be created. If value is set to null, the ExtendedProperty will be removed.</summary>
		[IntelliSense("Sets the value of the ExtendedProperty having the given name. If no such ExtendedProperty exists, it will be created. If value is set to null, the ExtendedProperty will be removed.")]
		public void SetExtendedProperty(string name, string value, ExtendedPropertyType type) {
			SetExtendedProperty(name, value, type, true);
		}
		internal void SetExtendedProperty(string name, string value, ExtendedPropertyType type, bool undoable) {
			if(name == null) name = GetNewExtendedPropertyName();

			if(value == null) {
				// Remove ExtendedProperty if set to null:
				RemoveExtendedProperty(name);
				return;
			}

			if(GetExtendedProperty(name) == value) return;
			if(undoable) {
				bool cancel = false;
				OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + value, ref undoable, ref cancel);
				if (cancel) return;
			}

			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Change existing ExtendedProperty:
				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				var ep = MetadataObject.ExtendedProperties[name];
				if (ep is TOM.JsonExtendedProperty)
					(ep as TOM.JsonExtendedProperty).Value = value;
				else 
					(ep as TOM.StringExtendedProperty).Value = value;
					
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, name + ":" + value);
			} else {
				// Add new ExtendedProperty:
				if (type == ExtendedPropertyType.Json)
					MetadataObject.ExtendedProperties.Add(new TOM.JsonExtendedProperty{ Name = name, Value = value });
				else
					MetadataObject.ExtendedProperties.Add(new TOM.StringExtendedProperty{ Name = name, Value = value });

				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, null, type));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, null, name + ":" + value);
			}
		}
		void IInternalExtendedPropertyObject.SetExtendedProperty(string name, string value, ExtendedPropertyType type, bool undoable) {
			this.SetExtendedProperty(name, value, type, undoable);
		}

		///<summary>Remove an ExtendedProperty by the given name.</summary>
		[IntelliSense("Remove an ExtendedProperty by the given name.")]
		public void RemoveExtendedProperty(string name) {
			RemoveExtendedProperty(name, true);
		}

		internal void RemoveExtendedProperty(string name, bool undoable) {
			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Get current value:
				if(undoable) {
					bool cancel = false;
					OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + GetExtendedProperty(name), ref undoable, ref cancel);
					if (cancel) return;
				}

				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				MetadataObject.ExtendedProperties.Remove(name);

				// Undo-handling:
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, null, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, null);
			}
		}
		void IInternalExtendedPropertyObject.RemoveExtendedProperty(string name, bool undoable) {
			this.RemoveExtendedProperty(name, undoable);
		}
		///<summary>Gets the number of ExtendedProperties on the current object.</summary>
		[IntelliSense("Gets the number of ExtendedProperties on the current object.")]
		public int GetExtendedPropertyCount() {
			return MetadataObject.ExtendedProperties.Count;
		}
		///<summary>Gets a collection of all ExtendedProperty names on the current object.</summary>
		[IntelliSense("Gets a collection of all ExtendedProperty names on the current object.")]
		public IEnumerable<string> GetExtendedProperties() {
			return MetadataObject.ExtendedProperties.Select(a => a.Name);
		}

		/// <summary>
///             The security name that identifies the user or group of the member.
///             </summary>
		[DisplayName("Member Name")]
		[Category("Options"),Description(@"The security name that identifies the user or group of the member."),IntelliSense(@"The security name that identifies the user or group of the member.")]
		public string MemberName {
			get {
			    return MetadataObject.MemberName;
			}
			set {
				
				var oldValue = MemberName;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.MEMBERNAME, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.MemberName = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.MEMBERNAME, oldValue, newValue));
				OnPropertyChanged(Properties.MEMBERNAME, oldValue, newValue);
			}
		}
		private bool ShouldSerializeMemberName() { return false; }
/// <summary>
///             A reference to a Member object associated with this RoleMembership.
///             </summary>
		[DisplayName("Member ID")]
		[Category("Options"),Description(@"A reference to a Member object associated with this RoleMembership."),IntelliSense(@"A reference to a Member object associated with this RoleMembership.")]
		public string MemberID {
			get {
			    return MetadataObject.MemberID;
			}
			set {
				
				var oldValue = MemberID;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.MEMBERID, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.MemberID = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.MEMBERID, oldValue, newValue));
				OnPropertyChanged(Properties.MEMBERID, oldValue, newValue);
			}
		}
		private bool ShouldSerializeMemberID() { return false; }
/// <summary>
///             A reference to a Role object that owns this RoleMembeship.
///             </summary>
		[DisplayName("Role")]
		[Category("Options"),Description(@"A reference to a Role object that owns this RoleMembeship."),IntelliSense(@"A reference to a Role object that owns this RoleMembeship.")]
		public ModelRole Role {
			get {
				if (MetadataObject.Role == null) return null;
			    return Handler.WrapperLookup[MetadataObject.Role] as ModelRole;
            }
			
		}
		private bool ShouldSerializeRole() { return false; }

	
        internal override void RenewMetadataObject()
        {
            Handler.WrapperLookup.Remove(MetadataObject);
            var json = TOM.JsonSerializer.SerializeObject(MetadataObject, RenewMetadataOptions);
            MetadataObject = TOM.JsonSerializer.DeserializeObject<TOM.ModelRoleMember>(json);
            Handler.WrapperLookup.Add(MetadataObject, this);
        }

		///<summary>The parent Model Role of the current Model Role Member.</summary>
		public ModelRole Parent { 
			get {
				return Handler.WrapperLookup[MetadataObject.Parent] as ModelRole;
			}
		}



		/// <summary>
		/// CTOR - only called from static factory methods on the class
		/// </summary>
		protected ModelRoleMember(TOM.ModelRoleMember metadataObject) : base(metadataObject)
		{
			
			// Create indexer for annotations:
			Annotations = new AnnotationCollection(this);
			
			// Create indexer for extended properties:
			ExtendedProperties = new ExtendedPropertyCollection(this);
		}



		internal override void Undelete(ITabularObjectCollection collection, Type tomObjectType, string tomJson) {
			base.Undelete(collection, tomObjectType, tomJson);
			Reinit();
			ReapplyReferences();
		}
		internal override bool Browsable(string propertyName) {
			// Allow custom overrides to hide a property regardless of its compatibility level requirements:
			if(!base.Browsable(propertyName)) return false;

			switch (propertyName) {

				// Hide properties based on compatibility requirements (inferred from TOM):
				case Properties.EXTENDEDPROPERTIES:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1400 : Handler.CompatibilityLevel >= 1400;
				case Properties.PARENT:
					return false;
				
				default:
					return true;
			}
		}

    }


	/// <summary>
	/// Collection class for ModelRoleMember. Provides convenient properties for setting a property on multiple objects at once.
	/// </summary>
	public sealed partial class ModelRoleMemberCollection: TabularObjectCollection<ModelRoleMember>
	{
		internal ModelRole ModelRole { get { return Parent as ModelRole; } }
		TOM.ModelRoleMemberCollection TOM_Collection;
		internal ModelRoleMemberCollection(string collectionName, TOM.ModelRoleMemberCollection metadataObjectCollection, ModelRole parent) : base(collectionName, parent)
		{
			TOM_Collection = metadataObjectCollection;
		}
		internal override Type GetItemType() { return typeof(ModelRoleMember); }
        internal override void TOM_Add(TOM.MetadataObject obj) { TOM_Collection.Add(obj as TOM.ModelRoleMember); }
        internal override bool TOM_Contains(TOM.MetadataObject obj) { return TOM_Collection.Contains(obj as TOM.ModelRoleMember); }
        internal override void TOM_Remove(TOM.MetadataObject obj) { TOM_Collection.Remove(obj as TOM.ModelRoleMember); }
        internal override void TOM_Clear() { TOM_Collection.Clear(); }
        internal override bool TOM_ContainsName(string name) { return TOM_Collection.ContainsName(name); }
		internal override TOM.MetadataObject TOM_Get(int index) { return TOM_Collection[index]; }
        internal override TOM.MetadataObject TOM_Get(string name) { return TOM_Collection[name]; }
        internal override TOM.MetadataObject TOM_Find(string name) { return TOM_Collection.Find(name); }
        internal override string GetNewName(string prefix = null) { return string.IsNullOrEmpty(prefix) ? TOM_Collection.GetNewName() : TOM_Collection.GetNewName(prefix); }
        internal override int IndexOf(TOM.MetadataObject obj) { return TOM_Collection.IndexOf(obj as TOM.ModelRoleMember); }
        /// <summary>The number of items in this collection.</summary>
		public override int Count { get { return TOM_Collection.Count; } }
		/// <summary>Returns an enumerator that iterates through the collection.</summary>
        public override IEnumerator<ModelRoleMember> GetEnumerator() { return TOM_Collection.Select(h => Handler.WrapperLookup[h]).OfType<ModelRoleMember>().GetEnumerator(); }
		internal override void Reinit() {
			var ixOffset = 0;
			for(int i = 0; i < Count; i++) {
				var metadataObj = TOM_Get(i) as TOM.ModelRoleMember;
				var item = Handler.WrapperLookup.TryGetValue(metadataObj, out var existingItem) ? existingItem as ModelRoleMember : CreateFromMetadata(metadataObj);
				Handler.WrapperLookup.Remove(item.MetadataObject);
				item.MetadataObject = ModelRole.MetadataObject.Members[i + ixOffset] as TOM.ModelRoleMember;
				Handler.WrapperLookup.Add(item.MetadataObject, item);
				item.Collection = this;
			}
			TOM_Collection = ModelRole.MetadataObject.Members;
			foreach(var item in this) item.Reinit();
		}

		internal override void ReapplyReferences() {
			foreach(var item in this) item.ReapplyReferences();
		}

		private ModelRoleMember CreateFromMetadata(TOM.ModelRoleMember obj)
		{
			if(obj is TOM.ExternalModelRoleMember externalmodelrolememberObj) return ExternalModelRoleMember.CreateFromMetadata(ModelRole, externalmodelrolememberObj);
			if(obj is TOM.WindowsModelRoleMember windowsmodelrolememberObj) return WindowsModelRoleMember.CreateFromMetadata(ModelRole, windowsmodelrolememberObj);
		    return null;
		}

		/// <summary>
		/// Calling this method will populate the ModelRoleMemberCollection with objects based on the MetadataObjects in the corresponding MetadataObjectCollection.
		/// </summary>
		internal override void CreateChildrenFromMetadata()
		{
			// Construct child objects (they are automatically added to the Handler's WrapperLookup dictionary):
			foreach(var obj in TOM_Collection)
			{
				CreateFromMetadata(obj);
			}
		}

		/// <summary>
		/// Sets the MemberName property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the MemberName property of all objects in the collection at once.")]
		public string MemberName {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("MemberName"));
				this.ToList().ForEach(item => { item.MemberName = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the MemberID property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the MemberID property of all objects in the collection at once.")]
		public string MemberID {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("MemberID"));
				this.ToList().ForEach(item => { item.MemberID = value; });
				Handler.UndoManager.EndBatch();
			}
		}
	}
  
	/// <summary>
///             Represents a partition in a table. Partitions define the query against external data sources that return the rowsets of a <see cref="T:TabularEditor.TOMWrapper.Table" />.
///             </summary>
	[TypeConverter(typeof(DynamicPropertyConverter))]
	public partial class Partition: TabularNamedObject
			, IErrorMessageObject
			, ITabularTableObject
			, IDescriptionObject
			, IInternalAnnotationObject
			, IInternalExtendedPropertyObject
			, IClonableObject
	{
	    internal new TOM.Partition MetadataObject 
		{ 
			get 
			{ 
				return base.MetadataObject as TOM.Partition; 
		    } 
			set 
			{ 
				base.MetadataObject = value; 
			}
		}

/// <summary>
///             The type of source used by the Partition. This is either a query against a DataSource, or for calculated tables, an expression.
///             </summary>
		[DisplayName("Source Type")]
		[Category("Options"),Description(@"The type of source used by the Partition. This is either a query against a DataSource, or for calculated tables, an expression."),IntelliSense(@"The type of source used by the Partition. This is either a query against a DataSource, or for calculated tables, an expression.")]
		public PartitionSourceType SourceType {
			get {
			    return (PartitionSourceType)MetadataObject.SourceType;
			}
			
		}
		private bool ShouldSerializeSourceType() { return false; }
        private bool CanClearAnnotations() => GetAnnotationsCount() > 0;
        ///<summary>Removes all annotations from this object.</summary>
        [IntelliSense("Removes all annotations from this object.")]
        public void ClearAnnotations()
        {
            Handler.BeginUpdate("Clear annotations");
            foreach(var annotation in GetAnnotations().ToList()) {
                RemoveAnnotation(annotation);
            }
            Handler.EndUpdate();
        }

		///<summary>The collection of Annotations on the current Partition.</summary>
        [Browsable(true),NoMultiselect,Category("Metadata"),Description("The collection of Annotations on the current Partition."),Editor(typeof(AnnotationCollectionEditor), typeof(UITypeEditor))]
        [PropertyAction(nameof(ClearAnnotations))]
		public AnnotationCollection Annotations { get; private set; }
		///<summary>Gets the value of the annotation with the given index, assuming it exists.</summary>
		[IntelliSense("Gets the value of the annotation with the given index, assuming it exists.")]
		public string GetAnnotation(int index) {
			return MetadataObject.Annotations[index].Value;
		}
		///<summary>Returns true if an annotation with the given name exists. Otherwise false.</summary>
		[IntelliSense("Returns true if an annotation with the given name exists. Otherwise false.")]
		public bool HasAnnotation(string name) {
		    return MetadataObject.Annotations.ContainsName(name);
		}
		///<summary>Gets the value of the annotation with the given name. Returns null if no such annotation exists.</summary>
		[IntelliSense("Gets the value of the annotation with the given name. Returns null if no such annotation exists.")]
		public string GetAnnotation(string name) {
		    return HasAnnotation(name) ? MetadataObject.Annotations[name].Value : null;
		}
		///<summary>Sets the value of the annotation with the given index, assuming it exists.</summary>
		[IntelliSense("Sets the value of the annotation with the given index, assuming it exists.")]
		public void SetAnnotation(int index, string value) {
		    SetAnnotation(index, value, true);
		}
		internal void SetAnnotation(int index, string value, bool undoable) {
		    var name = MetadataObject.Annotations[index].Name;
			SetAnnotation(name, value, undoable);
		}
		void IInternalAnnotationObject.SetAnnotation(int index, string value, bool undoable) {
			SetAnnotation(index, value, undoable);
		}
		///<summary>Returns a unique name for a new annotation.</summary>
		public string GetNewAnnotationName() {
			return MetadataObject.Annotations.GetNewName("New Annotation");
		}
		///<summary>Sets the value of the annotation having the given name. If no such annotation exists, it will be created. If value is set to null, the annotation will be removed.</summary>
		[IntelliSense("Sets the value of the annotation having the given name. If no such annotation exists, it will be created. If value is set to null, the annotation will be removed.")]
		public void SetAnnotation(string name, string value) {
		    SetAnnotation(name, value, true);
		}
		internal void SetAnnotation(string name, string value, bool undoable) {
			if(name == null) name = GetNewAnnotationName();

			if(value == null) {
				// Remove annotation if set to null:
				RemoveAnnotation(name, undoable);
				return;
			}

			if(undoable) {
 				if(GetAnnotation(name) == value) return;
				bool undoable2 = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + value, ref undoable2, ref cancel);
				if (cancel) return;
			}

			if(MetadataObject.Annotations.Contains(name)) {
				// Change existing annotation:

				var oldValue = GetAnnotation(name);
				MetadataObject.Annotations[name].Value = value;
				if (undoable) {
					Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, oldValue));
					OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, name + ":" + value);
				}
			} else {
				// Add new annotation:

				MetadataObject.Annotations.Add(new TOM.Annotation{ Name = name, Value = value });
				if (undoable) {
					Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, null));
					OnPropertyChanged(Properties.ANNOTATIONS, null, name + ":" + value);
				}
			}
		}
		void IInternalAnnotationObject.SetAnnotation(string name, string value, bool undoable) {
			this.SetAnnotation(name, value, undoable);
		}
		///<summary>Remove an annotation by the given name.</summary>
		[IntelliSense("Remove an annotation by the given name.")]
		public void RemoveAnnotation(string name) {
		    RemoveAnnotation(name, true);
		}
		internal void RemoveAnnotation(string name, bool undoable) {
			if(MetadataObject.Annotations.Contains(name)) {
				if(undoable) 
				{
				    bool undoable2 = true;
				    bool cancel = false;
				    OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + GetAnnotation(name), ref undoable2, ref cancel);
				    if (cancel) return;
				}

			    var oldValue = MetadataObject.Annotations[name].Value;
				MetadataObject.Annotations.Remove(name);

				if (undoable) 
				{
					Handler.UndoManager.Add(new UndoAnnotationAction(this, name, null, oldValue));
					OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, null);
			    }
			}
		}
		void IInternalAnnotationObject.RemoveAnnotation(string name, bool undoable) {
			this.RemoveAnnotation(name, undoable);
		}
		///<summary>Gets the number of annotations on the current Partition.</summary>
		[IntelliSense("Gets the number of annotations on the current Partition.")]
		public int GetAnnotationsCount() {
			return MetadataObject.Annotations.Count;
		}
		///<summary>Gets a collection of all annotation names on the current Partition.</summary>
		[IntelliSense("Gets a collection of all annotation names on the current Partition.")]
		public IEnumerable<string> GetAnnotations() {
			return MetadataObject.Annotations.Select(a => a.Name);
		}

		        private bool CanClearExtendedProperties() => GetExtendedPropertyCount() > 0;
        ///<summary>Removes all Extended Properties from this object.</summary>
        [IntelliSense("Removes all Extended Properties from this object.")]
        public void ClearExtendedProperties()
        {
            Handler.BeginUpdate("Clear extended properties");
            foreach(var extendedProperty in GetExtendedProperties().ToList()) {
                RemoveExtendedProperty(extendedProperty);
            }
            Handler.EndUpdate();
        }

		///<summary>The collection of Extended Properties on the current Partition.</summary>
        [DisplayName("Extended Properties"),NoMultiselect,Category("Metadata"),Description("The collection of Extended Properties on the current Partition."),Editor(typeof(ExtendedPropertyCollectionEditor), typeof(UITypeEditor))]
        [PropertyAction(nameof(ClearExtendedProperties))]
		public ExtendedPropertyCollection ExtendedProperties { get; private set; }

		///<summary>Returns true if an ExtendedProperty with the given name exists. Otherwise false.</summary>
		[IntelliSense("Returns true if an ExtendedProperty with the given name exists. Otherwise false.")]
		public bool HasExtendedProperty(string name) {
		    return MetadataObject.ExtendedProperties.ContainsName(name);
		}
		///<summary>Gets the type of the ExtendedProperty with the given index, assuming it exists.</summary>
		public ExtendedPropertyType GetExtendedPropertyType(int index) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[index].Type;
		}
		///<summary>Gets the type of the ExtendedProperty with the given name, assuming it exists.</summary>
		public ExtendedPropertyType GetExtendedPropertyType(string name) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[name].Type;
		}
		///<summary>Gets the value of the ExtendedProperty with the given index, assuming it exists.</summary>
		public string GetExtendedProperty(int index) {
			var ep = MetadataObject.ExtendedProperties[index];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		///<summary>Gets the value of the ExtendedProperty with the given name. Returns null if no such ExtendedProperty exists.</summary>
		[IntelliSense("Gets the value of the ExtendedProperty with the given name. Returns null if no such ExtendedProperty exists.")]
		public string GetExtendedProperty(string name) {
		    if(!HasExtendedProperty(name)) return null;
			var ep = MetadataObject.ExtendedProperties[name];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		///<summary>Sets the value of the ExtendedProperty with the given index, optionally specifiying the type (string or JSON) of the ExtendedProperty.</summary>
		public void SetExtendedProperty(int index, string value, ExtendedPropertyType type) {
			SetExtendedProperty(index, value, type, true);
		}
		void IInternalExtendedPropertyObject.SetExtendedProperty(int index, string value, ExtendedPropertyType type, bool undoable) {
			SetExtendedProperty(index, value, type, undoable);
		}
		internal void SetExtendedProperty(int index, string value, ExtendedPropertyType type, bool undoable) {
			var name = MetadataObject.ExtendedProperties[index].Name;
			SetExtendedProperty(name, value, type, undoable);
		}
		///<summary>Returns a unique name for a new ExtendedProperty.</summary>
		public string GetNewExtendedPropertyName() {
			return MetadataObject.ExtendedProperties.GetNewName("New ExtendedProperty");
		}
		///<summary>Sets the value of the ExtendedProperty having the given name. If no such ExtendedProperty exists, it will be created. If value is set to null, the ExtendedProperty will be removed.</summary>
		[IntelliSense("Sets the value of the ExtendedProperty having the given name. If no such ExtendedProperty exists, it will be created. If value is set to null, the ExtendedProperty will be removed.")]
		public void SetExtendedProperty(string name, string value, ExtendedPropertyType type) {
			SetExtendedProperty(name, value, type, true);
		}
		internal void SetExtendedProperty(string name, string value, ExtendedPropertyType type, bool undoable) {
			if(name == null) name = GetNewExtendedPropertyName();

			if(value == null) {
				// Remove ExtendedProperty if set to null:
				RemoveExtendedProperty(name);
				return;
			}

			if(GetExtendedProperty(name) == value) return;
			if(undoable) {
				bool cancel = false;
				OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + value, ref undoable, ref cancel);
				if (cancel) return;
			}

			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Change existing ExtendedProperty:
				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				var ep = MetadataObject.ExtendedProperties[name];
				if (ep is TOM.JsonExtendedProperty)
					(ep as TOM.JsonExtendedProperty).Value = value;
				else 
					(ep as TOM.StringExtendedProperty).Value = value;
					
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, name + ":" + value);
			} else {
				// Add new ExtendedProperty:
				if (type == ExtendedPropertyType.Json)
					MetadataObject.ExtendedProperties.Add(new TOM.JsonExtendedProperty{ Name = name, Value = value });
				else
					MetadataObject.ExtendedProperties.Add(new TOM.StringExtendedProperty{ Name = name, Value = value });

				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, null, type));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, null, name + ":" + value);
			}
		}
		void IInternalExtendedPropertyObject.SetExtendedProperty(string name, string value, ExtendedPropertyType type, bool undoable) {
			this.SetExtendedProperty(name, value, type, undoable);
		}

		///<summary>Remove an ExtendedProperty by the given name.</summary>
		[IntelliSense("Remove an ExtendedProperty by the given name.")]
		public void RemoveExtendedProperty(string name) {
			RemoveExtendedProperty(name, true);
		}

		internal void RemoveExtendedProperty(string name, bool undoable) {
			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Get current value:
				if(undoable) {
					bool cancel = false;
					OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + GetExtendedProperty(name), ref undoable, ref cancel);
					if (cancel) return;
				}

				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				MetadataObject.ExtendedProperties.Remove(name);

				// Undo-handling:
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, null, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, null);
			}
		}
		void IInternalExtendedPropertyObject.RemoveExtendedProperty(string name, bool undoable) {
			this.RemoveExtendedProperty(name, undoable);
		}
		///<summary>Gets the number of ExtendedProperties on the current object.</summary>
		[IntelliSense("Gets the number of ExtendedProperties on the current object.")]
		public int GetExtendedPropertyCount() {
			return MetadataObject.ExtendedProperties.Count;
		}
		///<summary>Gets a collection of all ExtendedProperty names on the current object.</summary>
		[IntelliSense("Gets a collection of all ExtendedProperty names on the current object.")]
		public IEnumerable<string> GetExtendedProperties() {
			return MetadataObject.ExtendedProperties.Select(a => a.Name);
		}

		/// <summary>
///             The description of the partition, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio.
///             </summary>
		[DisplayName("Description")]
		[Category("Basic"),Description(@"The description of the partition, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio."),IntelliSense(@"The description of the partition, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio.")][Editor(typeof(System.ComponentModel.Design.MultilineStringEditor), typeof(System.Drawing.Design.UITypeEditor))]
		public string Description {
			get {
			    return MetadataObject.Description;
			}
			set {
				
				var oldValue = Description;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DESCRIPTION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.Description = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DESCRIPTION, oldValue, newValue));
				OnPropertyChanged(Properties.DESCRIPTION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeDescription() { return false; }
/// <summary>
///             Provides information on the state of the partition. Possible values are as follows. Ready (1): The partition is queryable and has up-to-date data. NoData (3): The partition is queryable but has no data. This state applies only to partitions with a type other than Calculated. CalculationNeeded (4): The partition is not queryable and needs to be refreshed (that is, recalculated) to become functional. This state applies only to partitions of the type Calculated. SemanticError (5): The partition is in an error state because of an invalid expression and is not queryable. This state applies only to partitions of the type Calculated. EvaluationError (6): The partition is in an error state because of an error during expression evaluation. The partition is not queryable. This state applies only to partitions of the type Calculated. DependencyError (7): The partition is in an error state because some of its calculation dependencies are in an error state. The partition is not queryable. This state applies only to partitions of the type Calculated. Incomplete (8): Some parts of the partition have no data, and the partition needs to be refreshed to bring the data in. The partition is queryable. This state applies only to partitions of a type other than Calculated. SyntaxError (9): The partition is in an error state because of a syntax error in its expression. The partition is not queryable. This state applies only to partitions of the type Calculated.
///             </summary>
		[DisplayName("State")]
		[Category("Metadata"),Description(@"Provides information on the state of the partition. Possible values are as follows. Ready (1): The partition is queryable and has up-to-date data. NoData (3): The partition is queryable but has no data. This state applies only to partitions with a type other than Calculated. CalculationNeeded (4): The partition is not queryable and needs to be refreshed (that is, recalculated) to become functional. This state applies only to partitions of the type Calculated. SemanticError (5): The partition is in an error state because of an invalid expression and is not queryable. This state applies only to partitions of the type Calculated. EvaluationError (6): The partition is in an error state because of an error during expression evaluation. The partition is not queryable. This state applies only to partitions of the type Calculated. DependencyError (7): The partition is in an error state because some of its calculation dependencies are in an error state. The partition is not queryable. This state applies only to partitions of the type Calculated. Incomplete (8): Some parts of the partition have no data, and the partition needs to be refreshed to bring the data in. The partition is queryable. This state applies only to partitions of a type other than Calculated. SyntaxError (9): The partition is in an error state because of a syntax error in its expression. The partition is not queryable. This state applies only to partitions of the type Calculated."),IntelliSense(@"Provides information on the state of the partition. Possible values are as follows. Ready (1): The partition is queryable and has up-to-date data. NoData (3): The partition is queryable but has no data. This state applies only to partitions with a type other than Calculated. CalculationNeeded (4): The partition is not queryable and needs to be refreshed (that is, recalculated) to become functional. This state applies only to partitions of the type Calculated. SemanticError (5): The partition is in an error state because of an invalid expression and is not queryable. This state applies only to partitions of the type Calculated. EvaluationError (6): The partition is in an error state because of an error during expression evaluation. The partition is not queryable. This state applies only to partitions of the type Calculated. DependencyError (7): The partition is in an error state because some of its calculation dependencies are in an error state. The partition is not queryable. This state applies only to partitions of the type Calculated. Incomplete (8): Some parts of the partition have no data, and the partition needs to be refreshed to bring the data in. The partition is queryable. This state applies only to partitions of a type other than Calculated. SyntaxError (9): The partition is in an error state because of a syntax error in its expression. The partition is not queryable. This state applies only to partitions of the type Calculated.")]
		public ObjectState State {
			get {
			    return (ObjectState)MetadataObject.State;
			}
			
		}
		private bool ShouldSerializeState() { return false; }
/// <summary>
///             Defines the method for making data available in the partition. Possible values are as follows. Import (0) Data will be imported from a data source. DirectQuery (1) Data will be queried dynamically from a data source. Default (2): Only partitions can use this value. When set, the partition will inherit the DefaultMode of the Model. Push (3): Data will be pushed into the partition. The Mode of a Partition can be set to Default (2), in which case it will inherit its Mode from the DefaultMode of the Model
///             </summary>
		[DisplayName("Mode")]
		[Category("Options"),Description(@"Defines the method for making data available in the partition. Possible values are as follows. Import (0) Data will be imported from a data source. DirectQuery (1) Data will be queried dynamically from a data source. Default (2): Only partitions can use this value. When set, the partition will inherit the DefaultMode of the Model. Push (3): Data will be pushed into the partition. The Mode of a Partition can be set to Default (2), in which case it will inherit its Mode from the DefaultMode of the Model"),IntelliSense(@"Defines the method for making data available in the partition. Possible values are as follows. Import (0) Data will be imported from a data source. DirectQuery (1) Data will be queried dynamically from a data source. Default (2): Only partitions can use this value. When set, the partition will inherit the DefaultMode of the Model. Push (3): Data will be pushed into the partition. The Mode of a Partition can be set to Default (2), in which case it will inherit its Mode from the DefaultMode of the Model")]
		public ModeType Mode {
			get {
			    return (ModeType)MetadataObject.Mode;
			}
			set {
				
				var oldValue = Mode;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.MODE, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.Mode = (TOM.ModeType)newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.MODE, oldValue, newValue));
				OnPropertyChanged(Properties.MODE, oldValue, newValue);
			}
		}
		private bool ShouldSerializeMode() { return false; }
/// <summary>
///             Determines which partitions should be selected to run queries against the model. The possible values are as follows. Full (0) - Partitions with DataView set to Default or Full are selected. Sample (1): Partitions with DataView set to Default or Sample are selected. SampleAndFull (2): All partitions are selected. Default (3) - Inherits from the default DataView of the Model object.
///             </summary>
		[DisplayName("Data View")]
		[Category("Options"),Description(@"Determines which partitions should be selected to run queries against the model. The possible values are as follows. Full (0) - Partitions with DataView set to Default or Full are selected. Sample (1): Partitions with DataView set to Default or Sample are selected. SampleAndFull (2): All partitions are selected. Default (3) - Inherits from the default DataView of the Model object."),IntelliSense(@"Determines which partitions should be selected to run queries against the model. The possible values are as follows. Full (0) - Partitions with DataView set to Default or Full are selected. Sample (1): Partitions with DataView set to Default or Sample are selected. SampleAndFull (2): All partitions are selected. Default (3) - Inherits from the default DataView of the Model object.")]
		public DataViewType DataView {
			get {
			    return (DataViewType)MetadataObject.DataView;
			}
			set {
				
				var oldValue = DataView;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DATAVIEW, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.DataView = (TOM.DataViewType)newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DATAVIEW, oldValue, newValue));
				OnPropertyChanged(Properties.DATAVIEW, oldValue, newValue);
			}
		}
		private bool ShouldSerializeDataView() { return false; }
/// <summary>
///             The string that explains the error state associated with the current object. It is set by the engine only when the state of the object is one of these three values: SemanticError, DependencyError, or EvaluationError.This element applies only to partitions of the type Calculated.
///             </summary>
		[DisplayName("Error Message")]
		[Category("Metadata"),Description(@"The string that explains the error state associated with the current object. It is set by the engine only when the state of the object is one of these three values: SemanticError, DependencyError, or EvaluationError.This element applies only to partitions of the type Calculated."),IntelliSense(@"The string that explains the error state associated with the current object. It is set by the engine only when the state of the object is one of these three values: SemanticError, DependencyError, or EvaluationError.This element applies only to partitions of the type Calculated.")]
		public string ErrorMessage {
			get {
			    return MetadataObject.ErrorMessage;
			}
			
		}
		private bool ShouldSerializeErrorMessage() { return false; }
		///<summary>The parent table of the current Partition.</summary>
		[Browsable(false)]
		public Table Table
		{ 
			get 
			{ 
				TabularObject t = null;
				if(MetadataObject == null || MetadataObject.Table == null) return null;
				if(!Handler.WrapperLookup.TryGetValue(MetadataObject.Table, out t)) {
				    if(!MetadataObject.Table.IsRemoved)
						t = Model.Tables[MetadataObject.Table.Name];
				}
				return t as Table;
			} 
		}

		internal static Partition CreateFromMetadata(Table parent, TOM.Partition metadataObject) {
			var obj = new Partition(metadataObject);
			parent.Partitions.Add(obj);
			
			obj.Init();

			return obj;
		}


		/// <summary>
		/// Creates a new Partition and adds it to the parent Table.
		/// Also creates the underlying metadataobject and adds it to the TOM tree.
		/// </summary>
		public static Partition CreateNew(Table parent, string name = null)
		{
			if(!parent.Handler.PowerBIGovernance.AllowCreate(typeof(Partition))) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(Partition).GetTypeName()));
			}

			var metadataObject = new TOM.Partition();
			metadataObject.Name = parent.Partitions.GetNewName(string.IsNullOrWhiteSpace(name) ? "New " + typeof(Partition).GetTypeName() : name);
            InitMetadata(metadataObject, parent);
            var obj = new Partition(metadataObject);

			parent.Partitions.Add(obj);
			
			obj.Init();

			return obj;
		}

        static partial void InitMetadata(TOM.Partition metadataObject, Table parent);


		/// <summary>
		/// Creates an exact copy of this Partition object.
		/// </summary>
		[IntelliSense("Creates an exact copy of this Partition object.")]
		public virtual Partition Clone(string newName = null, Table newParent = null) {
			if(!Handler.PowerBIGovernance.AllowCreate(this.GetType())) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(Partition).GetTypeName()));
			}

		    Handler.BeginUpdate("Clone Partition");

			// Create a clone of the underlying metadataobject:
			var tom = MetadataObject.Clone() as TOM.Partition;


			// Assign a new, unique name:
			tom.Name = Parent.Partitions.GetNewName(string.IsNullOrEmpty(newName) ? tom.Name + " copy" : newName);
				
			// Create the TOM Wrapper object, representing the metadataobject
			Partition obj = CreateFromMetadata(newParent ?? Parent, tom);

            Handler.EndUpdate();

            return obj;
		}

		TabularNamedObject IClonableObject.Clone(string newName, bool includeTranslations, TabularNamedObject newParent) 
		{
			return Clone(newName);
		}

	
        internal override void RenewMetadataObject()
        {
            Handler.WrapperLookup.Remove(MetadataObject);
            var json = TOM.JsonSerializer.SerializeObject(MetadataObject, RenewMetadataOptions);
            MetadataObject = TOM.JsonSerializer.DeserializeObject<TOM.Partition>(json);
            Handler.WrapperLookup.Add(MetadataObject, this);
        }

		///<summary>The parent Table of the current Partition.</summary>
		public Table Parent { 
			get {
				return Handler.WrapperLookup[MetadataObject.Parent] as Table;
			}
		}



		/// <summary>
		/// CTOR - only called from static factory methods on the class
		/// </summary>
		protected Partition(TOM.Partition metadataObject) : base(metadataObject)
		{
			
			// Create indexer for annotations:
			Annotations = new AnnotationCollection(this);
			
			// Create indexer for extended properties:
			ExtendedProperties = new ExtendedPropertyCollection(this);
		}



		internal override void Undelete(ITabularObjectCollection collection, Type tomObjectType, string tomJson) {
			base.Undelete(collection, tomObjectType, tomJson);
			Reinit();
			ReapplyReferences();
		}
		internal override sealed bool Browsable(string propertyName) {
			// Allow custom overrides to hide a property regardless of its compatibility level requirements:
			if(!base.Browsable(propertyName)) return false;

			switch (propertyName) {

				// Hide properties based on compatibility requirements (inferred from TOM):
				case Properties.EXTENDEDPROPERTIES:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1400 : Handler.CompatibilityLevel >= 1400;
				case Properties.QUERYGROUP:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1480 : Handler.CompatibilityLevel >= 1480;
				case Properties.RETAINDATATILLFORCECALCULATE:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1400 : Handler.CompatibilityLevel >= 1400;
				case Properties.PARENT:
					return false;
				
				default:
					return true;
			}
		}

    }


	/// <summary>
	/// Collection class for Partition. Provides convenient properties for setting a property on multiple objects at once.
	/// </summary>
	public sealed partial class PartitionCollection: TabularObjectCollection<Partition>
	{
		internal Table Table { get { return Parent as Table; } }
		TOM.PartitionCollection TOM_Collection;
		internal PartitionCollection(string collectionName, TOM.PartitionCollection metadataObjectCollection, Table parent) : base(collectionName, parent)
		{
			TOM_Collection = metadataObjectCollection;
		}
		internal override Type GetItemType() { return typeof(Partition); }
        internal override void TOM_Add(TOM.MetadataObject obj) { TOM_Collection.Add(obj as TOM.Partition); }
        internal override bool TOM_Contains(TOM.MetadataObject obj) { return TOM_Collection.Contains(obj as TOM.Partition); }
        internal override void TOM_Remove(TOM.MetadataObject obj) { TOM_Collection.Remove(obj as TOM.Partition); }
        internal override void TOM_Clear() { TOM_Collection.Clear(); }
        internal override bool TOM_ContainsName(string name) { return TOM_Collection.ContainsName(name); }
		internal override TOM.MetadataObject TOM_Get(int index) { return TOM_Collection[index]; }
        internal override TOM.MetadataObject TOM_Get(string name) { return TOM_Collection[name]; }
        internal override TOM.MetadataObject TOM_Find(string name) { return TOM_Collection.Find(name); }
        internal override string GetNewName(string prefix = null) { return string.IsNullOrEmpty(prefix) ? TOM_Collection.GetNewName() : TOM_Collection.GetNewName(prefix); }
        internal override int IndexOf(TOM.MetadataObject obj) { return TOM_Collection.IndexOf(obj as TOM.Partition); }
        /// <summary>The number of items in this collection.</summary>
		public override int Count { get { return TOM_Collection.Count; } }
		/// <summary>Returns an enumerator that iterates through the collection.</summary>
        public override IEnumerator<Partition> GetEnumerator() { return TOM_Collection.Select(h => Handler.WrapperLookup[h]).OfType<Partition>().GetEnumerator(); }
		internal override void Reinit() {
			var ixOffset = 0;
			for(int i = 0; i < Count; i++) {
				var metadataObj = TOM_Get(i) as TOM.Partition;
				var item = Handler.WrapperLookup.TryGetValue(metadataObj, out var existingItem) ? existingItem as Partition : CreateFromMetadata(metadataObj);
				Handler.WrapperLookup.Remove(item.MetadataObject);
				item.MetadataObject = Table.MetadataObject.Partitions[i + ixOffset] as TOM.Partition;
				Handler.WrapperLookup.Add(item.MetadataObject, item);
				item.Collection = this;
			}
			TOM_Collection = Table.MetadataObject.Partitions;
			foreach(var item in this) item.Reinit();
		}

		internal override void ReapplyReferences() {
			foreach(var item in this) item.ReapplyReferences();
		}

		private Partition CreateFromMetadata(TOM.Partition obj)
		{
			if(obj.SourceType == TOM.PartitionSourceType.M) return MPartition.CreateFromMetadata(Table, obj);
            else if(obj.SourceType == TOM.PartitionSourceType.Entity) return EntityPartition.CreateFromMetadata(Table, obj);
            else if(obj.SourceType == TOM.PartitionSourceType.PolicyRange) return PolicyRangePartition.CreateFromMetadata(Table, obj);
			else return Partition.CreateFromMetadata(Table, obj);
		    return null;
		}

		/// <summary>
		/// Calling this method will populate the PartitionCollection with objects based on the MetadataObjects in the corresponding MetadataObjectCollection.
		/// </summary>
		internal override void CreateChildrenFromMetadata()
		{
			// Construct child objects (they are automatically added to the Handler's WrapperLookup dictionary):
			foreach(var obj in TOM_Collection)
			{
				CreateFromMetadata(obj);
			}
		}

		/// <summary>
		/// Sets the Description property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the Description property of all objects in the collection at once.")]
		public string Description {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("Description"));
				this.ToList().ForEach(item => { item.Description = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the Mode property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the Mode property of all objects in the collection at once.")]
		public ModeType Mode {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("Mode"));
				this.ToList().ForEach(item => { item.Mode = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the DataView property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the DataView property of all objects in the collection at once.")]
		public DataViewType DataView {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("DataView"));
				this.ToList().ForEach(item => { item.DataView = value; });
				Handler.UndoManager.EndBatch();
			}
		}
	}
  
	/// <summary>
///             Set object.
///             </summary><remarks>This metadata object is only supported at database compatibility level of 1400 or above for Pbi server.</remarks>
	[TypeConverter(typeof(DynamicPropertyConverter))]
	public sealed partial class Set: TabularNamedObject
			, IFolderObject
			, IHideableObject
			, IErrorMessageObject
			, ITabularTableObject
			, IDescriptionObject
			, IExpressionObject
			, IInternalAnnotationObject
			, IInternalExtendedPropertyObject
			, IClonableObject
	{
	    internal new TOM.Set MetadataObject 
		{ 
			get 
			{ 
				return base.MetadataObject as TOM.Set; 
		    } 
			set 
			{ 
				base.MetadataObject = value; 
			}
		}

        private bool CanClearAnnotations() => GetAnnotationsCount() > 0;
        ///<summary>Removes all annotations from this object.</summary>
        [IntelliSense("Removes all annotations from this object.")]
        public void ClearAnnotations()
        {
            Handler.BeginUpdate("Clear annotations");
            foreach(var annotation in GetAnnotations().ToList()) {
                RemoveAnnotation(annotation);
            }
            Handler.EndUpdate();
        }

		///<summary>The collection of Annotations on the current Set.</summary>
        [Browsable(true),NoMultiselect,Category("Metadata"),Description("The collection of Annotations on the current Set."),Editor(typeof(AnnotationCollectionEditor), typeof(UITypeEditor))]
        [PropertyAction(nameof(ClearAnnotations))]
		public AnnotationCollection Annotations { get; private set; }
		///<summary>Gets the value of the annotation with the given index, assuming it exists.</summary>
		[IntelliSense("Gets the value of the annotation with the given index, assuming it exists.")]
		public string GetAnnotation(int index) {
			return MetadataObject.Annotations[index].Value;
		}
		///<summary>Returns true if an annotation with the given name exists. Otherwise false.</summary>
		[IntelliSense("Returns true if an annotation with the given name exists. Otherwise false.")]
		public bool HasAnnotation(string name) {
		    return MetadataObject.Annotations.ContainsName(name);
		}
		///<summary>Gets the value of the annotation with the given name. Returns null if no such annotation exists.</summary>
		[IntelliSense("Gets the value of the annotation with the given name. Returns null if no such annotation exists.")]
		public string GetAnnotation(string name) {
		    return HasAnnotation(name) ? MetadataObject.Annotations[name].Value : null;
		}
		///<summary>Sets the value of the annotation with the given index, assuming it exists.</summary>
		[IntelliSense("Sets the value of the annotation with the given index, assuming it exists.")]
		public void SetAnnotation(int index, string value) {
		    SetAnnotation(index, value, true);
		}
		internal void SetAnnotation(int index, string value, bool undoable) {
		    var name = MetadataObject.Annotations[index].Name;
			SetAnnotation(name, value, undoable);
		}
		void IInternalAnnotationObject.SetAnnotation(int index, string value, bool undoable) {
			SetAnnotation(index, value, undoable);
		}
		///<summary>Returns a unique name for a new annotation.</summary>
		public string GetNewAnnotationName() {
			return MetadataObject.Annotations.GetNewName("New Annotation");
		}
		///<summary>Sets the value of the annotation having the given name. If no such annotation exists, it will be created. If value is set to null, the annotation will be removed.</summary>
		[IntelliSense("Sets the value of the annotation having the given name. If no such annotation exists, it will be created. If value is set to null, the annotation will be removed.")]
		public void SetAnnotation(string name, string value) {
		    SetAnnotation(name, value, true);
		}
		internal void SetAnnotation(string name, string value, bool undoable) {
			if(name == null) name = GetNewAnnotationName();

			if(value == null) {
				// Remove annotation if set to null:
				RemoveAnnotation(name, undoable);
				return;
			}

			if(undoable) {
 				if(GetAnnotation(name) == value) return;
				bool undoable2 = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + value, ref undoable2, ref cancel);
				if (cancel) return;
			}

			if(MetadataObject.Annotations.Contains(name)) {
				// Change existing annotation:

				var oldValue = GetAnnotation(name);
				MetadataObject.Annotations[name].Value = value;
				if (undoable) {
					Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, oldValue));
					OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, name + ":" + value);
				}
			} else {
				// Add new annotation:

				MetadataObject.Annotations.Add(new TOM.Annotation{ Name = name, Value = value });
				if (undoable) {
					Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, null));
					OnPropertyChanged(Properties.ANNOTATIONS, null, name + ":" + value);
				}
			}
		}
		void IInternalAnnotationObject.SetAnnotation(string name, string value, bool undoable) {
			this.SetAnnotation(name, value, undoable);
		}
		///<summary>Remove an annotation by the given name.</summary>
		[IntelliSense("Remove an annotation by the given name.")]
		public void RemoveAnnotation(string name) {
		    RemoveAnnotation(name, true);
		}
		internal void RemoveAnnotation(string name, bool undoable) {
			if(MetadataObject.Annotations.Contains(name)) {
				if(undoable) 
				{
				    bool undoable2 = true;
				    bool cancel = false;
				    OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + GetAnnotation(name), ref undoable2, ref cancel);
				    if (cancel) return;
				}

			    var oldValue = MetadataObject.Annotations[name].Value;
				MetadataObject.Annotations.Remove(name);

				if (undoable) 
				{
					Handler.UndoManager.Add(new UndoAnnotationAction(this, name, null, oldValue));
					OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, null);
			    }
			}
		}
		void IInternalAnnotationObject.RemoveAnnotation(string name, bool undoable) {
			this.RemoveAnnotation(name, undoable);
		}
		///<summary>Gets the number of annotations on the current Set.</summary>
		[IntelliSense("Gets the number of annotations on the current Set.")]
		public int GetAnnotationsCount() {
			return MetadataObject.Annotations.Count;
		}
		///<summary>Gets a collection of all annotation names on the current Set.</summary>
		[IntelliSense("Gets a collection of all annotation names on the current Set.")]
		public IEnumerable<string> GetAnnotations() {
			return MetadataObject.Annotations.Select(a => a.Name);
		}

		        private bool CanClearExtendedProperties() => GetExtendedPropertyCount() > 0;
        ///<summary>Removes all Extended Properties from this object.</summary>
        [IntelliSense("Removes all Extended Properties from this object.")]
        public void ClearExtendedProperties()
        {
            Handler.BeginUpdate("Clear extended properties");
            foreach(var extendedProperty in GetExtendedProperties().ToList()) {
                RemoveExtendedProperty(extendedProperty);
            }
            Handler.EndUpdate();
        }

		///<summary>The collection of Extended Properties on the current Set.</summary>
        [DisplayName("Extended Properties"),NoMultiselect,Category("Metadata"),Description("The collection of Extended Properties on the current Set."),Editor(typeof(ExtendedPropertyCollectionEditor), typeof(UITypeEditor))]
        [PropertyAction(nameof(ClearExtendedProperties))]
		public ExtendedPropertyCollection ExtendedProperties { get; private set; }

		///<summary>Returns true if an ExtendedProperty with the given name exists. Otherwise false.</summary>
		[IntelliSense("Returns true if an ExtendedProperty with the given name exists. Otherwise false.")]
		public bool HasExtendedProperty(string name) {
		    return MetadataObject.ExtendedProperties.ContainsName(name);
		}
		///<summary>Gets the type of the ExtendedProperty with the given index, assuming it exists.</summary>
		public ExtendedPropertyType GetExtendedPropertyType(int index) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[index].Type;
		}
		///<summary>Gets the type of the ExtendedProperty with the given name, assuming it exists.</summary>
		public ExtendedPropertyType GetExtendedPropertyType(string name) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[name].Type;
		}
		///<summary>Gets the value of the ExtendedProperty with the given index, assuming it exists.</summary>
		public string GetExtendedProperty(int index) {
			var ep = MetadataObject.ExtendedProperties[index];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		///<summary>Gets the value of the ExtendedProperty with the given name. Returns null if no such ExtendedProperty exists.</summary>
		[IntelliSense("Gets the value of the ExtendedProperty with the given name. Returns null if no such ExtendedProperty exists.")]
		public string GetExtendedProperty(string name) {
		    if(!HasExtendedProperty(name)) return null;
			var ep = MetadataObject.ExtendedProperties[name];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		///<summary>Sets the value of the ExtendedProperty with the given index, optionally specifiying the type (string or JSON) of the ExtendedProperty.</summary>
		public void SetExtendedProperty(int index, string value, ExtendedPropertyType type) {
			SetExtendedProperty(index, value, type, true);
		}
		void IInternalExtendedPropertyObject.SetExtendedProperty(int index, string value, ExtendedPropertyType type, bool undoable) {
			SetExtendedProperty(index, value, type, undoable);
		}
		internal void SetExtendedProperty(int index, string value, ExtendedPropertyType type, bool undoable) {
			var name = MetadataObject.ExtendedProperties[index].Name;
			SetExtendedProperty(name, value, type, undoable);
		}
		///<summary>Returns a unique name for a new ExtendedProperty.</summary>
		public string GetNewExtendedPropertyName() {
			return MetadataObject.ExtendedProperties.GetNewName("New ExtendedProperty");
		}
		///<summary>Sets the value of the ExtendedProperty having the given name. If no such ExtendedProperty exists, it will be created. If value is set to null, the ExtendedProperty will be removed.</summary>
		[IntelliSense("Sets the value of the ExtendedProperty having the given name. If no such ExtendedProperty exists, it will be created. If value is set to null, the ExtendedProperty will be removed.")]
		public void SetExtendedProperty(string name, string value, ExtendedPropertyType type) {
			SetExtendedProperty(name, value, type, true);
		}
		internal void SetExtendedProperty(string name, string value, ExtendedPropertyType type, bool undoable) {
			if(name == null) name = GetNewExtendedPropertyName();

			if(value == null) {
				// Remove ExtendedProperty if set to null:
				RemoveExtendedProperty(name);
				return;
			}

			if(GetExtendedProperty(name) == value) return;
			if(undoable) {
				bool cancel = false;
				OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + value, ref undoable, ref cancel);
				if (cancel) return;
			}

			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Change existing ExtendedProperty:
				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				var ep = MetadataObject.ExtendedProperties[name];
				if (ep is TOM.JsonExtendedProperty)
					(ep as TOM.JsonExtendedProperty).Value = value;
				else 
					(ep as TOM.StringExtendedProperty).Value = value;
					
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, name + ":" + value);
			} else {
				// Add new ExtendedProperty:
				if (type == ExtendedPropertyType.Json)
					MetadataObject.ExtendedProperties.Add(new TOM.JsonExtendedProperty{ Name = name, Value = value });
				else
					MetadataObject.ExtendedProperties.Add(new TOM.StringExtendedProperty{ Name = name, Value = value });

				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, null, type));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, null, name + ":" + value);
			}
		}
		void IInternalExtendedPropertyObject.SetExtendedProperty(string name, string value, ExtendedPropertyType type, bool undoable) {
			this.SetExtendedProperty(name, value, type, undoable);
		}

		///<summary>Remove an ExtendedProperty by the given name.</summary>
		[IntelliSense("Remove an ExtendedProperty by the given name.")]
		public void RemoveExtendedProperty(string name) {
			RemoveExtendedProperty(name, true);
		}

		internal void RemoveExtendedProperty(string name, bool undoable) {
			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Get current value:
				if(undoable) {
					bool cancel = false;
					OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + GetExtendedProperty(name), ref undoable, ref cancel);
					if (cancel) return;
				}

				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				MetadataObject.ExtendedProperties.Remove(name);

				// Undo-handling:
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, null, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, null);
			}
		}
		void IInternalExtendedPropertyObject.RemoveExtendedProperty(string name, bool undoable) {
			this.RemoveExtendedProperty(name, undoable);
		}
		///<summary>Gets the number of ExtendedProperties on the current object.</summary>
		[IntelliSense("Gets the number of ExtendedProperties on the current object.")]
		public int GetExtendedPropertyCount() {
			return MetadataObject.ExtendedProperties.Count;
		}
		///<summary>Gets a collection of all ExtendedProperty names on the current object.</summary>
		[IntelliSense("Gets a collection of all ExtendedProperty names on the current object.")]
		public IEnumerable<string> GetExtendedProperties() {
			return MetadataObject.ExtendedProperties.Select(a => a.Name);
		}

		/// <summary>
///             The description of the set
///             </summary>
		[DisplayName("Description")]
		[Category("Basic"),Description(@"The description of the set"),IntelliSense(@"The description of the set")][Editor(typeof(System.ComponentModel.Design.MultilineStringEditor), typeof(System.Drawing.Design.UITypeEditor))]
		public string Description {
			get {
			    return MetadataObject.Description;
			}
			set {
				
				var oldValue = Description;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DESCRIPTION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.Description = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DESCRIPTION, oldValue, newValue));
				OnPropertyChanged(Properties.DESCRIPTION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeDescription() { return false; }
/// <summary>
///             The DAX expression that is evaluated for the calculated set.
///             </summary>
		[DisplayName("Expression")]
		[Category("Options"),Description(@"The DAX expression that is evaluated for the calculated set."),IntelliSense(@"The DAX expression that is evaluated for the calculated set.")][Editor(typeof(System.ComponentModel.Design.MultilineStringEditor), typeof(System.Drawing.Design.UITypeEditor))]
		public string Expression {
			get {
			    return MetadataObject.Expression;
			}
			set {
				
				var oldValue = Expression;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.EXPRESSION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.Expression = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.EXPRESSION, oldValue, newValue));
				OnPropertyChanged(Properties.EXPRESSION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeExpression() { return false; }
/// <summary>
///             Indicates whether the set is static or dynamic
///             </summary>
		[DisplayName("Dynamic")]
		[Category("Options"),Description(@"Indicates whether the set is static or dynamic"),IntelliSense(@"Indicates whether the set is static or dynamic")]
		public bool IsDynamic {
			get {
			    return MetadataObject.IsDynamic;
			}
			set {
				
				var oldValue = IsDynamic;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ISDYNAMIC, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.IsDynamic = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.ISDYNAMIC, oldValue, newValue));
				OnPropertyChanged(Properties.ISDYNAMIC, oldValue, newValue);
			}
		}
		private bool ShouldSerializeIsDynamic() { return false; }
/// <summary>
///             A boolean value that indicates whether the set is treated as hidden by client visualization tools. True if the set is treated as hidden by client visualization tools; otherwise false.
///             </summary>
		[DisplayName("Hidden")]
		[Category("Basic"),Description(@"A boolean value that indicates whether the set is treated as hidden by client visualization tools. True if the set is treated as hidden by client visualization tools; otherwise false."),IntelliSense(@"A boolean value that indicates whether the set is treated as hidden by client visualization tools. True if the set is treated as hidden by client visualization tools; otherwise false.")]
		public bool IsHidden {
			get {
			    return MetadataObject.IsHidden;
			}
			set {
				
				var oldValue = IsHidden;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ISHIDDEN, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.IsHidden = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.ISHIDDEN, oldValue, newValue));
				OnPropertyChanged(Properties.ISHIDDEN, oldValue, newValue);
				Handler.UpdateObject(this);
			}
		}
		private bool ShouldSerializeIsHidden() { return false; }
/// <summary>
///             Provides information on the state of the set. Possible values and their interpretation are as follows. Ready (1) The set is queryable and has up-to-date data. NoData (3) Not applicable to Set. CalculationNeeded (4) Not applicable to Set. SemanticError (5) The set expression has a semantic error. EvaluationError (6) Not applicable to Set. DependencyError (7) A dependency associated with this set is in an error state (SemanticError, EvaluationError, or DependencyError). Incomplete (8) Not applicable to Set. SyntaxError (9) The measure has a syntax error in its expression.
///             </summary>
		[DisplayName("State")]
		[Category("Metadata"),Description(@"Provides information on the state of the set. Possible values and their interpretation are as follows. Ready (1) The set is queryable and has up-to-date data. NoData (3) Not applicable to Set. CalculationNeeded (4) Not applicable to Set. SemanticError (5) The set expression has a semantic error. EvaluationError (6) Not applicable to Set. DependencyError (7) A dependency associated with this set is in an error state (SemanticError, EvaluationError, or DependencyError). Incomplete (8) Not applicable to Set. SyntaxError (9) The measure has a syntax error in its expression."),IntelliSense(@"Provides information on the state of the set. Possible values and their interpretation are as follows. Ready (1) The set is queryable and has up-to-date data. NoData (3) Not applicable to Set. CalculationNeeded (4) Not applicable to Set. SemanticError (5) The set expression has a semantic error. EvaluationError (6) Not applicable to Set. DependencyError (7) A dependency associated with this set is in an error state (SemanticError, EvaluationError, or DependencyError). Incomplete (8) Not applicable to Set. SyntaxError (9) The measure has a syntax error in its expression.")]
		public ObjectState State {
			get {
			    return (ObjectState)MetadataObject.State;
			}
			
		}
		private bool ShouldSerializeState() { return false; }
/// <summary>
///             The string that explains the error state associated with the current object. It is set by the engine only when the state of the object is one of these three values: SemanticError, DependencyError or EvaluationError.
///             </summary>
		[DisplayName("Error Message")]
		[Category("Metadata"),Description(@"The string that explains the error state associated with the current object. It is set by the engine only when the state of the object is one of these three values: SemanticError, DependencyError or EvaluationError."),IntelliSense(@"The string that explains the error state associated with the current object. It is set by the engine only when the state of the object is one of these three values: SemanticError, DependencyError or EvaluationError.")]
		public string ErrorMessage {
			get {
			    return MetadataObject.ErrorMessage;
			}
			
		}
		private bool ShouldSerializeErrorMessage() { return false; }
/// <summary>
///             Defines the display folder for the Measure, for use by clients.
///             </summary>
		[DisplayName("Display Folder")]
		[Category("Basic"),Description(@"Defines the display folder for the Measure, for use by clients."),IntelliSense(@"Defines the display folder for the Measure, for use by clients.")][Editor(typeof(CustomDialogEditor), typeof(System.Drawing.Design.UITypeEditor))]
		public string DisplayFolder {
			get {
			    return MetadataObject.DisplayFolder;
			}
			set {
				if(value.Contains(@"\\")) throw new Exception("Display Folder names cannot be blank.");
				var oldValue = DisplayFolder;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DISPLAYFOLDER, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.DisplayFolder = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DISPLAYFOLDER, oldValue, newValue));
				OnPropertyChanged(Properties.DISPLAYFOLDER, oldValue, newValue);
				Handler.UpdateFolders(Table);
			}
		}
		private bool ShouldSerializeDisplayFolder() { return false; }
        /// <summary>
        /// Collection of localized Display Folders for the current Set.
        /// </summary>
        [Browsable(true),DisplayName("Translated Display Folders"),Description("Shows all translated Display Folders of the current Set."),Category("Translations, Perspectives, Security")]
	    public TranslationIndexer TranslatedDisplayFolders { private set; get; }
		///<summary>The parent table of the current Set.</summary>
		[Browsable(false)]
		public Table Table
		{ 
			get 
			{ 
				TabularObject t = null;
				if(MetadataObject == null || MetadataObject.Table == null) return null;
				if(!Handler.WrapperLookup.TryGetValue(MetadataObject.Table, out t)) {
				    if(!MetadataObject.Table.IsRemoved)
						t = Model.Tables[MetadataObject.Table.Name];
				}
				return t as Table;
			} 
		}

		internal static Set CreateFromMetadata(Table parent, TOM.Set metadataObject) {
			var obj = new Set(metadataObject);
			parent.Sets.Add(obj);
			
			obj.Init();

			return obj;
		}


		/// <summary>
		/// Creates a new Set and adds it to the parent Table.
		/// Also creates the underlying metadataobject and adds it to the TOM tree.
		/// </summary>
		public static Set CreateNew(Table parent, string name = null)
		{
			if(!parent.Handler.PowerBIGovernance.AllowCreate(typeof(Set))) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(Set).GetTypeName()));
			}

			var metadataObject = new TOM.Set();
			metadataObject.Name = parent.Sets.GetNewName(string.IsNullOrWhiteSpace(name) ? "New " + typeof(Set).GetTypeName() : name);
            InitMetadata(metadataObject, parent);
            var obj = new Set(metadataObject);

			parent.Sets.Add(obj);
			
			obj.Init();

			return obj;
		}

        static partial void InitMetadata(TOM.Set metadataObject, Table parent);


		/// <summary>
		/// Creates an exact copy of this Set object.
		/// </summary>
		[IntelliSense("Creates an exact copy of this Set object.")]
		public Set Clone(string newName = null, Table newParent = null) {
			if(!Handler.PowerBIGovernance.AllowCreate(this.GetType())) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(Set).GetTypeName()));
			}

		    Handler.BeginUpdate("Clone Set");

			// Create a clone of the underlying metadataobject:
			var tom = MetadataObject.Clone() as TOM.Set;


			// Assign a new, unique name:
			tom.Name = Parent.Sets.GetNewName(string.IsNullOrEmpty(newName) ? tom.Name + " copy" : newName);
				
			// Create the TOM Wrapper object, representing the metadataobject
			Set obj = CreateFromMetadata(newParent ?? Parent, tom);

            Handler.EndUpdate();

            return obj;
		}

		TabularNamedObject IClonableObject.Clone(string newName, bool includeTranslations, TabularNamedObject newParent) 
		{
			return Clone(newName);
		}

	
        internal override void RenewMetadataObject()
        {
            Handler.WrapperLookup.Remove(MetadataObject);
            var json = TOM.JsonSerializer.SerializeObject(MetadataObject, RenewMetadataOptions);
            MetadataObject = TOM.JsonSerializer.DeserializeObject<TOM.Set>(json);
            Handler.WrapperLookup.Add(MetadataObject, this);
        }

		///<summary>The parent Table of the current Set.</summary>
		public Table Parent { 
			get {
				return Handler.WrapperLookup[MetadataObject.Parent] as Table;
			}
		}



		/// <summary>
		/// CTOR - only called from static factory methods on the class
		/// </summary>
		Set(TOM.Set metadataObject) : base(metadataObject)
		{
			TranslatedDisplayFolders = new TranslationIndexer(this, TOM.TranslatedProperty.DisplayFolder);
			
			// Create indexer for annotations:
			Annotations = new AnnotationCollection(this);
			
			// Create indexer for extended properties:
			ExtendedProperties = new ExtendedPropertyCollection(this);
		}



		internal override void Undelete(ITabularObjectCollection collection, Type tomObjectType, string tomJson) {
			base.Undelete(collection, tomObjectType, tomJson);
			Reinit();
			ReapplyReferences();
		}
		internal override sealed bool Browsable(string propertyName) {
			// Allow custom overrides to hide a property regardless of its compatibility level requirements:
			if(!base.Browsable(propertyName)) return false;

			switch (propertyName) {

				// Hide properties based on compatibility requirements (inferred from TOM):
				case Properties.PARENT:
					return false;
				
				default:
					return true;
			}
		}

    }


	/// <summary>
	/// Collection class for Set. Provides convenient properties for setting a property on multiple objects at once.
	/// </summary>
	public sealed partial class SetCollection: TabularObjectCollection<Set>
	{
		internal Table Table { get { return Parent as Table; } }
		TOM.SetCollection TOM_Collection;
		internal SetCollection(string collectionName, TOM.SetCollection metadataObjectCollection, Table parent) : base(collectionName, parent)
		{
			TOM_Collection = metadataObjectCollection;
		}
		internal override Type GetItemType() { return typeof(Set); }
        internal override void TOM_Add(TOM.MetadataObject obj) { TOM_Collection.Add(obj as TOM.Set); }
        internal override bool TOM_Contains(TOM.MetadataObject obj) { return TOM_Collection.Contains(obj as TOM.Set); }
        internal override void TOM_Remove(TOM.MetadataObject obj) { TOM_Collection.Remove(obj as TOM.Set); }
        internal override void TOM_Clear() { TOM_Collection.Clear(); }
        internal override bool TOM_ContainsName(string name) { return TOM_Collection.ContainsName(name); }
		internal override TOM.MetadataObject TOM_Get(int index) { return TOM_Collection[index]; }
        internal override TOM.MetadataObject TOM_Get(string name) { return TOM_Collection[name]; }
        internal override TOM.MetadataObject TOM_Find(string name) { return TOM_Collection.Find(name); }
        internal override string GetNewName(string prefix = null) { return string.IsNullOrEmpty(prefix) ? TOM_Collection.GetNewName() : TOM_Collection.GetNewName(prefix); }
        internal override int IndexOf(TOM.MetadataObject obj) { return TOM_Collection.IndexOf(obj as TOM.Set); }
        /// <summary>The number of items in this collection.</summary>
		public override int Count { get { return TOM_Collection.Count; } }
		/// <summary>Returns an enumerator that iterates through the collection.</summary>
        public override IEnumerator<Set> GetEnumerator() { return TOM_Collection.Select(h => Handler.WrapperLookup[h]).OfType<Set>().GetEnumerator(); }
		internal override void Reinit() {
			var ixOffset = 0;
			for(int i = 0; i < Count; i++) {
				var metadataObj = TOM_Get(i) as TOM.Set;
				var item = Handler.WrapperLookup.TryGetValue(metadataObj, out var existingItem) ? existingItem as Set : CreateFromMetadata(metadataObj);
				Handler.WrapperLookup.Remove(item.MetadataObject);
				item.MetadataObject = Table.MetadataObject.Sets[i + ixOffset] as TOM.Set;
				Handler.WrapperLookup.Add(item.MetadataObject, item);
				item.Collection = this;
			}
			TOM_Collection = Table.MetadataObject.Sets;
			foreach(var item in this) item.Reinit();
		}

		internal override void ReapplyReferences() {
			foreach(var item in this) item.ReapplyReferences();
		}

		private Set CreateFromMetadata(TOM.Set obj)
		{
			if(obj is TOM.Set setObj) return Set.CreateFromMetadata(Table, setObj);
		    return null;
		}

		/// <summary>
		/// Calling this method will populate the SetCollection with objects based on the MetadataObjects in the corresponding MetadataObjectCollection.
		/// </summary>
		internal override void CreateChildrenFromMetadata()
		{
			// Construct child objects (they are automatically added to the Handler's WrapperLookup dictionary):
			foreach(var obj in TOM_Collection)
			{
				CreateFromMetadata(obj);
			}
		}

		/// <summary>
		/// Sets the Description property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the Description property of all objects in the collection at once.")]
		public string Description {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("Description"));
				this.ToList().ForEach(item => { item.Description = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the Expression property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the Expression property of all objects in the collection at once.")]
		public string Expression {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("Expression"));
				this.ToList().ForEach(item => { item.Expression = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the IsDynamic property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the IsDynamic property of all objects in the collection at once.")]
		public bool IsDynamic {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("IsDynamic"));
				this.ToList().ForEach(item => { item.IsDynamic = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the IsHidden property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the IsHidden property of all objects in the collection at once.")]
		public bool IsHidden {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("IsHidden"));
				this.ToList().ForEach(item => { item.IsHidden = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the DisplayFolder property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the DisplayFolder property of all objects in the collection at once.")]
		public string DisplayFolder {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("DisplayFolder"));
				this.ToList().ForEach(item => { item.DisplayFolder = value; });
				Handler.UndoManager.EndBatch();
			}
		}
	}
  
	/// <summary>
///             Defines a logical view over the Model and is a child of a Model object. It allows hiding Tables, Columns, Measures, and Hierarchies so that end users can look at a smaller subset of the large data model. 
///             </summary>
	[TypeConverter(typeof(DynamicPropertyConverter))]
	public sealed partial class Perspective: TabularNamedObject
			, IDescriptionObject
			, IInternalAnnotationObject
			, IInternalExtendedPropertyObject
			, IInternalTranslatableObject
			, IClonableObject
	{
	    internal new TOM.Perspective MetadataObject 
		{ 
			get 
			{ 
				return base.MetadataObject as TOM.Perspective; 
		    } 
			set 
			{ 
				base.MetadataObject = value; 
			}
		}

        private bool CanClearAnnotations() => GetAnnotationsCount() > 0;
        ///<summary>Removes all annotations from this object.</summary>
        [IntelliSense("Removes all annotations from this object.")]
        public void ClearAnnotations()
        {
            Handler.BeginUpdate("Clear annotations");
            foreach(var annotation in GetAnnotations().ToList()) {
                RemoveAnnotation(annotation);
            }
            Handler.EndUpdate();
        }

		///<summary>The collection of Annotations on the current Perspective.</summary>
        [Browsable(true),NoMultiselect,Category("Metadata"),Description("The collection of Annotations on the current Perspective."),Editor(typeof(AnnotationCollectionEditor), typeof(UITypeEditor))]
        [PropertyAction(nameof(ClearAnnotations))]
		public AnnotationCollection Annotations { get; private set; }
		///<summary>Gets the value of the annotation with the given index, assuming it exists.</summary>
		[IntelliSense("Gets the value of the annotation with the given index, assuming it exists.")]
		public string GetAnnotation(int index) {
			return MetadataObject.Annotations[index].Value;
		}
		///<summary>Returns true if an annotation with the given name exists. Otherwise false.</summary>
		[IntelliSense("Returns true if an annotation with the given name exists. Otherwise false.")]
		public bool HasAnnotation(string name) {
		    return MetadataObject.Annotations.ContainsName(name);
		}
		///<summary>Gets the value of the annotation with the given name. Returns null if no such annotation exists.</summary>
		[IntelliSense("Gets the value of the annotation with the given name. Returns null if no such annotation exists.")]
		public string GetAnnotation(string name) {
		    return HasAnnotation(name) ? MetadataObject.Annotations[name].Value : null;
		}
		///<summary>Sets the value of the annotation with the given index, assuming it exists.</summary>
		[IntelliSense("Sets the value of the annotation with the given index, assuming it exists.")]
		public void SetAnnotation(int index, string value) {
		    SetAnnotation(index, value, true);
		}
		internal void SetAnnotation(int index, string value, bool undoable) {
		    var name = MetadataObject.Annotations[index].Name;
			SetAnnotation(name, value, undoable);
		}
		void IInternalAnnotationObject.SetAnnotation(int index, string value, bool undoable) {
			SetAnnotation(index, value, undoable);
		}
		///<summary>Returns a unique name for a new annotation.</summary>
		public string GetNewAnnotationName() {
			return MetadataObject.Annotations.GetNewName("New Annotation");
		}
		///<summary>Sets the value of the annotation having the given name. If no such annotation exists, it will be created. If value is set to null, the annotation will be removed.</summary>
		[IntelliSense("Sets the value of the annotation having the given name. If no such annotation exists, it will be created. If value is set to null, the annotation will be removed.")]
		public void SetAnnotation(string name, string value) {
		    SetAnnotation(name, value, true);
		}
		internal void SetAnnotation(string name, string value, bool undoable) {
			if(name == null) name = GetNewAnnotationName();

			if(value == null) {
				// Remove annotation if set to null:
				RemoveAnnotation(name, undoable);
				return;
			}

			if(undoable) {
 				if(GetAnnotation(name) == value) return;
				bool undoable2 = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + value, ref undoable2, ref cancel);
				if (cancel) return;
			}

			if(MetadataObject.Annotations.Contains(name)) {
				// Change existing annotation:

				var oldValue = GetAnnotation(name);
				MetadataObject.Annotations[name].Value = value;
				if (undoable) {
					Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, oldValue));
					OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, name + ":" + value);
				}
			} else {
				// Add new annotation:

				MetadataObject.Annotations.Add(new TOM.Annotation{ Name = name, Value = value });
				if (undoable) {
					Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, null));
					OnPropertyChanged(Properties.ANNOTATIONS, null, name + ":" + value);
				}
			}
		}
		void IInternalAnnotationObject.SetAnnotation(string name, string value, bool undoable) {
			this.SetAnnotation(name, value, undoable);
		}
		///<summary>Remove an annotation by the given name.</summary>
		[IntelliSense("Remove an annotation by the given name.")]
		public void RemoveAnnotation(string name) {
		    RemoveAnnotation(name, true);
		}
		internal void RemoveAnnotation(string name, bool undoable) {
			if(MetadataObject.Annotations.Contains(name)) {
				if(undoable) 
				{
				    bool undoable2 = true;
				    bool cancel = false;
				    OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + GetAnnotation(name), ref undoable2, ref cancel);
				    if (cancel) return;
				}

			    var oldValue = MetadataObject.Annotations[name].Value;
				MetadataObject.Annotations.Remove(name);

				if (undoable) 
				{
					Handler.UndoManager.Add(new UndoAnnotationAction(this, name, null, oldValue));
					OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, null);
			    }
			}
		}
		void IInternalAnnotationObject.RemoveAnnotation(string name, bool undoable) {
			this.RemoveAnnotation(name, undoable);
		}
		///<summary>Gets the number of annotations on the current Perspective.</summary>
		[IntelliSense("Gets the number of annotations on the current Perspective.")]
		public int GetAnnotationsCount() {
			return MetadataObject.Annotations.Count;
		}
		///<summary>Gets a collection of all annotation names on the current Perspective.</summary>
		[IntelliSense("Gets a collection of all annotation names on the current Perspective.")]
		public IEnumerable<string> GetAnnotations() {
			return MetadataObject.Annotations.Select(a => a.Name);
		}

		        private bool CanClearExtendedProperties() => GetExtendedPropertyCount() > 0;
        ///<summary>Removes all Extended Properties from this object.</summary>
        [IntelliSense("Removes all Extended Properties from this object.")]
        public void ClearExtendedProperties()
        {
            Handler.BeginUpdate("Clear extended properties");
            foreach(var extendedProperty in GetExtendedProperties().ToList()) {
                RemoveExtendedProperty(extendedProperty);
            }
            Handler.EndUpdate();
        }

		///<summary>The collection of Extended Properties on the current Perspective.</summary>
        [DisplayName("Extended Properties"),NoMultiselect,Category("Metadata"),Description("The collection of Extended Properties on the current Perspective."),Editor(typeof(ExtendedPropertyCollectionEditor), typeof(UITypeEditor))]
        [PropertyAction(nameof(ClearExtendedProperties))]
		public ExtendedPropertyCollection ExtendedProperties { get; private set; }

		///<summary>Returns true if an ExtendedProperty with the given name exists. Otherwise false.</summary>
		[IntelliSense("Returns true if an ExtendedProperty with the given name exists. Otherwise false.")]
		public bool HasExtendedProperty(string name) {
		    return MetadataObject.ExtendedProperties.ContainsName(name);
		}
		///<summary>Gets the type of the ExtendedProperty with the given index, assuming it exists.</summary>
		public ExtendedPropertyType GetExtendedPropertyType(int index) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[index].Type;
		}
		///<summary>Gets the type of the ExtendedProperty with the given name, assuming it exists.</summary>
		public ExtendedPropertyType GetExtendedPropertyType(string name) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[name].Type;
		}
		///<summary>Gets the value of the ExtendedProperty with the given index, assuming it exists.</summary>
		public string GetExtendedProperty(int index) {
			var ep = MetadataObject.ExtendedProperties[index];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		///<summary>Gets the value of the ExtendedProperty with the given name. Returns null if no such ExtendedProperty exists.</summary>
		[IntelliSense("Gets the value of the ExtendedProperty with the given name. Returns null if no such ExtendedProperty exists.")]
		public string GetExtendedProperty(string name) {
		    if(!HasExtendedProperty(name)) return null;
			var ep = MetadataObject.ExtendedProperties[name];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		///<summary>Sets the value of the ExtendedProperty with the given index, optionally specifiying the type (string or JSON) of the ExtendedProperty.</summary>
		public void SetExtendedProperty(int index, string value, ExtendedPropertyType type) {
			SetExtendedProperty(index, value, type, true);
		}
		void IInternalExtendedPropertyObject.SetExtendedProperty(int index, string value, ExtendedPropertyType type, bool undoable) {
			SetExtendedProperty(index, value, type, undoable);
		}
		internal void SetExtendedProperty(int index, string value, ExtendedPropertyType type, bool undoable) {
			var name = MetadataObject.ExtendedProperties[index].Name;
			SetExtendedProperty(name, value, type, undoable);
		}
		///<summary>Returns a unique name for a new ExtendedProperty.</summary>
		public string GetNewExtendedPropertyName() {
			return MetadataObject.ExtendedProperties.GetNewName("New ExtendedProperty");
		}
		///<summary>Sets the value of the ExtendedProperty having the given name. If no such ExtendedProperty exists, it will be created. If value is set to null, the ExtendedProperty will be removed.</summary>
		[IntelliSense("Sets the value of the ExtendedProperty having the given name. If no such ExtendedProperty exists, it will be created. If value is set to null, the ExtendedProperty will be removed.")]
		public void SetExtendedProperty(string name, string value, ExtendedPropertyType type) {
			SetExtendedProperty(name, value, type, true);
		}
		internal void SetExtendedProperty(string name, string value, ExtendedPropertyType type, bool undoable) {
			if(name == null) name = GetNewExtendedPropertyName();

			if(value == null) {
				// Remove ExtendedProperty if set to null:
				RemoveExtendedProperty(name);
				return;
			}

			if(GetExtendedProperty(name) == value) return;
			if(undoable) {
				bool cancel = false;
				OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + value, ref undoable, ref cancel);
				if (cancel) return;
			}

			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Change existing ExtendedProperty:
				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				var ep = MetadataObject.ExtendedProperties[name];
				if (ep is TOM.JsonExtendedProperty)
					(ep as TOM.JsonExtendedProperty).Value = value;
				else 
					(ep as TOM.StringExtendedProperty).Value = value;
					
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, name + ":" + value);
			} else {
				// Add new ExtendedProperty:
				if (type == ExtendedPropertyType.Json)
					MetadataObject.ExtendedProperties.Add(new TOM.JsonExtendedProperty{ Name = name, Value = value });
				else
					MetadataObject.ExtendedProperties.Add(new TOM.StringExtendedProperty{ Name = name, Value = value });

				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, null, type));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, null, name + ":" + value);
			}
		}
		void IInternalExtendedPropertyObject.SetExtendedProperty(string name, string value, ExtendedPropertyType type, bool undoable) {
			this.SetExtendedProperty(name, value, type, undoable);
		}

		///<summary>Remove an ExtendedProperty by the given name.</summary>
		[IntelliSense("Remove an ExtendedProperty by the given name.")]
		public void RemoveExtendedProperty(string name) {
			RemoveExtendedProperty(name, true);
		}

		internal void RemoveExtendedProperty(string name, bool undoable) {
			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Get current value:
				if(undoable) {
					bool cancel = false;
					OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + GetExtendedProperty(name), ref undoable, ref cancel);
					if (cancel) return;
				}

				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				MetadataObject.ExtendedProperties.Remove(name);

				// Undo-handling:
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, null, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, null);
			}
		}
		void IInternalExtendedPropertyObject.RemoveExtendedProperty(string name, bool undoable) {
			this.RemoveExtendedProperty(name, undoable);
		}
		///<summary>Gets the number of ExtendedProperties on the current object.</summary>
		[IntelliSense("Gets the number of ExtendedProperties on the current object.")]
		public int GetExtendedPropertyCount() {
			return MetadataObject.ExtendedProperties.Count;
		}
		///<summary>Gets a collection of all ExtendedProperty names on the current object.</summary>
		[IntelliSense("Gets a collection of all ExtendedProperty names on the current object.")]
		public IEnumerable<string> GetExtendedProperties() {
			return MetadataObject.ExtendedProperties.Select(a => a.Name);
		}

		/// <summary>
///             The description of the perspective, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio.
///             </summary>
		[DisplayName("Description")]
		[Category("Basic"),Description(@"The description of the perspective, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio."),IntelliSense(@"The description of the perspective, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio.")][Editor(typeof(System.ComponentModel.Design.MultilineStringEditor), typeof(System.Drawing.Design.UITypeEditor))]
		public string Description {
			get {
			    return MetadataObject.Description;
			}
			set {
				
				var oldValue = Description;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DESCRIPTION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.Description = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DESCRIPTION, oldValue, newValue));
				OnPropertyChanged(Properties.DESCRIPTION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeDescription() { return false; }

        /// <summary>
        /// Collection of localized descriptions for this Perspective.
        /// </summary>
        [Browsable(true),DisplayName("Translated Descriptions"),Description("Shows all translated descriptions of the current Perspective."),Category("Translations, Perspectives, Security")]
	    public TranslationIndexer TranslatedDescriptions { private set; get; }
        /// <summary>
        /// Collection of localized names for this Perspective.
        /// </summary>
        [Browsable(true),DisplayName("Translated Names"),Description("Shows all translated names of the current Perspective."),Category("Translations, Perspectives, Security")]
	    public TranslationIndexer TranslatedNames { private set; get; }

		internal static Perspective CreateFromMetadata(Model parent, TOM.Perspective metadataObject) {
			var obj = new Perspective(metadataObject);
			parent.Perspectives.Add(obj);
			
			obj.Init();

			return obj;
		}


		/// <summary>
		/// Creates a new Perspective and adds it to the parent Model.
		/// Also creates the underlying metadataobject and adds it to the TOM tree.
		/// </summary>
		public static Perspective CreateNew(Model parent, string name = null)
		{
			if(!parent.Handler.PowerBIGovernance.AllowCreate(typeof(Perspective))) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(Perspective).GetTypeName()));
			}

			var metadataObject = new TOM.Perspective();
			metadataObject.Name = parent.Perspectives.GetNewName(string.IsNullOrWhiteSpace(name) ? "New " + typeof(Perspective).GetTypeName() : name);
            InitMetadata(metadataObject, parent);
            var obj = new Perspective(metadataObject);

			parent.Perspectives.Add(obj);
			
			obj.Init();

			return obj;
		}

        static partial void InitMetadata(TOM.Perspective metadataObject, Model parent);

		/// <summary>
		/// Creates a new Perspective and adds it to the current Model.
		/// Also creates the underlying metadataobject and adds it to the TOM tree.
		/// </summary>		
		public static Perspective CreateNew(string name = null)
		{
			return CreateNew(TabularModelHandler.Singleton.Model, name);
		}


		/// <summary>
		/// Creates an exact copy of this Perspective object.
		/// </summary>
		[IntelliSense("Creates an exact copy of this Perspective object.")]
		public Perspective Clone(string newName = null, bool includeTranslations = true) {
			if(!Handler.PowerBIGovernance.AllowCreate(this.GetType())) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(Perspective).GetTypeName()));
			}

		    Handler.BeginUpdate("Clone Perspective");

			// Create a clone of the underlying metadataobject:
			var tom = MetadataObject.Clone() as TOM.Perspective;


			// Assign a new, unique name:
			tom.Name = Parent.Perspectives.GetNewName(string.IsNullOrEmpty(newName) ? tom.Name + " copy" : newName);
				
			// Create the TOM Wrapper object, representing the metadataobject
			Perspective obj = CreateFromMetadata(Parent, tom);

			// Copy translations, if applicable:
			if(includeTranslations) {
				obj.CopyTranslationsFrom(this);
			}
            Handler.EndUpdate();

            return obj;
		}

		TabularNamedObject IClonableObject.Clone(string newName, bool includeTranslations, TabularNamedObject newParent) 
		{
			if (newParent != null) throw new ArgumentException("This object can not be cloned to another parent. Argument newParent should be left as null.", "newParent");
			return Clone(newName, includeTranslations);
		}

	
        internal override void RenewMetadataObject()
        {
            Handler.WrapperLookup.Remove(MetadataObject);
            var json = TOM.JsonSerializer.SerializeObject(MetadataObject, RenewMetadataOptions);
            MetadataObject = TOM.JsonSerializer.DeserializeObject<TOM.Perspective>(json);
            Handler.WrapperLookup.Add(MetadataObject, this);
        }

		///<summary>The parent Model of the current Perspective.</summary>
		public Model Parent { 
			get {
				return Handler.WrapperLookup[MetadataObject.Parent] as Model;
			}
		}



		/// <summary>
		/// CTOR - only called from static factory methods on the class
		/// </summary>
		Perspective(TOM.Perspective metadataObject) : base(metadataObject)
		{
			// Create indexers for translations:
			TranslatedNames = new TranslationIndexer(this, TOM.TranslatedProperty.Caption);
			TranslatedDescriptions = new TranslationIndexer(this, TOM.TranslatedProperty.Description);
			
			// Create indexer for annotations:
			Annotations = new AnnotationCollection(this);
			
			// Create indexer for extended properties:
			ExtendedProperties = new ExtendedPropertyCollection(this);
		}



		internal override void Undelete(ITabularObjectCollection collection, Type tomObjectType, string tomJson) {
			base.Undelete(collection, tomObjectType, tomJson);
			Reinit();
			ReapplyReferences();
		}
		internal override sealed bool Browsable(string propertyName) {
			// Allow custom overrides to hide a property regardless of its compatibility level requirements:
			if(!base.Browsable(propertyName)) return false;

			switch (propertyName) {

				// Hide properties based on compatibility requirements (inferred from TOM):
				case Properties.EXTENDEDPROPERTIES:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1400 : Handler.CompatibilityLevel >= 1400;
				case Properties.PARENT:
					return false;
				
				// Hides translation properties in the grid, unless the model actually contains translations:
				case Properties.TRANSLATEDNAMES:
				case Properties.TRANSLATEDDESCRIPTIONS:
					return Model.Cultures.Any();
				
				default:
					return true;
			}
		}

    }


	/// <summary>
	/// Collection class for Perspective. Provides convenient properties for setting a property on multiple objects at once.
	/// </summary>
	public sealed partial class PerspectiveCollection: TabularObjectCollection<Perspective>
	{
		internal Model Model { get { return Parent as Model; } }
		TOM.PerspectiveCollection TOM_Collection;
		internal PerspectiveCollection(string collectionName, TOM.PerspectiveCollection metadataObjectCollection, Model parent) : base(collectionName, parent)
		{
			TOM_Collection = metadataObjectCollection;
		}
		internal override Type GetItemType() { return typeof(Perspective); }
        internal override void TOM_Add(TOM.MetadataObject obj) { TOM_Collection.Add(obj as TOM.Perspective); }
        internal override bool TOM_Contains(TOM.MetadataObject obj) { return TOM_Collection.Contains(obj as TOM.Perspective); }
        internal override void TOM_Remove(TOM.MetadataObject obj) { TOM_Collection.Remove(obj as TOM.Perspective); }
        internal override void TOM_Clear() { TOM_Collection.Clear(); }
        internal override bool TOM_ContainsName(string name) { return TOM_Collection.ContainsName(name); }
		internal override TOM.MetadataObject TOM_Get(int index) { return TOM_Collection[index]; }
        internal override TOM.MetadataObject TOM_Get(string name) { return TOM_Collection[name]; }
        internal override TOM.MetadataObject TOM_Find(string name) { return TOM_Collection.Find(name); }
        internal override string GetNewName(string prefix = null) { return string.IsNullOrEmpty(prefix) ? TOM_Collection.GetNewName() : TOM_Collection.GetNewName(prefix); }
        internal override int IndexOf(TOM.MetadataObject obj) { return TOM_Collection.IndexOf(obj as TOM.Perspective); }
        /// <summary>The number of items in this collection.</summary>
		public override int Count { get { return TOM_Collection.Count; } }
		/// <summary>Returns an enumerator that iterates through the collection.</summary>
        public override IEnumerator<Perspective> GetEnumerator() { return TOM_Collection.Select(h => Handler.WrapperLookup[h]).OfType<Perspective>().GetEnumerator(); }
		internal override void Reinit() {
			var ixOffset = 0;
			for(int i = 0; i < Count; i++) {
				var metadataObj = TOM_Get(i) as TOM.Perspective;
				var item = Handler.WrapperLookup.TryGetValue(metadataObj, out var existingItem) ? existingItem as Perspective : CreateFromMetadata(metadataObj);
				Handler.WrapperLookup.Remove(item.MetadataObject);
				item.MetadataObject = Model.MetadataObject.Perspectives[i + ixOffset] as TOM.Perspective;
				Handler.WrapperLookup.Add(item.MetadataObject, item);
				item.Collection = this;
			}
			TOM_Collection = Model.MetadataObject.Perspectives;
			foreach(var item in this) item.Reinit();
		}

		internal override void ReapplyReferences() {
			foreach(var item in this) item.ReapplyReferences();
		}

		private Perspective CreateFromMetadata(TOM.Perspective obj)
		{
			if(obj is TOM.Perspective perspectiveObj) return Perspective.CreateFromMetadata(Model, perspectiveObj);
		    return null;
		}

		/// <summary>
		/// Calling this method will populate the PerspectiveCollection with objects based on the MetadataObjects in the corresponding MetadataObjectCollection.
		/// </summary>
		internal override void CreateChildrenFromMetadata()
		{
			// Construct child objects (they are automatically added to the Handler's WrapperLookup dictionary):
			foreach(var obj in TOM_Collection)
			{
				CreateFromMetadata(obj);
			}
		}

		/// <summary>
		/// Sets the Description property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the Description property of all objects in the collection at once.")]
		public string Description {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("Description"));
				this.ToList().ForEach(item => { item.Description = value; });
				Handler.UndoManager.EndBatch();
			}
		}
	}
  
	/// <summary>
///             Represents a data source that uses a connection string for the connection.
///             </summary>
	[TypeConverter(typeof(DynamicPropertyConverter))]
	public sealed partial class ProviderDataSource: DataSource
			, IClonableObject
	{
	    internal new TOM.ProviderDataSource MetadataObject 
		{ 
			get 
			{ 
				return base.MetadataObject as TOM.ProviderDataSource; 
		    } 
			set 
			{ 
				base.MetadataObject = value; 
			}
		}

/// <summary>
///             A string used to open the connection to the data source.
///             </summary>
		[DisplayName("Connection String")]
		[Category("Connection Details"),Description(@"A string used to open the connection to the data source."),IntelliSense(@"A string used to open the connection to the data source.")][Editor(typeof(CustomDialogEditor), typeof(System.Drawing.Design.UITypeEditor)),TypeConverter(typeof(ConnectionStringConverter))]
		public string ConnectionString {
			get {
			    return MetadataObject.ConnectionString;
			}
			set {
				
				var oldValue = ConnectionString;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.CONNECTIONSTRING, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.ConnectionString = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.CONNECTIONSTRING, oldValue, newValue));
				OnPropertyChanged(Properties.CONNECTIONSTRING, oldValue, newValue);
			}
		}
		private bool ShouldSerializeConnectionString() { return false; }
/// <summary>
///             Determines how credentials are obtained for an impersonated connection to a data source during data import or refresh.
///             </summary>
		[DisplayName("Impersonation Mode")]
		[Category("Connection Details"),Description(@"Determines how credentials are obtained for an impersonated connection to a data source during data import or refresh."),IntelliSense(@"Determines how credentials are obtained for an impersonated connection to a data source during data import or refresh.")]
		public ImpersonationMode ImpersonationMode {
			get {
			    return (ImpersonationMode)MetadataObject.ImpersonationMode;
			}
			set {
				
				var oldValue = ImpersonationMode;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.IMPERSONATIONMODE, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.ImpersonationMode = (TOM.ImpersonationMode)newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.IMPERSONATIONMODE, oldValue, newValue));
				OnPropertyChanged(Properties.IMPERSONATIONMODE, oldValue, newValue);
			}
		}
		private bool ShouldSerializeImpersonationMode() { return false; }
/// <summary>
///             The user account used for impersonation.
///             </summary>
		[DisplayName("Account")]
		[Category("Connection Details"),Description(@"The user account used for impersonation."),IntelliSense(@"The user account used for impersonation.")]
		public string Account {
			get {
			    return MetadataObject.Account;
			}
			set {
				
				var oldValue = Account;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ACCOUNT, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.Account = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.ACCOUNT, oldValue, newValue));
				OnPropertyChanged(Properties.ACCOUNT, oldValue, newValue);
			}
		}
		private bool ShouldSerializeAccount() { return false; }
/// <summary>
///             The account password.
///             </summary>
		[DisplayName("Password")]
		[Category("Connection Details"),Description(@"The account password."),IntelliSense(@"The account password.")][PasswordPropertyText(true)]
		public string Password {
			get {
			    return MetadataObject.Password;
			}
			set {
				
				var oldValue = Password;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.PASSWORD, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.Password = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.PASSWORD, oldValue, newValue));
				OnPropertyChanged(Properties.PASSWORD, oldValue, newValue);
			}
		}
		private bool ShouldSerializePassword() { return false; }
/// <summary>
///             Specifies the locking behavior of the SQL statements when executing commands against the data source. Valid values include ReadCommitted (default) which only reads from committed transactions, or Snapshot which can read any statement in a transaction that is transactionally consistent.
///             </summary>
		[DisplayName("Isolation")]
		[Category("Connection Details"),Description(@"Specifies the locking behavior of the SQL statements when executing commands against the data source. Valid values include ReadCommitted (default) which only reads from committed transactions, or Snapshot which can read any statement in a transaction that is transactionally consistent."),IntelliSense(@"Specifies the locking behavior of the SQL statements when executing commands against the data source. Valid values include ReadCommitted (default) which only reads from committed transactions, or Snapshot which can read any statement in a transaction that is transactionally consistent.")]
		public DatasourceIsolation Isolation {
			get {
			    return (DatasourceIsolation)MetadataObject.Isolation;
			}
			set {
				
				var oldValue = Isolation;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ISOLATION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.Isolation = (TOM.DatasourceIsolation)newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.ISOLATION, oldValue, newValue));
				OnPropertyChanged(Properties.ISOLATION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeIsolation() { return false; }
/// <summary>
///             The timeout in seconds for commands executed against the data source.
///             </summary>
		[DisplayName("Timeout")]
		[Category("Connection Details"),Description(@"The timeout in seconds for commands executed against the data source."),IntelliSense(@"The timeout in seconds for commands executed against the data source.")]
		public int Timeout {
			get {
			    return MetadataObject.Timeout;
			}
			set {
				
				var oldValue = Timeout;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.TIMEOUT, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.Timeout = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.TIMEOUT, oldValue, newValue));
				OnPropertyChanged(Properties.TIMEOUT, oldValue, newValue);
			}
		}
		private bool ShouldSerializeTimeout() { return false; }
/// <summary>
///             An optional string that identifies the name of the managed data provider for the data source.
///             </summary>
		[DisplayName("Provider")]
		[Category("Connection Details"),Description(@"An optional string that identifies the name of the managed data provider for the data source."),IntelliSense(@"An optional string that identifies the name of the managed data provider for the data source.")]
		public string Provider {
			get {
			    return MetadataObject.Provider;
			}
			set {
				
				var oldValue = Provider;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.PROVIDER, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.Provider = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.PROVIDER, oldValue, newValue));
				OnPropertyChanged(Properties.PROVIDER, oldValue, newValue);
			}
		}
		private bool ShouldSerializeProvider() { return false; }

		internal static ProviderDataSource CreateFromMetadata(Model parent, TOM.ProviderDataSource metadataObject) {
			var obj = new ProviderDataSource(metadataObject);
			parent.DataSources.Add(obj);
			
			obj.Init();

			return obj;
		}


		/// <summary>
		/// Creates a new ProviderDataSource and adds it to the parent Model.
		/// Also creates the underlying metadataobject and adds it to the TOM tree.
		/// </summary>
		public static ProviderDataSource CreateNew(Model parent, string name = null)
		{
			if(!parent.Handler.PowerBIGovernance.AllowCreate(typeof(ProviderDataSource))) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(ProviderDataSource).GetTypeName()));
			}

			var metadataObject = new TOM.ProviderDataSource();
			metadataObject.Name = parent.DataSources.GetNewName(string.IsNullOrWhiteSpace(name) ? "New " + typeof(ProviderDataSource).GetTypeName() : name);
            InitMetadata(metadataObject, parent);
            var obj = new ProviderDataSource(metadataObject);

			parent.DataSources.Add(obj);
			
			obj.Init();

			return obj;
		}

        static partial void InitMetadata(TOM.ProviderDataSource metadataObject, Model parent);

		/// <summary>
		/// Creates a new ProviderDataSource and adds it to the current Model.
		/// Also creates the underlying metadataobject and adds it to the TOM tree.
		/// </summary>		
		public static ProviderDataSource CreateNew(string name = null)
		{
			return CreateNew(TabularModelHandler.Singleton.Model, name);
		}


		/// <summary>
		/// Creates an exact copy of this ProviderDataSource object.
		/// </summary>
		[IntelliSense("Creates an exact copy of this ProviderDataSource object.")]
		public ProviderDataSource Clone(string newName = null) {
			if(!Handler.PowerBIGovernance.AllowCreate(this.GetType())) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(ProviderDataSource).GetTypeName()));
			}

		    Handler.BeginUpdate("Clone ProviderDataSource");

			// Create a clone of the underlying metadataobject:
			var tom = MetadataObject.Clone() as TOM.ProviderDataSource;


			// Assign a new, unique name:
			tom.Name = Parent.DataSources.GetNewName(string.IsNullOrEmpty(newName) ? tom.Name + " copy" : newName);
				
			// Create the TOM Wrapper object, representing the metadataobject
			ProviderDataSource obj = CreateFromMetadata(Parent, tom);

            Handler.EndUpdate();

            return obj;
		}

		TabularNamedObject IClonableObject.Clone(string newName, bool includeTranslations, TabularNamedObject newParent) 
		{
			if (newParent != null) throw new ArgumentException("This object can not be cloned to another parent. Argument newParent should be left as null.", "newParent");
			return Clone(newName);
		}

	
        internal override void RenewMetadataObject()
        {
            Handler.WrapperLookup.Remove(MetadataObject);
            var json = TOM.JsonSerializer.SerializeObject(MetadataObject, RenewMetadataOptions);
            MetadataObject = TOM.JsonSerializer.DeserializeObject<TOM.ProviderDataSource>(json);
            Handler.WrapperLookup.Add(MetadataObject, this);
        }

		///<summary>The parent Model of the current Provider Data Source.</summary>
		public new Model Parent { 
			get {
				return Handler.WrapperLookup[MetadataObject.Parent] as Model;
			}
		}



		/// <summary>
		/// CTOR - only called from static factory methods on the class
		/// </summary>
		ProviderDataSource(TOM.ProviderDataSource metadataObject) : base(metadataObject)
		{
		}



		internal override void Undelete(ITabularObjectCollection collection, Type tomObjectType, string tomJson) {
			base.Undelete(collection, tomObjectType, tomJson);
			Reinit();
			ReapplyReferences();
		}
		internal override sealed bool Browsable(string propertyName) {
			// Allow custom overrides to hide a property regardless of its compatibility level requirements:
			if(!base.Browsable(propertyName)) return false;

			switch (propertyName) {

				// Hide properties based on compatibility requirements (inferred from TOM):
				case Properties.PARENT:
					return false;
				
				default:
					return true;
			}
		}

    }

  
	/// <summary>
///             Represents a logical relationship between two Table objects. It is a child of a Model object.
///             </summary>
	[TypeConverter(typeof(DynamicPropertyConverter))]
	public abstract partial class Relationship: TabularNamedObject
			, IInternalAnnotationObject
			, IInternalExtendedPropertyObject
	{
	    internal new TOM.Relationship MetadataObject 
		{ 
			get 
			{ 
				return base.MetadataObject as TOM.Relationship; 
		    } 
			set 
			{ 
				base.MetadataObject = value; 
			}
		}

/// <summary>
///             Gets the destination table in a directional table relationship.
///             </summary>
		[DisplayName("To Table")]
		[Category("Options"),Description(@"Gets the destination table in a directional table relationship."),IntelliSense(@"Gets the destination table in a directional table relationship.")]
		public Table ToTable {
			get {
				if (MetadataObject.ToTable == null) return null;
			    return Handler.WrapperLookup[MetadataObject.ToTable] as Table;
            }
			
		}
		private bool ShouldSerializeToTable() { return false; }
/// <summary>
///             Gets the starting table in a directional table relationship.
///             </summary>
		[DisplayName("From Table")]
		[Category("Options"),Description(@"Gets the starting table in a directional table relationship."),IntelliSense(@"Gets the starting table in a directional table relationship.")]
		public Table FromTable {
			get {
				if (MetadataObject.FromTable == null) return null;
			    return Handler.WrapperLookup[MetadataObject.FromTable] as Table;
            }
			
		}
		private bool ShouldSerializeFromTable() { return false; }
        private bool CanClearAnnotations() => GetAnnotationsCount() > 0;
        ///<summary>Removes all annotations from this object.</summary>
        [IntelliSense("Removes all annotations from this object.")]
        public void ClearAnnotations()
        {
            Handler.BeginUpdate("Clear annotations");
            foreach(var annotation in GetAnnotations().ToList()) {
                RemoveAnnotation(annotation);
            }
            Handler.EndUpdate();
        }

		///<summary>The collection of Annotations on the current Relationship.</summary>
        [Browsable(true),NoMultiselect,Category("Metadata"),Description("The collection of Annotations on the current Relationship."),Editor(typeof(AnnotationCollectionEditor), typeof(UITypeEditor))]
        [PropertyAction(nameof(ClearAnnotations))]
		public AnnotationCollection Annotations { get; private set; }
		///<summary>Gets the value of the annotation with the given index, assuming it exists.</summary>
		[IntelliSense("Gets the value of the annotation with the given index, assuming it exists.")]
		public string GetAnnotation(int index) {
			return MetadataObject.Annotations[index].Value;
		}
		///<summary>Returns true if an annotation with the given name exists. Otherwise false.</summary>
		[IntelliSense("Returns true if an annotation with the given name exists. Otherwise false.")]
		public bool HasAnnotation(string name) {
		    return MetadataObject.Annotations.ContainsName(name);
		}
		///<summary>Gets the value of the annotation with the given name. Returns null if no such annotation exists.</summary>
		[IntelliSense("Gets the value of the annotation with the given name. Returns null if no such annotation exists.")]
		public string GetAnnotation(string name) {
		    return HasAnnotation(name) ? MetadataObject.Annotations[name].Value : null;
		}
		///<summary>Sets the value of the annotation with the given index, assuming it exists.</summary>
		[IntelliSense("Sets the value of the annotation with the given index, assuming it exists.")]
		public void SetAnnotation(int index, string value) {
		    SetAnnotation(index, value, true);
		}
		internal void SetAnnotation(int index, string value, bool undoable) {
		    var name = MetadataObject.Annotations[index].Name;
			SetAnnotation(name, value, undoable);
		}
		void IInternalAnnotationObject.SetAnnotation(int index, string value, bool undoable) {
			SetAnnotation(index, value, undoable);
		}
		///<summary>Returns a unique name for a new annotation.</summary>
		public string GetNewAnnotationName() {
			return MetadataObject.Annotations.GetNewName("New Annotation");
		}
		///<summary>Sets the value of the annotation having the given name. If no such annotation exists, it will be created. If value is set to null, the annotation will be removed.</summary>
		[IntelliSense("Sets the value of the annotation having the given name. If no such annotation exists, it will be created. If value is set to null, the annotation will be removed.")]
		public void SetAnnotation(string name, string value) {
		    SetAnnotation(name, value, true);
		}
		internal void SetAnnotation(string name, string value, bool undoable) {
			if(name == null) name = GetNewAnnotationName();

			if(value == null) {
				// Remove annotation if set to null:
				RemoveAnnotation(name, undoable);
				return;
			}

			if(undoable) {
 				if(GetAnnotation(name) == value) return;
				bool undoable2 = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + value, ref undoable2, ref cancel);
				if (cancel) return;
			}

			if(MetadataObject.Annotations.Contains(name)) {
				// Change existing annotation:

				var oldValue = GetAnnotation(name);
				MetadataObject.Annotations[name].Value = value;
				if (undoable) {
					Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, oldValue));
					OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, name + ":" + value);
				}
			} else {
				// Add new annotation:

				MetadataObject.Annotations.Add(new TOM.Annotation{ Name = name, Value = value });
				if (undoable) {
					Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, null));
					OnPropertyChanged(Properties.ANNOTATIONS, null, name + ":" + value);
				}
			}
		}
		void IInternalAnnotationObject.SetAnnotation(string name, string value, bool undoable) {
			this.SetAnnotation(name, value, undoable);
		}
		///<summary>Remove an annotation by the given name.</summary>
		[IntelliSense("Remove an annotation by the given name.")]
		public void RemoveAnnotation(string name) {
		    RemoveAnnotation(name, true);
		}
		internal void RemoveAnnotation(string name, bool undoable) {
			if(MetadataObject.Annotations.Contains(name)) {
				if(undoable) 
				{
				    bool undoable2 = true;
				    bool cancel = false;
				    OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + GetAnnotation(name), ref undoable2, ref cancel);
				    if (cancel) return;
				}

			    var oldValue = MetadataObject.Annotations[name].Value;
				MetadataObject.Annotations.Remove(name);

				if (undoable) 
				{
					Handler.UndoManager.Add(new UndoAnnotationAction(this, name, null, oldValue));
					OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, null);
			    }
			}
		}
		void IInternalAnnotationObject.RemoveAnnotation(string name, bool undoable) {
			this.RemoveAnnotation(name, undoable);
		}
		///<summary>Gets the number of annotations on the current Relationship.</summary>
		[IntelliSense("Gets the number of annotations on the current Relationship.")]
		public int GetAnnotationsCount() {
			return MetadataObject.Annotations.Count;
		}
		///<summary>Gets a collection of all annotation names on the current Relationship.</summary>
		[IntelliSense("Gets a collection of all annotation names on the current Relationship.")]
		public IEnumerable<string> GetAnnotations() {
			return MetadataObject.Annotations.Select(a => a.Name);
		}

		        private bool CanClearExtendedProperties() => GetExtendedPropertyCount() > 0;
        ///<summary>Removes all Extended Properties from this object.</summary>
        [IntelliSense("Removes all Extended Properties from this object.")]
        public void ClearExtendedProperties()
        {
            Handler.BeginUpdate("Clear extended properties");
            foreach(var extendedProperty in GetExtendedProperties().ToList()) {
                RemoveExtendedProperty(extendedProperty);
            }
            Handler.EndUpdate();
        }

		///<summary>The collection of Extended Properties on the current Relationship.</summary>
        [DisplayName("Extended Properties"),NoMultiselect,Category("Metadata"),Description("The collection of Extended Properties on the current Relationship."),Editor(typeof(ExtendedPropertyCollectionEditor), typeof(UITypeEditor))]
        [PropertyAction(nameof(ClearExtendedProperties))]
		public ExtendedPropertyCollection ExtendedProperties { get; private set; }

		///<summary>Returns true if an ExtendedProperty with the given name exists. Otherwise false.</summary>
		[IntelliSense("Returns true if an ExtendedProperty with the given name exists. Otherwise false.")]
		public bool HasExtendedProperty(string name) {
		    return MetadataObject.ExtendedProperties.ContainsName(name);
		}
		///<summary>Gets the type of the ExtendedProperty with the given index, assuming it exists.</summary>
		public ExtendedPropertyType GetExtendedPropertyType(int index) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[index].Type;
		}
		///<summary>Gets the type of the ExtendedProperty with the given name, assuming it exists.</summary>
		public ExtendedPropertyType GetExtendedPropertyType(string name) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[name].Type;
		}
		///<summary>Gets the value of the ExtendedProperty with the given index, assuming it exists.</summary>
		public string GetExtendedProperty(int index) {
			var ep = MetadataObject.ExtendedProperties[index];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		///<summary>Gets the value of the ExtendedProperty with the given name. Returns null if no such ExtendedProperty exists.</summary>
		[IntelliSense("Gets the value of the ExtendedProperty with the given name. Returns null if no such ExtendedProperty exists.")]
		public string GetExtendedProperty(string name) {
		    if(!HasExtendedProperty(name)) return null;
			var ep = MetadataObject.ExtendedProperties[name];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		///<summary>Sets the value of the ExtendedProperty with the given index, optionally specifiying the type (string or JSON) of the ExtendedProperty.</summary>
		public void SetExtendedProperty(int index, string value, ExtendedPropertyType type) {
			SetExtendedProperty(index, value, type, true);
		}
		void IInternalExtendedPropertyObject.SetExtendedProperty(int index, string value, ExtendedPropertyType type, bool undoable) {
			SetExtendedProperty(index, value, type, undoable);
		}
		internal void SetExtendedProperty(int index, string value, ExtendedPropertyType type, bool undoable) {
			var name = MetadataObject.ExtendedProperties[index].Name;
			SetExtendedProperty(name, value, type, undoable);
		}
		///<summary>Returns a unique name for a new ExtendedProperty.</summary>
		public string GetNewExtendedPropertyName() {
			return MetadataObject.ExtendedProperties.GetNewName("New ExtendedProperty");
		}
		///<summary>Sets the value of the ExtendedProperty having the given name. If no such ExtendedProperty exists, it will be created. If value is set to null, the ExtendedProperty will be removed.</summary>
		[IntelliSense("Sets the value of the ExtendedProperty having the given name. If no such ExtendedProperty exists, it will be created. If value is set to null, the ExtendedProperty will be removed.")]
		public void SetExtendedProperty(string name, string value, ExtendedPropertyType type) {
			SetExtendedProperty(name, value, type, true);
		}
		internal void SetExtendedProperty(string name, string value, ExtendedPropertyType type, bool undoable) {
			if(name == null) name = GetNewExtendedPropertyName();

			if(value == null) {
				// Remove ExtendedProperty if set to null:
				RemoveExtendedProperty(name);
				return;
			}

			if(GetExtendedProperty(name) == value) return;
			if(undoable) {
				bool cancel = false;
				OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + value, ref undoable, ref cancel);
				if (cancel) return;
			}

			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Change existing ExtendedProperty:
				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				var ep = MetadataObject.ExtendedProperties[name];
				if (ep is TOM.JsonExtendedProperty)
					(ep as TOM.JsonExtendedProperty).Value = value;
				else 
					(ep as TOM.StringExtendedProperty).Value = value;
					
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, name + ":" + value);
			} else {
				// Add new ExtendedProperty:
				if (type == ExtendedPropertyType.Json)
					MetadataObject.ExtendedProperties.Add(new TOM.JsonExtendedProperty{ Name = name, Value = value });
				else
					MetadataObject.ExtendedProperties.Add(new TOM.StringExtendedProperty{ Name = name, Value = value });

				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, null, type));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, null, name + ":" + value);
			}
		}
		void IInternalExtendedPropertyObject.SetExtendedProperty(string name, string value, ExtendedPropertyType type, bool undoable) {
			this.SetExtendedProperty(name, value, type, undoable);
		}

		///<summary>Remove an ExtendedProperty by the given name.</summary>
		[IntelliSense("Remove an ExtendedProperty by the given name.")]
		public void RemoveExtendedProperty(string name) {
			RemoveExtendedProperty(name, true);
		}

		internal void RemoveExtendedProperty(string name, bool undoable) {
			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Get current value:
				if(undoable) {
					bool cancel = false;
					OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + GetExtendedProperty(name), ref undoable, ref cancel);
					if (cancel) return;
				}

				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				MetadataObject.ExtendedProperties.Remove(name);

				// Undo-handling:
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, null, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, null);
			}
		}
		void IInternalExtendedPropertyObject.RemoveExtendedProperty(string name, bool undoable) {
			this.RemoveExtendedProperty(name, undoable);
		}
		///<summary>Gets the number of ExtendedProperties on the current object.</summary>
		[IntelliSense("Gets the number of ExtendedProperties on the current object.")]
		public int GetExtendedPropertyCount() {
			return MetadataObject.ExtendedProperties.Count;
		}
		///<summary>Gets a collection of all ExtendedProperty names on the current object.</summary>
		[IntelliSense("Gets a collection of all ExtendedProperty names on the current object.")]
		public IEnumerable<string> GetExtendedProperties() {
			return MetadataObject.ExtendedProperties.Select(a => a.Name);
		}

		/// <summary>
///             A boolean value that indicates whether the relationship is marked as Active or Inactive. An Active relationship is automatically used for filtering across tables. An Inactive relationship can be used explicitly by DAX calculations with the USERELATIONSHIP function.
///             </summary>
		[DisplayName("Active")]
		[Category("Basic"),Description(@"A boolean value that indicates whether the relationship is marked as Active or Inactive. An Active relationship is automatically used for filtering across tables. An Inactive relationship can be used explicitly by DAX calculations with the USERELATIONSHIP function."),IntelliSense(@"A boolean value that indicates whether the relationship is marked as Active or Inactive. An Active relationship is automatically used for filtering across tables. An Inactive relationship can be used explicitly by DAX calculations with the USERELATIONSHIP function.")]
		public bool IsActive {
			get {
			    return MetadataObject.IsActive;
			}
			set {
				
				var oldValue = IsActive;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ISACTIVE, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.IsActive = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.ISACTIVE, oldValue, newValue));
				OnPropertyChanged(Properties.ISACTIVE, oldValue, newValue);
			}
		}
		private bool ShouldSerializeIsActive() { return false; }
/// <summary>
///             The type of Relationship. At present, the only possible value is SingleColumn (1) or a normal column-column relationship.
///             </summary>
		[DisplayName("Type")]
		[Category("Options"),Description(@"The type of Relationship. At present, the only possible value is SingleColumn (1) or a normal column-column relationship."),IntelliSense(@"The type of Relationship. At present, the only possible value is SingleColumn (1) or a normal column-column relationship.")]
		public RelationshipType Type {
			get {
			    return (RelationshipType)MetadataObject.Type;
			}
			
		}
		private bool ShouldSerializeType() { return false; }
/// <summary>
///             Indicates how relationships influence filtering of data. The enumeration defines the possible behaviors. Possible values are as follows. OneDirection (1) The rows selected in the 'To' end of the relationship will automatically filter scans of the table in the 'From' end of the relationship. BothDirections (2) Filters on either end of the relationship will automatically filter the other table. Automatic (3) The engine will analyze the relationships and choose one of the behaviors by using heuristics.
///             </summary>
		[DisplayName("Cross Filtering Behavior")]
		[Category("Options"),Description(@"Indicates how relationships influence filtering of data. The enumeration defines the possible behaviors. Possible values are as follows. OneDirection (1) The rows selected in the 'To' end of the relationship will automatically filter scans of the table in the 'From' end of the relationship. BothDirections (2) Filters on either end of the relationship will automatically filter the other table. Automatic (3) The engine will analyze the relationships and choose one of the behaviors by using heuristics."),IntelliSense(@"Indicates how relationships influence filtering of data. The enumeration defines the possible behaviors. Possible values are as follows. OneDirection (1) The rows selected in the 'To' end of the relationship will automatically filter scans of the table in the 'From' end of the relationship. BothDirections (2) Filters on either end of the relationship will automatically filter the other table. Automatic (3) The engine will analyze the relationships and choose one of the behaviors by using heuristics.")]
		public CrossFilteringBehavior CrossFilteringBehavior {
			get {
			    return (CrossFilteringBehavior)MetadataObject.CrossFilteringBehavior;
			}
			set {
				
				var oldValue = CrossFilteringBehavior;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.CROSSFILTERINGBEHAVIOR, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.CrossFilteringBehavior = (TOM.CrossFilteringBehavior)newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.CROSSFILTERINGBEHAVIOR, oldValue, newValue));
				OnPropertyChanged(Properties.CROSSFILTERINGBEHAVIOR, oldValue, newValue);
			}
		}
		private bool ShouldSerializeCrossFilteringBehavior() { return false; }
/// <summary>
///             When joining two date time columns, indicates whether to join on date and time parts, or on date part only. DateAndTime (1) When joining two date time columns, join on date and time parts. DatePartOnly (2) When joining two date time columns, join on date part only.
///             </summary>
		[DisplayName("Join On Date Behavior")]
		[Category("Options"),Description(@"When joining two date time columns, indicates whether to join on date and time parts, or on date part only. DateAndTime (1) When joining two date time columns, join on date and time parts. DatePartOnly (2) When joining two date time columns, join on date part only."),IntelliSense(@"When joining two date time columns, indicates whether to join on date and time parts, or on date part only. DateAndTime (1) When joining two date time columns, join on date and time parts. DatePartOnly (2) When joining two date time columns, join on date part only.")]
		public DateTimeRelationshipBehavior JoinOnDateBehavior {
			get {
			    return (DateTimeRelationshipBehavior)MetadataObject.JoinOnDateBehavior;
			}
			set {
				
				var oldValue = JoinOnDateBehavior;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.JOINONDATEBEHAVIOR, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.JoinOnDateBehavior = (TOM.DateTimeRelationshipBehavior)newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.JOINONDATEBEHAVIOR, oldValue, newValue));
				OnPropertyChanged(Properties.JOINONDATEBEHAVIOR, oldValue, newValue);
			}
		}
		private bool ShouldSerializeJoinOnDateBehavior() { return false; }
/// <summary>
///             Unused; reserved for future use.
///             </summary>
		[DisplayName("Rely On Referential Integrity")]
		[Category("Options"),Description(@"If set to 'True', queries generated in DirectQuery mode will use INNER JOIN rather than OUTER JOIN."),IntelliSense(@"If set to 'True', queries generated in DirectQuery mode will use INNER JOIN rather than OUTER JOIN.")]
		public bool RelyOnReferentialIntegrity {
			get {
			    return MetadataObject.RelyOnReferentialIntegrity;
			}
			set {
				
				var oldValue = RelyOnReferentialIntegrity;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.RELYONREFERENTIALINTEGRITY, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.RelyOnReferentialIntegrity = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.RELYONREFERENTIALINTEGRITY, oldValue, newValue));
				OnPropertyChanged(Properties.RELYONREFERENTIALINTEGRITY, oldValue, newValue);
			}
		}
		private bool ShouldSerializeRelyOnReferentialIntegrity() { return false; }
/// <summary>
///             Provides information on the state of the relationship. Possible values and their interpretation are as follows. Ready (1) The relationship is queryable and has up-to-date data. NoData (3) Not applicable to relationships. CalculationNeeded (4) The relationship does not contain any data because it was not refreshed. There is no error associated with the relationship. SemanticError (5) Not applicable to Relationship. EvaluationError (6) Not applicable to Relationship. DependencyError (7) A dependency associated with this relationship is in an error state (SemanticError, EvaluationError, or DependencyError). Incomplete (8) Not applicable to relationships. SyntaxError (9) Not applicable to relationships.
///             </summary>
		[DisplayName("State")]
		[Category("Metadata"),Description(@"Provides information on the state of the relationship. Possible values and their interpretation are as follows. Ready (1) The relationship is queryable and has up-to-date data. NoData (3) Not applicable to relationships. CalculationNeeded (4) The relationship does not contain any data because it was not refreshed. There is no error associated with the relationship. SemanticError (5) Not applicable to Relationship. EvaluationError (6) Not applicable to Relationship. DependencyError (7) A dependency associated with this relationship is in an error state (SemanticError, EvaluationError, or DependencyError). Incomplete (8) Not applicable to relationships. SyntaxError (9) Not applicable to relationships."),IntelliSense(@"Provides information on the state of the relationship. Possible values and their interpretation are as follows. Ready (1) The relationship is queryable and has up-to-date data. NoData (3) Not applicable to relationships. CalculationNeeded (4) The relationship does not contain any data because it was not refreshed. There is no error associated with the relationship. SemanticError (5) Not applicable to Relationship. EvaluationError (6) Not applicable to Relationship. DependencyError (7) A dependency associated with this relationship is in an error state (SemanticError, EvaluationError, or DependencyError). Incomplete (8) Not applicable to relationships. SyntaxError (9) Not applicable to relationships.")]
		public ObjectState State {
			get {
			    return (ObjectState)MetadataObject.State;
			}
			
		}
		private bool ShouldSerializeState() { return false; }
/// <summary>
///             Indicates how relationships influence filtering of data when evaluating row-level security expressions. Possible values are as follows. OneDirection (1): The rows selected in the 'To' end of the relationship will automatically filter scans of the table in the 'From' end of the relationship. BothDirections (2): Filters on either end of the relationship will automatically filter the other table.
///             </summary>
		[DisplayName("Security Filtering Behavior")]
		[Category("Options"),Description(@"Indicates how relationships influence filtering of data when evaluating row-level security expressions. Possible values are as follows. OneDirection (1): The rows selected in the 'To' end of the relationship will automatically filter scans of the table in the 'From' end of the relationship. BothDirections (2): Filters on either end of the relationship will automatically filter the other table."),IntelliSense(@"Indicates how relationships influence filtering of data when evaluating row-level security expressions. Possible values are as follows. OneDirection (1): The rows selected in the 'To' end of the relationship will automatically filter scans of the table in the 'From' end of the relationship. BothDirections (2): Filters on either end of the relationship will automatically filter the other table.")]
		public SecurityFilteringBehavior SecurityFilteringBehavior {
			get {
			    return (SecurityFilteringBehavior)MetadataObject.SecurityFilteringBehavior;
			}
			set {
				
				var oldValue = SecurityFilteringBehavior;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.SECURITYFILTERINGBEHAVIOR, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.SecurityFilteringBehavior = (TOM.SecurityFilteringBehavior)newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.SECURITYFILTERINGBEHAVIOR, oldValue, newValue));
				OnPropertyChanged(Properties.SECURITYFILTERINGBEHAVIOR, oldValue, newValue);
			}
		}
		private bool ShouldSerializeSecurityFilteringBehavior() { return false; }

	
        internal override void RenewMetadataObject()
        {
            Handler.WrapperLookup.Remove(MetadataObject);
            var json = TOM.JsonSerializer.SerializeObject(MetadataObject, RenewMetadataOptions);
            MetadataObject = TOM.JsonSerializer.DeserializeObject<TOM.Relationship>(json);
            Handler.WrapperLookup.Add(MetadataObject, this);
        }

		///<summary>The parent Model of the current Relationship.</summary>
		public Model Parent { 
			get {
				return Handler.WrapperLookup[MetadataObject.Parent] as Model;
			}
		}



		/// <summary>
		/// CTOR - only called from static factory methods on the class
		/// </summary>
		protected Relationship(TOM.Relationship metadataObject) : base(metadataObject)
		{
			
			// Create indexer for annotations:
			Annotations = new AnnotationCollection(this);
			
			// Create indexer for extended properties:
			ExtendedProperties = new ExtendedPropertyCollection(this);
		}



		internal override void Undelete(ITabularObjectCollection collection, Type tomObjectType, string tomJson) {
			base.Undelete(collection, tomObjectType, tomJson);
			Reinit();
			ReapplyReferences();
		}
		internal override bool Browsable(string propertyName) {
			// Allow custom overrides to hide a property regardless of its compatibility level requirements:
			if(!base.Browsable(propertyName)) return false;

			switch (propertyName) {

				// Hide properties based on compatibility requirements (inferred from TOM):
				case Properties.EXTENDEDPROPERTIES:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1400 : Handler.CompatibilityLevel >= 1400;
				case Properties.PARENT:
					return false;
				
				default:
					return true;
			}
		}

    }


	/// <summary>
	/// Collection class for Relationship. Provides convenient properties for setting a property on multiple objects at once.
	/// </summary>
	public sealed partial class RelationshipCollection: TabularObjectCollection<SingleColumnRelationship>
	{
		internal Model Model { get { return Parent as Model; } }
		TOM.RelationshipCollection TOM_Collection;
		internal RelationshipCollection(string collectionName, TOM.RelationshipCollection metadataObjectCollection, Model parent) : base(collectionName, parent)
		{
			TOM_Collection = metadataObjectCollection;
		}
		internal override Type GetItemType() { return typeof(Relationship); }
        internal override void TOM_Add(TOM.MetadataObject obj) { TOM_Collection.Add(obj as TOM.Relationship); }
        internal override bool TOM_Contains(TOM.MetadataObject obj) { return TOM_Collection.Contains(obj as TOM.Relationship); }
        internal override void TOM_Remove(TOM.MetadataObject obj) { TOM_Collection.Remove(obj as TOM.Relationship); }
        internal override void TOM_Clear() { TOM_Collection.Clear(); }
        internal override bool TOM_ContainsName(string name) { return TOM_Collection.ContainsName(name); }
		internal override TOM.MetadataObject TOM_Get(int index) { return TOM_Collection[index]; }
        internal override TOM.MetadataObject TOM_Get(string name) { return TOM_Collection[name]; }
        internal override TOM.MetadataObject TOM_Find(string name) { return TOM_Collection.Find(name); }
 
		internal override string GetNewName(string prefix = null) { return Guid.NewGuid().ToString(); }
        internal override int IndexOf(TOM.MetadataObject obj) { return TOM_Collection.IndexOf(obj as TOM.Relationship); }
        /// <summary>The number of items in this collection.</summary>
		public override int Count { get { return TOM_Collection.Count; } }
		/// <summary>Returns an enumerator that iterates through the collection.</summary>
        public override IEnumerator<SingleColumnRelationship> GetEnumerator() { return TOM_Collection.Select(h => Handler.WrapperLookup[h]).OfType<SingleColumnRelationship>().GetEnumerator(); }
		internal override void Reinit() {
			var ixOffset = 0;
			for(int i = 0; i < Count; i++) {
				var metadataObj = TOM_Get(i) as TOM.Relationship;
				var item = Handler.WrapperLookup.TryGetValue(metadataObj, out var existingItem) ? existingItem as Relationship : CreateFromMetadata(metadataObj);
				Handler.WrapperLookup.Remove(item.MetadataObject);
				item.MetadataObject = Model.MetadataObject.Relationships[i + ixOffset] as TOM.SingleColumnRelationship;
				Handler.WrapperLookup.Add(item.MetadataObject, item);
				item.Collection = this;
			}
			TOM_Collection = Model.MetadataObject.Relationships;
			foreach(var item in this) item.Reinit();
		}

		internal override void ReapplyReferences() {
			foreach(var item in this) item.ReapplyReferences();
		}

		private Relationship CreateFromMetadata(TOM.Relationship obj)
		{
			if(obj is TOM.SingleColumnRelationship singlecolumnrelationshipObj) return SingleColumnRelationship.CreateFromMetadata(Model, singlecolumnrelationshipObj);
		    return null;
		}

		/// <summary>
		/// Calling this method will populate the RelationshipCollection with objects based on the MetadataObjects in the corresponding MetadataObjectCollection.
		/// </summary>
		internal override void CreateChildrenFromMetadata()
		{
			// Construct child objects (they are automatically added to the Handler's WrapperLookup dictionary):
			foreach(var obj in TOM_Collection)
			{
				CreateFromMetadata(obj);
			}
		}

		/// <summary>
		/// Sets the IsActive property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the IsActive property of all objects in the collection at once.")]
		public bool IsActive {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("IsActive"));
				this.ToList().ForEach(item => { item.IsActive = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the CrossFilteringBehavior property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the CrossFilteringBehavior property of all objects in the collection at once.")]
		public CrossFilteringBehavior CrossFilteringBehavior {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("CrossFilteringBehavior"));
				this.ToList().ForEach(item => { item.CrossFilteringBehavior = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the JoinOnDateBehavior property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the JoinOnDateBehavior property of all objects in the collection at once.")]
		public DateTimeRelationshipBehavior JoinOnDateBehavior {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("JoinOnDateBehavior"));
				this.ToList().ForEach(item => { item.JoinOnDateBehavior = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the RelyOnReferentialIntegrity property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the RelyOnReferentialIntegrity property of all objects in the collection at once.")]
		public bool RelyOnReferentialIntegrity {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("RelyOnReferentialIntegrity"));
				this.ToList().ForEach(item => { item.RelyOnReferentialIntegrity = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the SecurityFilteringBehavior property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the SecurityFilteringBehavior property of all objects in the collection at once.")]
		public SecurityFilteringBehavior SecurityFilteringBehavior {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("SecurityFilteringBehavior"));
				this.ToList().ForEach(item => { item.SecurityFilteringBehavior = value; });
				Handler.UndoManager.EndBatch();
			}
		}
	}
  
	/// <summary>
///             SingleColumnRelationship object.
///             </summary>
	[TypeConverter(typeof(DynamicPropertyConverter))]
	public sealed partial class SingleColumnRelationship: Relationship
			, IClonableObject
	{
	    internal new TOM.SingleColumnRelationship MetadataObject 
		{ 
			get 
			{ 
				return base.MetadataObject as TOM.SingleColumnRelationship; 
		    } 
			set 
			{ 
				base.MetadataObject = value; 
			}
		}

/// <summary>
///             Gets or sets the starting column in a single column relationship.
///             </summary>
		[DisplayName("From Column")]
		[Category("Basic"),Description(@"Gets or sets the starting column in a single column relationship."),IntelliSense(@"Gets or sets the starting column in a single column relationship.")][TypeConverter(typeof(AllColumnConverter))]
		public Column FromColumn {
			get {
				if (MetadataObject.FromColumn == null) return null;
			    return Handler.WrapperLookup[MetadataObject.FromColumn] as Column;
            }
			set {
				
				var oldValue = FromColumn;
				var newValue = value;
				if (oldValue?.MetadataObject == newValue?.MetadataObject) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.FROMCOLUMN, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.FromColumn = value?.MetadataObject;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.FROMCOLUMN, oldValue, newValue));
				OnPropertyChanged(Properties.FROMCOLUMN, oldValue, newValue);
			}
		}
		private bool ShouldSerializeFromColumn() { return false; }
/// <summary>
///             Gets or sets the destination column in a single column relationship.
///             </summary>
		[DisplayName("To Column")]
		[Category("Basic"),Description(@"Gets or sets the destination column in a single column relationship."),IntelliSense(@"Gets or sets the destination column in a single column relationship.")][TypeConverter(typeof(AllColumnConverter))]
		public Column ToColumn {
			get {
				if (MetadataObject.ToColumn == null) return null;
			    return Handler.WrapperLookup[MetadataObject.ToColumn] as Column;
            }
			set {
				
				var oldValue = ToColumn;
				var newValue = value;
				if (oldValue?.MetadataObject == newValue?.MetadataObject) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.TOCOLUMN, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.ToColumn = value?.MetadataObject;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.TOCOLUMN, oldValue, newValue));
				OnPropertyChanged(Properties.TOCOLUMN, oldValue, newValue);
			}
		}
		private bool ShouldSerializeToColumn() { return false; }
/// <summary>
///             Indicates whether the "From" end of the relationship has a cardinality of One (1) or Many (2).
///             </summary>
		[DisplayName("From Cardinality")]
		[Category("Basic"),Description(@"Indicates whether the ""From"" end of the relationship has a cardinality of One (1) or Many (2)."),IntelliSense(@"Indicates whether the ""From"" end of the relationship has a cardinality of One (1) or Many (2).")]
		public RelationshipEndCardinality FromCardinality {
			get {
			    return (RelationshipEndCardinality)MetadataObject.FromCardinality;
			}
			set {
				
				var oldValue = FromCardinality;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.FROMCARDINALITY, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.FromCardinality = (TOM.RelationshipEndCardinality)newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.FROMCARDINALITY, oldValue, newValue));
				OnPropertyChanged(Properties.FROMCARDINALITY, oldValue, newValue);
			}
		}
		private bool ShouldSerializeFromCardinality() { return false; }
/// <summary>
///             Indicates whether the "To" end of the relationship has a cardinality of One (1) or Many (2).
///             </summary>
		[DisplayName("To Cardinality")]
		[Category("Basic"),Description(@"Indicates whether the ""To"" end of the relationship has a cardinality of One (1) or Many (2)."),IntelliSense(@"Indicates whether the ""To"" end of the relationship has a cardinality of One (1) or Many (2).")]
		public RelationshipEndCardinality ToCardinality {
			get {
			    return (RelationshipEndCardinality)MetadataObject.ToCardinality;
			}
			set {
				
				var oldValue = ToCardinality;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.TOCARDINALITY, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.ToCardinality = (TOM.RelationshipEndCardinality)newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.TOCARDINALITY, oldValue, newValue));
				OnPropertyChanged(Properties.TOCARDINALITY, oldValue, newValue);
			}
		}
		private bool ShouldSerializeToCardinality() { return false; }

		internal static SingleColumnRelationship CreateFromMetadata(Model parent, TOM.SingleColumnRelationship metadataObject) {
			var obj = new SingleColumnRelationship(metadataObject);
			parent.Relationships.Add(obj);
			
			obj.Init();

			return obj;
		}


		/// <summary>
		/// Creates a new SingleColumnRelationship and adds it to the parent Model.
		/// Also creates the underlying metadataobject and adds it to the TOM tree.
		/// </summary>
		public static SingleColumnRelationship CreateNew(Model parent, string name = null)
		{
			if(!parent.Handler.PowerBIGovernance.AllowCreate(typeof(SingleColumnRelationship))) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(SingleColumnRelationship).GetTypeName()));
			}

			var metadataObject = new TOM.SingleColumnRelationship();
			metadataObject.Name = parent.Relationships.GetNewName(string.IsNullOrWhiteSpace(name) ? "New " + typeof(SingleColumnRelationship).GetTypeName() : name);
            InitMetadata(metadataObject, parent);
            var obj = new SingleColumnRelationship(metadataObject);

			parent.Relationships.Add(obj);
			
			obj.Init();

			return obj;
		}

        static partial void InitMetadata(TOM.SingleColumnRelationship metadataObject, Model parent);

		/// <summary>
		/// Creates a new SingleColumnRelationship and adds it to the current Model.
		/// Also creates the underlying metadataobject and adds it to the TOM tree.
		/// </summary>		
		public static SingleColumnRelationship CreateNew(string name = null)
		{
			return CreateNew(TabularModelHandler.Singleton.Model, name);
		}


		/// <summary>
		/// Creates an exact copy of this SingleColumnRelationship object.
		/// </summary>
		[IntelliSense("Creates an exact copy of this SingleColumnRelationship object.")]
		public SingleColumnRelationship Clone(string newName = null) {
			if(!Handler.PowerBIGovernance.AllowCreate(this.GetType())) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(SingleColumnRelationship).GetTypeName()));
			}

		    Handler.BeginUpdate("Clone SingleColumnRelationship");

			// Create a clone of the underlying metadataobject:
			var tom = MetadataObject.Clone() as TOM.SingleColumnRelationship;


			// Assign a new, unique name:
			tom.Name = Parent.Relationships.GetNewName(string.IsNullOrEmpty(newName) ? tom.Name + " copy" : newName);
				
			// Create the TOM Wrapper object, representing the metadataobject
			SingleColumnRelationship obj = CreateFromMetadata(Parent, tom);

            Handler.EndUpdate();

            return obj;
		}

		TabularNamedObject IClonableObject.Clone(string newName, bool includeTranslations, TabularNamedObject newParent) 
		{
			if (newParent != null) throw new ArgumentException("This object can not be cloned to another parent. Argument newParent should be left as null.", "newParent");
			return Clone(newName);
		}

	
        internal override void RenewMetadataObject()
        {
            Handler.WrapperLookup.Remove(MetadataObject);
            var json = TOM.JsonSerializer.SerializeObject(MetadataObject, RenewMetadataOptions);
            MetadataObject = TOM.JsonSerializer.DeserializeObject<TOM.SingleColumnRelationship>(json);
            Handler.WrapperLookup.Add(MetadataObject, this);
        }

		///<summary>The parent Model of the current Single Column Relationship.</summary>
		public new Model Parent { 
			get {
				return Handler.WrapperLookup[MetadataObject.Parent] as Model;
			}
		}



		/// <summary>
		/// CTOR - only called from static factory methods on the class
		/// </summary>
		SingleColumnRelationship(TOM.SingleColumnRelationship metadataObject) : base(metadataObject)
		{
		}



		internal override void Undelete(ITabularObjectCollection collection, Type tomObjectType, string tomJson) {
			base.Undelete(collection, tomObjectType, tomJson);
			Reinit();
			ReapplyReferences();
		}
		internal override sealed bool Browsable(string propertyName) {
			// Allow custom overrides to hide a property regardless of its compatibility level requirements:
			if(!base.Browsable(propertyName)) return false;

			switch (propertyName) {

				// Hide properties based on compatibility requirements (inferred from TOM):
				case Properties.PARENT:
					return false;
				
				default:
					return true;
			}
		}

    }

  
	/// <summary>
///             Represents a Table in the data model. A Table object is a member of the <see cref="T:TabularEditor.TOMWrapper.TableCollection" /> object under a <see cref="T:TabularEditor.TOMWrapper.Model" /> object. It contains a <see cref="T:TabularEditor.TOMWrapper.ColumnCollection" />. Rows are based on <see cref="T:TabularEditor.TOMWrapper.Partition" /> object or a <see cref="T:TabularEditor.TOMWrapper.CalculatedPartitionSource" /> if the Table is a calculated table.
///             </summary>
	[TypeConverter(typeof(DynamicPropertyConverter))]
	public partial class Table: TabularNamedObject
			, IHideableObject
			, IDescriptionObject
			, ILineageTagObject
			, IInternalAnnotationObject
			, IInternalExtendedPropertyObject
			, IInternalTabularPerspectiveObject
			, IInternalTranslatableObject
			, ISynonymObject
			, IClonableObject
	{
	    internal new TOM.Table MetadataObject 
		{ 
			get 
			{ 
				return base.MetadataObject as TOM.Table; 
		    } 
			set 
			{ 
				base.MetadataObject = value; 
			}
		}

        private bool CanClearAnnotations() => GetAnnotationsCount() > 0;
        ///<summary>Removes all annotations from this object.</summary>
        [IntelliSense("Removes all annotations from this object.")]
        public void ClearAnnotations()
        {
            Handler.BeginUpdate("Clear annotations");
            foreach(var annotation in GetAnnotations().ToList()) {
                RemoveAnnotation(annotation);
            }
            Handler.EndUpdate();
        }

		///<summary>The collection of Annotations on the current Table.</summary>
        [Browsable(true),NoMultiselect,Category("Metadata"),Description("The collection of Annotations on the current Table."),Editor(typeof(AnnotationCollectionEditor), typeof(UITypeEditor))]
        [PropertyAction(nameof(ClearAnnotations))]
		public AnnotationCollection Annotations { get; private set; }
		///<summary>Gets the value of the annotation with the given index, assuming it exists.</summary>
		[IntelliSense("Gets the value of the annotation with the given index, assuming it exists.")]
		public string GetAnnotation(int index) {
			return MetadataObject.Annotations[index].Value;
		}
		///<summary>Returns true if an annotation with the given name exists. Otherwise false.</summary>
		[IntelliSense("Returns true if an annotation with the given name exists. Otherwise false.")]
		public bool HasAnnotation(string name) {
		    return MetadataObject.Annotations.ContainsName(name);
		}
		///<summary>Gets the value of the annotation with the given name. Returns null if no such annotation exists.</summary>
		[IntelliSense("Gets the value of the annotation with the given name. Returns null if no such annotation exists.")]
		public string GetAnnotation(string name) {
		    return HasAnnotation(name) ? MetadataObject.Annotations[name].Value : null;
		}
		///<summary>Sets the value of the annotation with the given index, assuming it exists.</summary>
		[IntelliSense("Sets the value of the annotation with the given index, assuming it exists.")]
		public void SetAnnotation(int index, string value) {
		    SetAnnotation(index, value, true);
		}
		internal void SetAnnotation(int index, string value, bool undoable) {
		    var name = MetadataObject.Annotations[index].Name;
			SetAnnotation(name, value, undoable);
		}
		void IInternalAnnotationObject.SetAnnotation(int index, string value, bool undoable) {
			SetAnnotation(index, value, undoable);
		}
		///<summary>Returns a unique name for a new annotation.</summary>
		public string GetNewAnnotationName() {
			return MetadataObject.Annotations.GetNewName("New Annotation");
		}
		///<summary>Sets the value of the annotation having the given name. If no such annotation exists, it will be created. If value is set to null, the annotation will be removed.</summary>
		[IntelliSense("Sets the value of the annotation having the given name. If no such annotation exists, it will be created. If value is set to null, the annotation will be removed.")]
		public void SetAnnotation(string name, string value) {
		    SetAnnotation(name, value, true);
		}
		internal void SetAnnotation(string name, string value, bool undoable) {
			if(name == null) name = GetNewAnnotationName();

			if(value == null) {
				// Remove annotation if set to null:
				RemoveAnnotation(name, undoable);
				return;
			}

			if(undoable) {
 				if(GetAnnotation(name) == value) return;
				bool undoable2 = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + value, ref undoable2, ref cancel);
				if (cancel) return;
			}

			if(MetadataObject.Annotations.Contains(name)) {
				// Change existing annotation:

				var oldValue = GetAnnotation(name);
				MetadataObject.Annotations[name].Value = value;
				if (undoable) {
					Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, oldValue));
					OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, name + ":" + value);
				}
			} else {
				// Add new annotation:

				MetadataObject.Annotations.Add(new TOM.Annotation{ Name = name, Value = value });
				if (undoable) {
					Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, null));
					OnPropertyChanged(Properties.ANNOTATIONS, null, name + ":" + value);
				}
			}
		}
		void IInternalAnnotationObject.SetAnnotation(string name, string value, bool undoable) {
			this.SetAnnotation(name, value, undoable);
		}
		///<summary>Remove an annotation by the given name.</summary>
		[IntelliSense("Remove an annotation by the given name.")]
		public void RemoveAnnotation(string name) {
		    RemoveAnnotation(name, true);
		}
		internal void RemoveAnnotation(string name, bool undoable) {
			if(MetadataObject.Annotations.Contains(name)) {
				if(undoable) 
				{
				    bool undoable2 = true;
				    bool cancel = false;
				    OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + GetAnnotation(name), ref undoable2, ref cancel);
				    if (cancel) return;
				}

			    var oldValue = MetadataObject.Annotations[name].Value;
				MetadataObject.Annotations.Remove(name);

				if (undoable) 
				{
					Handler.UndoManager.Add(new UndoAnnotationAction(this, name, null, oldValue));
					OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, null);
			    }
			}
		}
		void IInternalAnnotationObject.RemoveAnnotation(string name, bool undoable) {
			this.RemoveAnnotation(name, undoable);
		}
		///<summary>Gets the number of annotations on the current Table.</summary>
		[IntelliSense("Gets the number of annotations on the current Table.")]
		public int GetAnnotationsCount() {
			return MetadataObject.Annotations.Count;
		}
		///<summary>Gets a collection of all annotation names on the current Table.</summary>
		[IntelliSense("Gets a collection of all annotation names on the current Table.")]
		public IEnumerable<string> GetAnnotations() {
			return MetadataObject.Annotations.Select(a => a.Name);
		}

		        private bool CanClearExtendedProperties() => GetExtendedPropertyCount() > 0;
        ///<summary>Removes all Extended Properties from this object.</summary>
        [IntelliSense("Removes all Extended Properties from this object.")]
        public void ClearExtendedProperties()
        {
            Handler.BeginUpdate("Clear extended properties");
            foreach(var extendedProperty in GetExtendedProperties().ToList()) {
                RemoveExtendedProperty(extendedProperty);
            }
            Handler.EndUpdate();
        }

		///<summary>The collection of Extended Properties on the current Table.</summary>
        [DisplayName("Extended Properties"),NoMultiselect,Category("Metadata"),Description("The collection of Extended Properties on the current Table."),Editor(typeof(ExtendedPropertyCollectionEditor), typeof(UITypeEditor))]
        [PropertyAction(nameof(ClearExtendedProperties))]
		public ExtendedPropertyCollection ExtendedProperties { get; private set; }

		///<summary>Returns true if an ExtendedProperty with the given name exists. Otherwise false.</summary>
		[IntelliSense("Returns true if an ExtendedProperty with the given name exists. Otherwise false.")]
		public bool HasExtendedProperty(string name) {
		    return MetadataObject.ExtendedProperties.ContainsName(name);
		}
		///<summary>Gets the type of the ExtendedProperty with the given index, assuming it exists.</summary>
		public ExtendedPropertyType GetExtendedPropertyType(int index) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[index].Type;
		}
		///<summary>Gets the type of the ExtendedProperty with the given name, assuming it exists.</summary>
		public ExtendedPropertyType GetExtendedPropertyType(string name) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[name].Type;
		}
		///<summary>Gets the value of the ExtendedProperty with the given index, assuming it exists.</summary>
		public string GetExtendedProperty(int index) {
			var ep = MetadataObject.ExtendedProperties[index];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		///<summary>Gets the value of the ExtendedProperty with the given name. Returns null if no such ExtendedProperty exists.</summary>
		[IntelliSense("Gets the value of the ExtendedProperty with the given name. Returns null if no such ExtendedProperty exists.")]
		public string GetExtendedProperty(string name) {
		    if(!HasExtendedProperty(name)) return null;
			var ep = MetadataObject.ExtendedProperties[name];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		///<summary>Sets the value of the ExtendedProperty with the given index, optionally specifiying the type (string or JSON) of the ExtendedProperty.</summary>
		public void SetExtendedProperty(int index, string value, ExtendedPropertyType type) {
			SetExtendedProperty(index, value, type, true);
		}
		void IInternalExtendedPropertyObject.SetExtendedProperty(int index, string value, ExtendedPropertyType type, bool undoable) {
			SetExtendedProperty(index, value, type, undoable);
		}
		internal void SetExtendedProperty(int index, string value, ExtendedPropertyType type, bool undoable) {
			var name = MetadataObject.ExtendedProperties[index].Name;
			SetExtendedProperty(name, value, type, undoable);
		}
		///<summary>Returns a unique name for a new ExtendedProperty.</summary>
		public string GetNewExtendedPropertyName() {
			return MetadataObject.ExtendedProperties.GetNewName("New ExtendedProperty");
		}
		///<summary>Sets the value of the ExtendedProperty having the given name. If no such ExtendedProperty exists, it will be created. If value is set to null, the ExtendedProperty will be removed.</summary>
		[IntelliSense("Sets the value of the ExtendedProperty having the given name. If no such ExtendedProperty exists, it will be created. If value is set to null, the ExtendedProperty will be removed.")]
		public void SetExtendedProperty(string name, string value, ExtendedPropertyType type) {
			SetExtendedProperty(name, value, type, true);
		}
		internal void SetExtendedProperty(string name, string value, ExtendedPropertyType type, bool undoable) {
			if(name == null) name = GetNewExtendedPropertyName();

			if(value == null) {
				// Remove ExtendedProperty if set to null:
				RemoveExtendedProperty(name);
				return;
			}

			if(GetExtendedProperty(name) == value) return;
			if(undoable) {
				bool cancel = false;
				OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + value, ref undoable, ref cancel);
				if (cancel) return;
			}

			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Change existing ExtendedProperty:
				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				var ep = MetadataObject.ExtendedProperties[name];
				if (ep is TOM.JsonExtendedProperty)
					(ep as TOM.JsonExtendedProperty).Value = value;
				else 
					(ep as TOM.StringExtendedProperty).Value = value;
					
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, name + ":" + value);
			} else {
				// Add new ExtendedProperty:
				if (type == ExtendedPropertyType.Json)
					MetadataObject.ExtendedProperties.Add(new TOM.JsonExtendedProperty{ Name = name, Value = value });
				else
					MetadataObject.ExtendedProperties.Add(new TOM.StringExtendedProperty{ Name = name, Value = value });

				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, null, type));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, null, name + ":" + value);
			}
		}
		void IInternalExtendedPropertyObject.SetExtendedProperty(string name, string value, ExtendedPropertyType type, bool undoable) {
			this.SetExtendedProperty(name, value, type, undoable);
		}

		///<summary>Remove an ExtendedProperty by the given name.</summary>
		[IntelliSense("Remove an ExtendedProperty by the given name.")]
		public void RemoveExtendedProperty(string name) {
			RemoveExtendedProperty(name, true);
		}

		internal void RemoveExtendedProperty(string name, bool undoable) {
			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Get current value:
				if(undoable) {
					bool cancel = false;
					OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + GetExtendedProperty(name), ref undoable, ref cancel);
					if (cancel) return;
				}

				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				MetadataObject.ExtendedProperties.Remove(name);

				// Undo-handling:
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, null, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, null);
			}
		}
		void IInternalExtendedPropertyObject.RemoveExtendedProperty(string name, bool undoable) {
			this.RemoveExtendedProperty(name, undoable);
		}
		///<summary>Gets the number of ExtendedProperties on the current object.</summary>
		[IntelliSense("Gets the number of ExtendedProperties on the current object.")]
		public int GetExtendedPropertyCount() {
			return MetadataObject.ExtendedProperties.Count;
		}
		///<summary>Gets a collection of all ExtendedProperty names on the current object.</summary>
		[IntelliSense("Gets a collection of all ExtendedProperty names on the current object.")]
		public IEnumerable<string> GetExtendedProperties() {
			return MetadataObject.ExtendedProperties.Select(a => a.Name);
		}

		/// <summary>
///             Specifies the type of Table so that you can customize application behavior based on the type of data in the table. Allowed values are identical to those of dimension type properties for Multidimensional models. Regular is the default. Other values include Time (2), Geography (3), Organization (4), BillOfMaterials (5), Accounts (6), Customers (7), Products (8), Scenario (9), Quantitativ1e (10), Utility (11), Currency (12), Rates (13), Channel (14) - channel dimension, Promotion (15).
///             </summary>
		[DisplayName("Data Category")]
		[Category("Options"),Description(@"Specifies the type of Table so that you can customize application behavior based on the type of data in the table. Allowed values are identical to those of dimension type properties for Multidimensional models. Regular is the default. Other values include Time (2), Geography (3), Organization (4), BillOfMaterials (5), Accounts (6), Customers (7), Products (8), Scenario (9), Quantitativ1e (10), Utility (11), Currency (12), Rates (13), Channel (14) - channel dimension, Promotion (15)."),IntelliSense(@"Specifies the type of Table so that you can customize application behavior based on the type of data in the table. Allowed values are identical to those of dimension type properties for Multidimensional models. Regular is the default. Other values include Time (2), Geography (3), Organization (4), BillOfMaterials (5), Accounts (6), Customers (7), Products (8), Scenario (9), Quantitativ1e (10), Utility (11), Currency (12), Rates (13), Channel (14) - channel dimension, Promotion (15).")][TypeConverter(typeof(TableDataCategoryConverter))]
		public string DataCategory {
			get {
			    return MetadataObject.DataCategory;
			}
			set {
				
				var oldValue = DataCategory;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DATACATEGORY, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.DataCategory = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DATACATEGORY, oldValue, newValue));
				OnPropertyChanged(Properties.DATACATEGORY, oldValue, newValue);
			}
		}
		private bool ShouldSerializeDataCategory() { return false; }
/// <summary>
///             The description of the table, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio.
///             </summary>
		[DisplayName("Description")]
		[Category("Basic"),Description(@"The description of the table, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio."),IntelliSense(@"The description of the table, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio.")][Editor(typeof(System.ComponentModel.Design.MultilineStringEditor), typeof(System.Drawing.Design.UITypeEditor))]
		public string Description {
			get {
			    return MetadataObject.Description;
			}
			set {
				
				var oldValue = Description;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DESCRIPTION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.Description = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DESCRIPTION, oldValue, newValue));
				OnPropertyChanged(Properties.DESCRIPTION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeDescription() { return false; }
/// <summary>
///             A boolean value that indicates whether the table is treated as hidden by client visualization tools. True if the Table is treated as hidden; otherwise false.
///             </summary>
		[DisplayName("Hidden")]
		[Category("Basic"),Description(@"A boolean value that indicates whether the table is treated as hidden by client visualization tools. True if the Table is treated as hidden; otherwise false."),IntelliSense(@"A boolean value that indicates whether the table is treated as hidden by client visualization tools. True if the Table is treated as hidden; otherwise false.")]
		public bool IsHidden {
			get {
			    return MetadataObject.IsHidden;
			}
			set {
				
				var oldValue = IsHidden;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ISHIDDEN, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.IsHidden = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.ISHIDDEN, oldValue, newValue));
				OnPropertyChanged(Properties.ISHIDDEN, oldValue, newValue);
				Handler.UpdateObject(this);
			}
		}
		private bool ShouldSerializeIsHidden() { return false; }
/// <summary>
///             A boolean value that indicates a difference between a local and server version. If True, the Table is only shown when referenced as Variation.
///             </summary><remarks>This property is only supported for Pbi server, at database compatibility level of 1400 or above for Box server, at database compatibility level of 1400 or above for Excel server.</remarks>
		[DisplayName("Show As Variations Only")]
		[Category("Options"),Description(@"A boolean value that indicates a difference between a local and server version. If True, the Table is only shown when referenced as Variation."),IntelliSense(@"A boolean value that indicates a difference between a local and server version. If True, the Table is only shown when referenced as Variation.")]
		public bool ShowAsVariationsOnly {
			get {
			    return MetadataObject.ShowAsVariationsOnly;
			}
			set {
				
				var oldValue = ShowAsVariationsOnly;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.SHOWASVARIATIONSONLY, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.ShowAsVariationsOnly = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.SHOWASVARIATIONSONLY, oldValue, newValue));
				OnPropertyChanged(Properties.SHOWASVARIATIONSONLY, oldValue, newValue);
			}
		}
		private bool ShouldSerializeShowAsVariationsOnly() { return false; }
/// <summary>
///             A boolean value that specifies whether to hide a table from the client. True hides the tables.
///             </summary><remarks>This property is only supported for Pbi server, at database compatibility level of 1400 or above for Box server, at database compatibility level of 1400 or above for Excel server.</remarks>
		[DisplayName("Private")]
		[Category("Options"),Description(@"A boolean value that specifies whether to hide a table from the client. True hides the tables."),IntelliSense(@"A boolean value that specifies whether to hide a table from the client. True hides the tables.")]
		public bool IsPrivate {
			get {
			    return MetadataObject.IsPrivate;
			}
			set {
				
				var oldValue = IsPrivate;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ISPRIVATE, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.IsPrivate = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.ISPRIVATE, oldValue, newValue));
				OnPropertyChanged(Properties.ISPRIVATE, oldValue, newValue);
			}
		}
		private bool ShouldSerializeIsPrivate() { return false; }
/// <summary>
///             The ranking or precedence used to select the alternate source table in case more than one match is found.
///             </summary><remarks>This property is only supported when the compatibility level of the database is at 1460 or above.</remarks>
		[DisplayName("Alternate Source Precedence")]
		[Category("Options"),Description(@"The ranking or precedence used to select the alternate source table in case more than one match is found."),IntelliSense(@"The ranking or precedence used to select the alternate source table in case more than one match is found.")]
		public int AlternateSourcePrecedence {
			get {
			    return MetadataObject.AlternateSourcePrecedence;
			}
			set {
				
				var oldValue = AlternateSourcePrecedence;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ALTERNATESOURCEPRECEDENCE, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.AlternateSourcePrecedence = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.ALTERNATESOURCEPRECEDENCE, oldValue, newValue));
				OnPropertyChanged(Properties.ALTERNATESOURCEPRECEDENCE, oldValue, newValue);
			}
		}
		private bool ShouldSerializeAlternateSourcePrecedence() { return false; }
/// <summary>
///             A boolean value that indicates whether the table is excluded from model refresh. When this is true, a refresh operation on the model would not trigger a refresh on the partitions of the table if they were already processed.
///             </summary><remarks>This property is only supported when the compatibility level of the database is at 1480 or above.</remarks>
		[DisplayName("Exclude From Model Refresh")]
		[Category("Options"),Description(@"A boolean value that indicates whether the table is excluded from model refresh. When this is true, a refresh operation on the model would not trigger a refresh on the partitions of the table if they were already processed."),IntelliSense(@"A boolean value that indicates whether the table is excluded from model refresh. When this is true, a refresh operation on the model would not trigger a refresh on the partitions of the table if they were already processed.")]
		public bool ExcludeFromModelRefresh {
			get {
			    return MetadataObject.ExcludeFromModelRefresh;
			}
			set {
				
				var oldValue = ExcludeFromModelRefresh;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.EXCLUDEFROMMODELREFRESH, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.ExcludeFromModelRefresh = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.EXCLUDEFROMMODELREFRESH, oldValue, newValue));
				OnPropertyChanged(Properties.EXCLUDEFROMMODELREFRESH, oldValue, newValue);
			}
		}
		private bool ShouldSerializeExcludeFromModelRefresh() { return false; }
/// <summary>
///             A tag that represents the lineage of the object.
///             </summary><remarks>This property is only supported when the compatibility level of the database is at 1540 or above.</remarks>
		[DisplayName("Lineage Tag")]
		[Category("Options"),Description(@"A tag that represents the lineage of the object."),IntelliSense(@"A tag that represents the lineage of the object.")]
		public string LineageTag {
			get {
			    return MetadataObject.LineageTag;
			}
			set {
				
				var oldValue = LineageTag;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.LINEAGETAG, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.LineageTag = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.LINEAGETAG, oldValue, newValue));
				OnPropertyChanged(Properties.LINEAGETAG, oldValue, newValue);
			}
		}
		private bool ShouldSerializeLineageTag() { return false; }
/// <summary>
///             A tag that represents the lineage of the source for the object.
///             </summary><remarks>This property is only supported when the compatibility level of the database is at 1550 or above.</remarks>
		[DisplayName("Source Lineage Tag")]
		[Category("Options"),Description(@"A tag that represents the lineage of the source for the object."),IntelliSense(@"A tag that represents the lineage of the source for the object.")]
		public string SourceLineageTag {
			get {
			    return MetadataObject.SourceLineageTag;
			}
			set {
				
				var oldValue = SourceLineageTag;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.SOURCELINEAGETAG, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.SourceLineageTag = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.SOURCELINEAGETAG, oldValue, newValue));
				OnPropertyChanged(Properties.SOURCELINEAGETAG, oldValue, newValue);
			}
		}
		private bool ShouldSerializeSourceLineageTag() { return false; }
/// <summary>
///             A boolean value that indicates whether the table is managed by the system. The system takes ownership of creation and deletion of such tables.
///             </summary><remarks>This property is only supported when the compatibility level of the database is at 1562 or above.</remarks>
		[DisplayName("System Managed")]
		[Category("Options"),Description(@"A boolean value that indicates whether the table is managed by the system. The system takes ownership of creation and deletion of such tables."),IntelliSense(@"A boolean value that indicates whether the table is managed by the system. The system takes ownership of creation and deletion of such tables.")]
		public bool SystemManaged {
			get {
			    return MetadataObject.SystemManaged;
			}
			set {
				
				var oldValue = SystemManaged;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.SYSTEMMANAGED, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.SystemManaged = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.SYSTEMMANAGED, oldValue, newValue));
				OnPropertyChanged(Properties.SYSTEMMANAGED, oldValue, newValue);
			}
		}
		private bool ShouldSerializeSystemManaged() { return false; }

        /// <Summary>
		/// Collection of perspectives in which this Table is visible.
		/// </Summary>
		[Browsable(true),DisplayName("Shown in Perspective"), Description("Provides an easy way to include or exclude the current Table from the perspectives of the model."), Category("Translations, Perspectives, Security")]
        public PerspectiveTableIndexer InPerspective { get; private set; }
		PerspectiveIndexer ITabularPerspectiveObject.InPerspective { get { return this.InPerspective; } }
        /// <summary>
        /// Collection of localized descriptions for this Table.
        /// </summary>
        [Browsable(true),DisplayName("Translated Descriptions"),Description("Shows all translated descriptions of the current Table."),Category("Translations, Perspectives, Security")]
	    public TranslationIndexer TranslatedDescriptions { private set; get; }
        /// <summary>
        /// Collection of localized names for this Table.
        /// </summary>
        [Browsable(true),DisplayName("Translated Names"),Description("Shows all translated names of the current Table."),Category("Translations, Perspectives, Security")]
	    public TranslationIndexer TranslatedNames { private set; get; }

        /// <summary>
        /// Collection of localized synonyms for this Table.
        /// </summary>
        [Browsable(true),DisplayName("Synonyms"),Description("Shows all translated synonyms of the current Table."),Category("Translations, Perspectives, Security")]
	    public SynonymIndexer Synonyms { private set; get; }
		internal static Table CreateFromMetadata(Model parent, TOM.Table metadataObject) {
            // Generate a new LineageTag if an object with the provided lineage tag already exists:
            if(!string.IsNullOrEmpty(metadataObject.LineageTag)) {
                if (parent.Handler.CompatibilityLevel < 1540) metadataObject.LineageTag = null;
                else if (parent.MetadataObject.Tables.FindByLineageTag(metadataObject.LineageTag) != metadataObject) {
                    metadataObject.LineageTag = Guid.NewGuid().ToString();
                }
            }
			var obj = new Table(metadataObject);
			parent.Tables.Add(obj);
			
			obj.Init();

			return obj;
		}


		/// <summary>
		/// Creates a new Table and adds it to the parent Model.
		/// Also creates the underlying metadataobject and adds it to the TOM tree.
		/// </summary>
		public static Table CreateNew(Model parent, string name = null)
		{
			if(!parent.Handler.PowerBIGovernance.AllowCreate(typeof(Table))) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(Table).GetTypeName()));
			}

			var metadataObject = new TOM.Table();
            if(parent.Model.Database.CompatibilityLevel >= 1540) metadataObject.LineageTag = Guid.NewGuid().ToString();
			metadataObject.Name = parent.Tables.GetNewName(string.IsNullOrWhiteSpace(name) ? "New " + typeof(Table).GetTypeName() : name);
            InitMetadata(metadataObject, parent);
            var obj = new Table(metadataObject);

			parent.Tables.Add(obj);
			
			obj.Init();

			return obj;
		}

        static partial void InitMetadata(TOM.Table metadataObject, Model parent);

		/// <summary>
		/// Creates a new Table and adds it to the current Model.
		/// Also creates the underlying metadataobject and adds it to the TOM tree.
		/// </summary>		
		public static Table CreateNew(string name = null)
		{
			return CreateNew(TabularModelHandler.Singleton.Model, name);
		}


		/// <summary>
		/// Creates an exact copy of this Table object.
		/// </summary>
		[IntelliSense("Creates an exact copy of this Table object.")]
		public virtual Table Clone(string newName = null, bool includeTranslations = true) {
			if(!Handler.PowerBIGovernance.AllowCreate(this.GetType())) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(Table).GetTypeName()));
			}

		    Handler.BeginUpdate("Clone Table");

			// Create a clone of the underlying metadataobject:
			var tom = MetadataObject.Clone() as TOM.Table;

			// Make sure that measures on the table are renamed:
			foreach(var m in tom.Measures) m.Name = tom.Measures.GetNewName(m.Name);

            // Make sure new lineage tags are generated:
            if(Model.Database.CompatibilityLevel >= 1540 && !string.IsNullOrEmpty(LineageTag)) {
                tom.LineageTag = Guid.NewGuid().ToString();
                foreach(var m in tom.Measures) m.LineageTag = Guid.NewGuid().ToString();
                foreach(var c in tom.Columns) c.LineageTag = Guid.NewGuid().ToString();
                foreach(var h in tom.Hierarchies) {
                    h.LineageTag = Guid.NewGuid().ToString();
                    foreach(var l in h.Levels) l.LineageTag = Guid.NewGuid().ToString();
                }
            }

			// Assign a new, unique name:
			tom.Name = Parent.Tables.GetNewName(string.IsNullOrEmpty(newName) ? tom.Name + " copy" : newName);
				
			// Create the TOM Wrapper object, representing the metadataobject
			Table obj ;
			if(this is CalculatedTable) obj = CalculatedTable.CreateFromMetadata(Parent, tom);
			else if(this is CalculationGroupTable) obj = CalculationGroupTable.CreateFromMetadata(Parent, tom);
			else obj = CreateFromMetadata(Parent, tom);

			// Copy translations, if applicable:
			if(includeTranslations) {
				obj.CopyTranslationsFrom(this);
				foreach(var objChild in obj.Columns) objChild.CopyTranslationsFrom(obj.Columns[objChild.MetadataIndex]);
				foreach(var objChild in obj.Hierarchies) objChild.CopyTranslationsFrom(obj.Hierarchies[objChild.MetadataIndex]);
				foreach(var objChild in obj.Measures) objChild.CopyTranslationsFrom(obj.Measures[objChild.MetadataIndex]);
			}
				
			// Copy perspectives:
			obj.InPerspective.CopyFrom(InPerspective);

			// TODO: Make sure that dependency trees are properly rebuilt when IDaxDependantObjects are cloned
			// FormulaFixup.BuildDependencyTree(this);
			Handler.UpdateFolders(obj);
            Handler.EndUpdate();

            return obj;
		}

		TabularNamedObject IClonableObject.Clone(string newName, bool includeTranslations, TabularNamedObject newParent) 
		{
			if (newParent != null) throw new ArgumentException("This object can not be cloned to another parent. Argument newParent should be left as null.", "newParent");
			return Clone(newName, includeTranslations);
		}

	
        internal override void RenewMetadataObject()
        {
            Handler.WrapperLookup.Remove(MetadataObject);
            var json = TOM.JsonSerializer.SerializeObject(MetadataObject, RenewMetadataOptions);
            MetadataObject = TOM.JsonSerializer.DeserializeObject<TOM.Table>(json);
            Handler.WrapperLookup.Add(MetadataObject, this);
        }

		///<summary>The parent Model of the current Table.</summary>
		public Model Parent { 
			get {
				return Handler.WrapperLookup[MetadataObject.Parent] as Model;
			}
		}

        internal override ITabularObjectCollection GetCollectionForChild(TabularObject child)
        {
			if (child is Set) return Sets;
			if (child is Partition) return Partitions;
			if (child is Column) return Columns;
			if (child is Hierarchy) return Hierarchies;
			if (child is Measure) return Measures;
            return base.GetCollectionForChild(child);
        }

        /// <summary>
        /// The collection of Set objects on this Table.
        /// </summary>
		[DisplayName("Sets")]
		[Category("Options"),IntelliSense("The collection of Set objects on the current Table.")][NoMultiselect(),Editor(typeof(SetCollectionEditor),typeof(UITypeEditor))]
		public SetCollection Sets { get; protected set; }
        /// <summary>
        /// The collection of Partition objects on this Table.
        /// </summary>
		[DisplayName("Partitions")]
		[Category("Options"),IntelliSense("The collection of Partition objects on the current Table.")][NoMultiselect(),Editor(typeof(PartitionCollectionEditor),typeof(UITypeEditor))]
		public PartitionCollection Partitions { get; protected set; }
        /// <summary>
        /// The collection of Column objects on this Table.
        /// </summary>
		[DisplayName("Columns")]
		[Category("Options"),IntelliSense("The collection of Column objects on the current Table.")][Browsable(false)]
		public ColumnCollection Columns { get; protected set; }
        /// <summary>
        /// The collection of Hierarchy objects on this Table.
        /// </summary>
		[DisplayName("Hierarchies")]
		[Category("Options"),IntelliSense("The collection of Hierarchy objects on the current Table.")][Browsable(false)]
		public HierarchyCollection Hierarchies { get; protected set; }
        /// <summary>
        /// The collection of Measure objects on this Table.
        /// </summary>
		[DisplayName("Measures")]
		[Category("Options"),IntelliSense("The collection of Measure objects on the current Table.")][Browsable(false)]
		public MeasureCollection Measures { get; protected set; }

		/// <summary>
		/// CTOR - only called from static factory methods on the class
		/// </summary>
		protected Table(TOM.Table metadataObject) : base(metadataObject)
		{
			// Create indexers for translations:
			TranslatedNames = new TranslationIndexer(this, TOM.TranslatedProperty.Caption);
			TranslatedDescriptions = new TranslationIndexer(this, TOM.TranslatedProperty.Description);
			Synonyms = new SynonymIndexer(this);

			// Create indexer for perspectives:
			InPerspective = new PerspectiveTableIndexer(this);
			
			// Create indexer for annotations:
			Annotations = new AnnotationCollection(this);
			
			// Create indexer for extended properties:
			ExtendedProperties = new ExtendedPropertyCollection(this);
			
			// Instantiate child collections:
			Sets = new SetCollection(this.GetObjectPath() + ".Sets", MetadataObject.Sets, this);
			Partitions = new PartitionCollection(this.GetObjectPath() + ".Partitions", MetadataObject.Partitions, this);
			Columns = new ColumnCollection(this.GetObjectPath() + ".Columns", MetadataObject.Columns, this);
			Hierarchies = new HierarchyCollection(this.GetObjectPath() + ".Hierarchies", MetadataObject.Hierarchies, this);
			Measures = new MeasureCollection(this.GetObjectPath() + ".Measures", MetadataObject.Measures, this);

			// Populate child collections:
			Sets.CreateChildrenFromMetadata();
			Partitions.CreateChildrenFromMetadata();
			Columns.CreateChildrenFromMetadata();
			Hierarchies.CreateChildrenFromMetadata();
			Measures.CreateChildrenFromMetadata();

			// Hook up event handlers on child collections:
			Sets.CollectionChanged += Children_CollectionChanged;
			Partitions.CollectionChanged += Children_CollectionChanged;
			Columns.CollectionChanged += Children_CollectionChanged;
			Hierarchies.CollectionChanged += Children_CollectionChanged;
			Measures.CollectionChanged += Children_CollectionChanged;
		}


		internal override void Reinit() {
			Sets.Reinit();
			Partitions.Reinit();
			Columns.Reinit();
			Hierarchies.Reinit();
			Measures.Reinit();
		}

		internal override void Undelete(ITabularObjectCollection collection, Type tomObjectType, string tomJson) {
			base.Undelete(collection, tomObjectType, tomJson);
			Reinit();
			ReapplyReferences();
			Handler.Tree.RebuildFolderCacheForTable(this);
		}
		internal override sealed bool Browsable(string propertyName) {
			// Allow custom overrides to hide a property regardless of its compatibility level requirements:
			if(!base.Browsable(propertyName)) return false;

			switch (propertyName) {

				// Hide properties based on compatibility requirements (inferred from TOM):
				case Properties.ALTERNATESOURCEPRECEDENCE:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1460 : Handler.CompatibilityLevel >= 1460;
				case Properties.CALCULATIONGROUP:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1470 : Handler.CompatibilityLevel >= 1470;
				case Properties.DEFAULTDETAILROWSDEFINITION:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1400 : Handler.CompatibilityLevel >= 1400;
				case Properties.EXCLUDEFROMMODELREFRESH:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1480 : Handler.CompatibilityLevel >= 1480;
				case Properties.EXTENDEDPROPERTIES:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1400 : Handler.CompatibilityLevel >= 1400;
				case Properties.ISPRIVATE:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1200 : Handler.CompatibilityLevel >= 1400;
				case Properties.LINEAGETAG:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1540 : Handler.CompatibilityLevel >= 1540;
				case Properties.REFRESHPOLICY:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1450 : Handler.CompatibilityLevel >= 1450;
				case Properties.SETS:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1400 : false;
				case Properties.SHOWASVARIATIONSONLY:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1200 : Handler.CompatibilityLevel >= 1400;
				case Properties.SOURCELINEAGETAG:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1550 : Handler.CompatibilityLevel >= 1550;
				case Properties.SYSTEMMANAGED:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1562 : Handler.CompatibilityLevel >= 1562;
				case Properties.PARENT:
					return false;
				case nameof(Synonyms):
					return Synonyms.LinguisticCultures.Any();
				
				// Hides translation properties in the grid, unless the model actually contains translations:
				case Properties.TRANSLATEDNAMES:
				case Properties.TRANSLATEDDESCRIPTIONS:
					return Model.Cultures.Any();
				
				// Hides the perspective property in the grid, unless the model actually contains perspectives:
				case Properties.INPERSPECTIVE:
					return Model.Perspectives.Any();
				
				default:
					return true;
			}
		}

    }


	/// <summary>
	/// Collection class for Table. Provides convenient properties for setting a property on multiple objects at once.
	/// </summary>
	public sealed partial class TableCollection: TabularObjectCollection<Table>
	{
		internal Model Model { get { return Parent as Model; } }
		TOM.TableCollection TOM_Collection;
		internal TableCollection(string collectionName, TOM.TableCollection metadataObjectCollection, Model parent) : base(collectionName, parent)
		{
			TOM_Collection = metadataObjectCollection;
		}
		internal override Type GetItemType() { return typeof(Table); }
        internal override void TOM_Add(TOM.MetadataObject obj) { TOM_Collection.Add(obj as TOM.Table); }
        internal override bool TOM_Contains(TOM.MetadataObject obj) { return TOM_Collection.Contains(obj as TOM.Table); }
        internal override void TOM_Remove(TOM.MetadataObject obj) { TOM_Collection.Remove(obj as TOM.Table); }
        internal override void TOM_Clear() { TOM_Collection.Clear(); }
        internal override bool TOM_ContainsName(string name) { return TOM_Collection.ContainsName(name); }
		internal override TOM.MetadataObject TOM_Get(int index) { return TOM_Collection[index]; }
        internal override TOM.MetadataObject TOM_Get(string name) { return TOM_Collection[name]; }
        internal override TOM.MetadataObject TOM_Find(string name) { return TOM_Collection.Find(name); }
        internal override string GetNewName(string prefix = null) { return string.IsNullOrEmpty(prefix) ? TOM_Collection.GetNewName() : TOM_Collection.GetNewName(prefix); }
        internal override int IndexOf(TOM.MetadataObject obj) { return TOM_Collection.IndexOf(obj as TOM.Table); }
        /// <summary>The number of items in this collection.</summary>
		public override int Count { get { return TOM_Collection.Count; } }
		/// <summary>Returns an enumerator that iterates through the collection.</summary>
        public override IEnumerator<Table> GetEnumerator() { return TOM_Collection.Select(h => Handler.WrapperLookup[h]).OfType<Table>().GetEnumerator(); }
		internal override void Reinit() {
			var ixOffset = 0;
			for(int i = 0; i < Count; i++) {
				var metadataObj = TOM_Get(i) as TOM.Table;
				var item = Handler.WrapperLookup.TryGetValue(metadataObj, out var existingItem) ? existingItem as Table : CreateFromMetadata(metadataObj);
				Handler.WrapperLookup.Remove(item.MetadataObject);
				item.MetadataObject = Model.MetadataObject.Tables[i + ixOffset] as TOM.Table;
				Handler.WrapperLookup.Add(item.MetadataObject, item);
				item.Collection = this;
			}
			TOM_Collection = Model.MetadataObject.Tables;
			foreach(var item in this) item.Reinit();
		}

		internal override void ReapplyReferences() {
			foreach(var item in this) item.ReapplyReferences();
		}

		private Table CreateFromMetadata(TOM.Table obj)
		{
            if (obj.Partitions[0].SourceType == TOM.PartitionSourceType.Calculated) return CalculatedTable.CreateFromMetadata(Model, obj);
			else if (obj.Partitions[0].SourceType == TOM.PartitionSourceType.CalculationGroup) return CalculationGroupTable.CreateFromMetadata(Model, obj);
            else return Table.CreateFromMetadata(Model, obj);
		    return null;
		}

		/// <summary>
		/// Calling this method will populate the TableCollection with objects based on the MetadataObjects in the corresponding MetadataObjectCollection.
		/// </summary>
		internal override void CreateChildrenFromMetadata()
		{
			// Construct child objects (they are automatically added to the Handler's WrapperLookup dictionary):
			foreach(var obj in TOM_Collection)
			{
				CreateFromMetadata(obj);
			}
		}

		/// <summary>
		/// Sets the DataCategory property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the DataCategory property of all objects in the collection at once.")]
		public string DataCategory {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("DataCategory"));
				this.ToList().ForEach(item => { item.DataCategory = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the Description property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the Description property of all objects in the collection at once.")]
		public string Description {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("Description"));
				this.ToList().ForEach(item => { item.Description = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the IsHidden property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the IsHidden property of all objects in the collection at once.")]
		public bool IsHidden {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("IsHidden"));
				this.ToList().ForEach(item => { item.IsHidden = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the ShowAsVariationsOnly property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the ShowAsVariationsOnly property of all objects in the collection at once.")]
		public bool ShowAsVariationsOnly {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("ShowAsVariationsOnly"));
				this.ToList().ForEach(item => { item.ShowAsVariationsOnly = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the IsPrivate property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the IsPrivate property of all objects in the collection at once.")]
		public bool IsPrivate {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("IsPrivate"));
				this.ToList().ForEach(item => { item.IsPrivate = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the AlternateSourcePrecedence property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the AlternateSourcePrecedence property of all objects in the collection at once.")]
		public int AlternateSourcePrecedence {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("AlternateSourcePrecedence"));
				this.ToList().ForEach(item => { item.AlternateSourcePrecedence = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the ExcludeFromModelRefresh property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the ExcludeFromModelRefresh property of all objects in the collection at once.")]
		public bool ExcludeFromModelRefresh {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("ExcludeFromModelRefresh"));
				this.ToList().ForEach(item => { item.ExcludeFromModelRefresh = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the SourceLineageTag property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the SourceLineageTag property of all objects in the collection at once.")]
		public string SourceLineageTag {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("SourceLineageTag"));
				this.ToList().ForEach(item => { item.SourceLineageTag = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the SystemManaged property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the SystemManaged property of all objects in the collection at once.")]
		public bool SystemManaged {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("SystemManaged"));
				this.ToList().ForEach(item => { item.SystemManaged = value; });
				Handler.UndoManager.EndBatch();
			}
		}
	}
  
	/// <summary>
///             Represents an individual Windows user account or a Windows security group.
///             </summary>
	[TypeConverter(typeof(DynamicPropertyConverter))]
	public sealed partial class WindowsModelRoleMember: ModelRoleMember
			, IClonableObject
	{
	    internal new TOM.WindowsModelRoleMember MetadataObject 
		{ 
			get 
			{ 
				return base.MetadataObject as TOM.WindowsModelRoleMember; 
		    } 
			set 
			{ 
				base.MetadataObject = value; 
			}
		}


		internal static WindowsModelRoleMember CreateFromMetadata(ModelRole parent, TOM.WindowsModelRoleMember metadataObject) {
			var obj = new WindowsModelRoleMember(metadataObject);
			parent.Members.Add(obj);
			
			obj.Init();

			return obj;
		}


		/// <summary>
		/// Creates a new WindowsModelRoleMember and adds it to the parent ModelRole.
		/// Also creates the underlying metadataobject and adds it to the TOM tree.
		/// </summary>
		public static WindowsModelRoleMember CreateNew(ModelRole parent, string name = null)
		{
			if(!parent.Handler.PowerBIGovernance.AllowCreate(typeof(WindowsModelRoleMember))) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(WindowsModelRoleMember).GetTypeName()));
			}

			var metadataObject = new TOM.WindowsModelRoleMember();
			metadataObject.MemberName = parent.Members.GetNewName(string.IsNullOrWhiteSpace(name) ? "New " + typeof(WindowsModelRoleMember).GetTypeName() : name);
            InitMetadata(metadataObject, parent);
            var obj = new WindowsModelRoleMember(metadataObject);

			parent.Members.Add(obj);
			
			obj.Init();

			return obj;
		}

        static partial void InitMetadata(TOM.WindowsModelRoleMember metadataObject, ModelRole parent);


		/// <summary>
		/// Creates an exact copy of this WindowsModelRoleMember object.
		/// </summary>
		[IntelliSense("Creates an exact copy of this WindowsModelRoleMember object.")]
		public WindowsModelRoleMember Clone(string newName = null, ModelRole newParent = null) {
			if(!Handler.PowerBIGovernance.AllowCreate(this.GetType())) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(WindowsModelRoleMember).GetTypeName()));
			}

		    Handler.BeginUpdate("Clone WindowsModelRoleMember");

			// Create a clone of the underlying metadataobject:
			var tom = MetadataObject.Clone() as TOM.WindowsModelRoleMember;


			// Assign a new, unique name:
			tom.Name = Parent.Members.GetNewName(string.IsNullOrEmpty(newName) ? tom.Name + " copy" : newName);
				
			// Create the TOM Wrapper object, representing the metadataobject
			WindowsModelRoleMember obj = CreateFromMetadata(newParent ?? Parent, tom);

            Handler.EndUpdate();

            return obj;
		}

		TabularNamedObject IClonableObject.Clone(string newName, bool includeTranslations, TabularNamedObject newParent) 
		{
			return Clone(newName);
		}

	
        internal override void RenewMetadataObject()
        {
            Handler.WrapperLookup.Remove(MetadataObject);
            var json = TOM.JsonSerializer.SerializeObject(MetadataObject, RenewMetadataOptions);
            MetadataObject = TOM.JsonSerializer.DeserializeObject<TOM.WindowsModelRoleMember>(json);
            Handler.WrapperLookup.Add(MetadataObject, this);
        }

		///<summary>The parent Model Role of the current Windows Model Role Member.</summary>
		public new ModelRole Parent { 
			get {
				return Handler.WrapperLookup[MetadataObject.Parent] as ModelRole;
			}
		}



		/// <summary>
		/// CTOR - only called from static factory methods on the class
		/// </summary>
		WindowsModelRoleMember(TOM.WindowsModelRoleMember metadataObject) : base(metadataObject)
		{
		}



		internal override void Undelete(ITabularObjectCollection collection, Type tomObjectType, string tomJson) {
			base.Undelete(collection, tomObjectType, tomJson);
			Reinit();
			ReapplyReferences();
		}
		internal override sealed bool Browsable(string propertyName) {
			// Allow custom overrides to hide a property regardless of its compatibility level requirements:
			if(!base.Browsable(propertyName)) return false;

			switch (propertyName) {

				// Hide properties based on compatibility requirements (inferred from TOM):
				case Properties.PARENT:
					return false;
				
				default:
					return true;
			}
		}

    }

  
	/// <summary>
///             A named expression that can be used by one or more partitions.
///             </summary><remarks>This metadata object is only supported when the compatibility level of the database is at 1400 or above.</remarks>
	[TypeConverter(typeof(DynamicPropertyConverter))]
	public sealed partial class NamedExpression: TabularNamedObject
			, IDescriptionObject
			, ILineageTagObject
			, IInternalAnnotationObject
			, IInternalExtendedPropertyObject
			, IClonableObject
	{
	    internal new TOM.NamedExpression MetadataObject 
		{ 
			get 
			{ 
				return base.MetadataObject as TOM.NamedExpression; 
		    } 
			set 
			{ 
				base.MetadataObject = value; 
			}
		}

        private bool CanClearAnnotations() => GetAnnotationsCount() > 0;
        ///<summary>Removes all annotations from this object.</summary>
        [IntelliSense("Removes all annotations from this object.")]
        public void ClearAnnotations()
        {
            Handler.BeginUpdate("Clear annotations");
            foreach(var annotation in GetAnnotations().ToList()) {
                RemoveAnnotation(annotation);
            }
            Handler.EndUpdate();
        }

		///<summary>The collection of Annotations on the current Named Expression.</summary>
        [Browsable(true),NoMultiselect,Category("Metadata"),Description("The collection of Annotations on the current Named Expression."),Editor(typeof(AnnotationCollectionEditor), typeof(UITypeEditor))]
        [PropertyAction(nameof(ClearAnnotations))]
		public AnnotationCollection Annotations { get; private set; }
		///<summary>Gets the value of the annotation with the given index, assuming it exists.</summary>
		[IntelliSense("Gets the value of the annotation with the given index, assuming it exists.")]
		public string GetAnnotation(int index) {
			return MetadataObject.Annotations[index].Value;
		}
		///<summary>Returns true if an annotation with the given name exists. Otherwise false.</summary>
		[IntelliSense("Returns true if an annotation with the given name exists. Otherwise false.")]
		public bool HasAnnotation(string name) {
		    return MetadataObject.Annotations.ContainsName(name);
		}
		///<summary>Gets the value of the annotation with the given name. Returns null if no such annotation exists.</summary>
		[IntelliSense("Gets the value of the annotation with the given name. Returns null if no such annotation exists.")]
		public string GetAnnotation(string name) {
		    return HasAnnotation(name) ? MetadataObject.Annotations[name].Value : null;
		}
		///<summary>Sets the value of the annotation with the given index, assuming it exists.</summary>
		[IntelliSense("Sets the value of the annotation with the given index, assuming it exists.")]
		public void SetAnnotation(int index, string value) {
		    SetAnnotation(index, value, true);
		}
		internal void SetAnnotation(int index, string value, bool undoable) {
		    var name = MetadataObject.Annotations[index].Name;
			SetAnnotation(name, value, undoable);
		}
		void IInternalAnnotationObject.SetAnnotation(int index, string value, bool undoable) {
			SetAnnotation(index, value, undoable);
		}
		///<summary>Returns a unique name for a new annotation.</summary>
		public string GetNewAnnotationName() {
			return MetadataObject.Annotations.GetNewName("New Annotation");
		}
		///<summary>Sets the value of the annotation having the given name. If no such annotation exists, it will be created. If value is set to null, the annotation will be removed.</summary>
		[IntelliSense("Sets the value of the annotation having the given name. If no such annotation exists, it will be created. If value is set to null, the annotation will be removed.")]
		public void SetAnnotation(string name, string value) {
		    SetAnnotation(name, value, true);
		}
		internal void SetAnnotation(string name, string value, bool undoable) {
			if(name == null) name = GetNewAnnotationName();

			if(value == null) {
				// Remove annotation if set to null:
				RemoveAnnotation(name, undoable);
				return;
			}

			if(undoable) {
 				if(GetAnnotation(name) == value) return;
				bool undoable2 = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + value, ref undoable2, ref cancel);
				if (cancel) return;
			}

			if(MetadataObject.Annotations.Contains(name)) {
				// Change existing annotation:

				var oldValue = GetAnnotation(name);
				MetadataObject.Annotations[name].Value = value;
				if (undoable) {
					Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, oldValue));
					OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, name + ":" + value);
				}
			} else {
				// Add new annotation:

				MetadataObject.Annotations.Add(new TOM.Annotation{ Name = name, Value = value });
				if (undoable) {
					Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, null));
					OnPropertyChanged(Properties.ANNOTATIONS, null, name + ":" + value);
				}
			}
		}
		void IInternalAnnotationObject.SetAnnotation(string name, string value, bool undoable) {
			this.SetAnnotation(name, value, undoable);
		}
		///<summary>Remove an annotation by the given name.</summary>
		[IntelliSense("Remove an annotation by the given name.")]
		public void RemoveAnnotation(string name) {
		    RemoveAnnotation(name, true);
		}
		internal void RemoveAnnotation(string name, bool undoable) {
			if(MetadataObject.Annotations.Contains(name)) {
				if(undoable) 
				{
				    bool undoable2 = true;
				    bool cancel = false;
				    OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + GetAnnotation(name), ref undoable2, ref cancel);
				    if (cancel) return;
				}

			    var oldValue = MetadataObject.Annotations[name].Value;
				MetadataObject.Annotations.Remove(name);

				if (undoable) 
				{
					Handler.UndoManager.Add(new UndoAnnotationAction(this, name, null, oldValue));
					OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, null);
			    }
			}
		}
		void IInternalAnnotationObject.RemoveAnnotation(string name, bool undoable) {
			this.RemoveAnnotation(name, undoable);
		}
		///<summary>Gets the number of annotations on the current Named Expression.</summary>
		[IntelliSense("Gets the number of annotations on the current Named Expression.")]
		public int GetAnnotationsCount() {
			return MetadataObject.Annotations.Count;
		}
		///<summary>Gets a collection of all annotation names on the current Named Expression.</summary>
		[IntelliSense("Gets a collection of all annotation names on the current Named Expression.")]
		public IEnumerable<string> GetAnnotations() {
			return MetadataObject.Annotations.Select(a => a.Name);
		}

		        private bool CanClearExtendedProperties() => GetExtendedPropertyCount() > 0;
        ///<summary>Removes all Extended Properties from this object.</summary>
        [IntelliSense("Removes all Extended Properties from this object.")]
        public void ClearExtendedProperties()
        {
            Handler.BeginUpdate("Clear extended properties");
            foreach(var extendedProperty in GetExtendedProperties().ToList()) {
                RemoveExtendedProperty(extendedProperty);
            }
            Handler.EndUpdate();
        }

		///<summary>The collection of Extended Properties on the current Named Expression.</summary>
        [DisplayName("Extended Properties"),NoMultiselect,Category("Metadata"),Description("The collection of Extended Properties on the current Named Expression."),Editor(typeof(ExtendedPropertyCollectionEditor), typeof(UITypeEditor))]
        [PropertyAction(nameof(ClearExtendedProperties))]
		public ExtendedPropertyCollection ExtendedProperties { get; private set; }

		///<summary>Returns true if an ExtendedProperty with the given name exists. Otherwise false.</summary>
		[IntelliSense("Returns true if an ExtendedProperty with the given name exists. Otherwise false.")]
		public bool HasExtendedProperty(string name) {
		    return MetadataObject.ExtendedProperties.ContainsName(name);
		}
		///<summary>Gets the type of the ExtendedProperty with the given index, assuming it exists.</summary>
		public ExtendedPropertyType GetExtendedPropertyType(int index) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[index].Type;
		}
		///<summary>Gets the type of the ExtendedProperty with the given name, assuming it exists.</summary>
		public ExtendedPropertyType GetExtendedPropertyType(string name) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[name].Type;
		}
		///<summary>Gets the value of the ExtendedProperty with the given index, assuming it exists.</summary>
		public string GetExtendedProperty(int index) {
			var ep = MetadataObject.ExtendedProperties[index];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		///<summary>Gets the value of the ExtendedProperty with the given name. Returns null if no such ExtendedProperty exists.</summary>
		[IntelliSense("Gets the value of the ExtendedProperty with the given name. Returns null if no such ExtendedProperty exists.")]
		public string GetExtendedProperty(string name) {
		    if(!HasExtendedProperty(name)) return null;
			var ep = MetadataObject.ExtendedProperties[name];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		///<summary>Sets the value of the ExtendedProperty with the given index, optionally specifiying the type (string or JSON) of the ExtendedProperty.</summary>
		public void SetExtendedProperty(int index, string value, ExtendedPropertyType type) {
			SetExtendedProperty(index, value, type, true);
		}
		void IInternalExtendedPropertyObject.SetExtendedProperty(int index, string value, ExtendedPropertyType type, bool undoable) {
			SetExtendedProperty(index, value, type, undoable);
		}
		internal void SetExtendedProperty(int index, string value, ExtendedPropertyType type, bool undoable) {
			var name = MetadataObject.ExtendedProperties[index].Name;
			SetExtendedProperty(name, value, type, undoable);
		}
		///<summary>Returns a unique name for a new ExtendedProperty.</summary>
		public string GetNewExtendedPropertyName() {
			return MetadataObject.ExtendedProperties.GetNewName("New ExtendedProperty");
		}
		///<summary>Sets the value of the ExtendedProperty having the given name. If no such ExtendedProperty exists, it will be created. If value is set to null, the ExtendedProperty will be removed.</summary>
		[IntelliSense("Sets the value of the ExtendedProperty having the given name. If no such ExtendedProperty exists, it will be created. If value is set to null, the ExtendedProperty will be removed.")]
		public void SetExtendedProperty(string name, string value, ExtendedPropertyType type) {
			SetExtendedProperty(name, value, type, true);
		}
		internal void SetExtendedProperty(string name, string value, ExtendedPropertyType type, bool undoable) {
			if(name == null) name = GetNewExtendedPropertyName();

			if(value == null) {
				// Remove ExtendedProperty if set to null:
				RemoveExtendedProperty(name);
				return;
			}

			if(GetExtendedProperty(name) == value) return;
			if(undoable) {
				bool cancel = false;
				OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + value, ref undoable, ref cancel);
				if (cancel) return;
			}

			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Change existing ExtendedProperty:
				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				var ep = MetadataObject.ExtendedProperties[name];
				if (ep is TOM.JsonExtendedProperty)
					(ep as TOM.JsonExtendedProperty).Value = value;
				else 
					(ep as TOM.StringExtendedProperty).Value = value;
					
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, name + ":" + value);
			} else {
				// Add new ExtendedProperty:
				if (type == ExtendedPropertyType.Json)
					MetadataObject.ExtendedProperties.Add(new TOM.JsonExtendedProperty{ Name = name, Value = value });
				else
					MetadataObject.ExtendedProperties.Add(new TOM.StringExtendedProperty{ Name = name, Value = value });

				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, null, type));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, null, name + ":" + value);
			}
		}
		void IInternalExtendedPropertyObject.SetExtendedProperty(string name, string value, ExtendedPropertyType type, bool undoable) {
			this.SetExtendedProperty(name, value, type, undoable);
		}

		///<summary>Remove an ExtendedProperty by the given name.</summary>
		[IntelliSense("Remove an ExtendedProperty by the given name.")]
		public void RemoveExtendedProperty(string name) {
			RemoveExtendedProperty(name, true);
		}

		internal void RemoveExtendedProperty(string name, bool undoable) {
			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Get current value:
				if(undoable) {
					bool cancel = false;
					OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + GetExtendedProperty(name), ref undoable, ref cancel);
					if (cancel) return;
				}

				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				MetadataObject.ExtendedProperties.Remove(name);

				// Undo-handling:
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, null, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, null);
			}
		}
		void IInternalExtendedPropertyObject.RemoveExtendedProperty(string name, bool undoable) {
			this.RemoveExtendedProperty(name, undoable);
		}
		///<summary>Gets the number of ExtendedProperties on the current object.</summary>
		[IntelliSense("Gets the number of ExtendedProperties on the current object.")]
		public int GetExtendedPropertyCount() {
			return MetadataObject.ExtendedProperties.Count;
		}
		///<summary>Gets a collection of all ExtendedProperty names on the current object.</summary>
		[IntelliSense("Gets a collection of all ExtendedProperty names on the current object.")]
		public IEnumerable<string> GetExtendedProperties() {
			return MetadataObject.ExtendedProperties.Select(a => a.Name);
		}

		/// <summary>
///             The description of the expression, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio.
///             </summary>
		[DisplayName("Description")]
		[Category("Basic"),Description(@"The description of the expression, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio."),IntelliSense(@"The description of the expression, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio.")][Editor(typeof(System.ComponentModel.Design.MultilineStringEditor), typeof(System.Drawing.Design.UITypeEditor))]
		public string Description {
			get {
			    return MetadataObject.Description;
			}
			set {
				
				var oldValue = Description;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DESCRIPTION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.Description = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DESCRIPTION, oldValue, newValue));
				OnPropertyChanged(Properties.DESCRIPTION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeDescription() { return false; }
/// <summary>
///             The dialect of the expression.
///             </summary>
		[DisplayName("Kind")]
		[Category("Options"),Description(@"The dialect of the expression."),IntelliSense(@"The dialect of the expression.")]
		public ExpressionKind Kind {
			get {
			    return (ExpressionKind)MetadataObject.Kind;
			}
			set {
				
				var oldValue = Kind;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.KIND, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.Kind = (TOM.ExpressionKind)newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.KIND, oldValue, newValue));
				OnPropertyChanged(Properties.KIND, oldValue, newValue);
			}
		}
		private bool ShouldSerializeKind() { return false; }
/// <summary>
///             The expression text.
///             </summary>
		[DisplayName("Expression")]
		[Category("Options"),Description(@"The expression text."),IntelliSense(@"The expression text.")][Editor(typeof(System.ComponentModel.Design.MultilineStringEditor), typeof(System.Drawing.Design.UITypeEditor))]
		public string Expression {
			get {
			    return MetadataObject.Expression;
			}
			set {
				
				var oldValue = Expression;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.EXPRESSION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.Expression = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.EXPRESSION, oldValue, newValue));
				OnPropertyChanged(Properties.EXPRESSION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeExpression() { return false; }
/// <summary>
///             The string that has M attributes.
///             </summary><remarks>This property is only supported when the compatibility level of the database is at 1535 or above.</remarks>
		[DisplayName("M Attributes")]
		[Category("Options"),Description(@"The string that has M attributes."),IntelliSense(@"The string that has M attributes.")]
		public string MAttributes {
			get {
			    return MetadataObject.MAttributes;
			}
			set {
				
				var oldValue = MAttributes;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.MATTRIBUTES, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.MAttributes = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.MATTRIBUTES, oldValue, newValue));
				OnPropertyChanged(Properties.MATTRIBUTES, oldValue, newValue);
			}
		}
		private bool ShouldSerializeMAttributes() { return false; }
/// <summary>
///             A tag that represents the lineage of the object.
///             </summary><remarks>This property is only supported when the compatibility level of the database is at 1540 or above.</remarks>
		[DisplayName("Lineage Tag")]
		[Category("Options"),Description(@"A tag that represents the lineage of the object."),IntelliSense(@"A tag that represents the lineage of the object.")]
		public string LineageTag {
			get {
			    return MetadataObject.LineageTag;
			}
			set {
				
				var oldValue = LineageTag;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.LINEAGETAG, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.LineageTag = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.LINEAGETAG, oldValue, newValue));
				OnPropertyChanged(Properties.LINEAGETAG, oldValue, newValue);
			}
		}
		private bool ShouldSerializeLineageTag() { return false; }
/// <summary>
///             A tag that represents the lineage of the source for the object.
///             </summary><remarks>This property is only supported when the compatibility level of the database is at 1550 or above.</remarks>
		[DisplayName("Source Lineage Tag")]
		[Category("Options"),Description(@"A tag that represents the lineage of the source for the object."),IntelliSense(@"A tag that represents the lineage of the source for the object.")]
		public string SourceLineageTag {
			get {
			    return MetadataObject.SourceLineageTag;
			}
			set {
				
				var oldValue = SourceLineageTag;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.SOURCELINEAGETAG, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.SourceLineageTag = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.SOURCELINEAGETAG, oldValue, newValue));
				OnPropertyChanged(Properties.SOURCELINEAGETAG, oldValue, newValue);
			}
		}
		private bool ShouldSerializeSourceLineageTag() { return false; }
/// <summary>
///             Client tools apply filters to this column using M parameter. The presence of this property indicates model owner allows Dax queries to override this parameter, and columns data type must match the type specified in the meta tag of the parameter..
///             </summary><remarks>This property is only supported when the compatibility level of the database is at 1545 or above.</remarks>
		[DisplayName("Parameter Values Column")]
		[Category("Options"),Description(@"Client tools apply filters to this column using M parameter. The presence of this property indicates model owner allows Dax queries to override this parameter, and columns data type must match the type specified in the meta tag of the parameter.."),IntelliSense(@"Client tools apply filters to this column using M parameter. The presence of this property indicates model owner allows Dax queries to override this parameter, and columns data type must match the type specified in the meta tag of the parameter..")][TypeConverter(typeof(AllColumnConverter))]
		public Column ParameterValuesColumn {
			get {
				if (MetadataObject.ParameterValuesColumn == null) return null;
			    return Handler.WrapperLookup[MetadataObject.ParameterValuesColumn] as Column;
            }
			set {
				
				var oldValue = ParameterValuesColumn;
				var newValue = value;
				if (oldValue?.MetadataObject == newValue?.MetadataObject) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.PARAMETERVALUESCOLUMN, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.ParameterValuesColumn = value?.MetadataObject;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.PARAMETERVALUESCOLUMN, oldValue, newValue));
				OnPropertyChanged(Properties.PARAMETERVALUESCOLUMN, oldValue, newValue);
			}
		}
		private bool ShouldSerializeParameterValuesColumn() { return false; }

		internal static NamedExpression CreateFromMetadata(Model parent, TOM.NamedExpression metadataObject) {
            // Generate a new LineageTag if an object with the provided lineage tag already exists:
            if(!string.IsNullOrEmpty(metadataObject.LineageTag)) {
                if (parent.Handler.CompatibilityLevel < 1540) metadataObject.LineageTag = null;
                else if (parent.MetadataObject.Expressions.FindByLineageTag(metadataObject.LineageTag) != metadataObject) {
                    metadataObject.LineageTag = Guid.NewGuid().ToString();
                }
            }
			var obj = new NamedExpression(metadataObject);
			parent.Expressions.Add(obj);
			
			obj.Init();

			return obj;
		}


		/// <summary>
		/// Creates a new NamedExpression and adds it to the parent Model.
		/// Also creates the underlying metadataobject and adds it to the TOM tree.
		/// </summary>
		public static NamedExpression CreateNew(Model parent, string name = null)
		{
			if(!parent.Handler.PowerBIGovernance.AllowCreate(typeof(NamedExpression))) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(NamedExpression).GetTypeName()));
			}

			var metadataObject = new TOM.NamedExpression();
            if(parent.Model.Database.CompatibilityLevel >= 1540) metadataObject.LineageTag = Guid.NewGuid().ToString();
			metadataObject.Name = parent.Expressions.GetNewName(string.IsNullOrWhiteSpace(name) ? "New " + typeof(NamedExpression).GetTypeName() : name);
            InitMetadata(metadataObject, parent);
            var obj = new NamedExpression(metadataObject);

			parent.Expressions.Add(obj);
			
			obj.Init();

			return obj;
		}

        static partial void InitMetadata(TOM.NamedExpression metadataObject, Model parent);

		/// <summary>
		/// Creates a new NamedExpression and adds it to the current Model.
		/// Also creates the underlying metadataobject and adds it to the TOM tree.
		/// </summary>		
		public static NamedExpression CreateNew(string name = null)
		{
			return CreateNew(TabularModelHandler.Singleton.Model, name);
		}


		/// <summary>
		/// Creates an exact copy of this NamedExpression object.
		/// </summary>
		[IntelliSense("Creates an exact copy of this NamedExpression object.")]
		public NamedExpression Clone(string newName = null) {
			if(!Handler.PowerBIGovernance.AllowCreate(this.GetType())) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(NamedExpression).GetTypeName()));
			}

		    Handler.BeginUpdate("Clone NamedExpression");

			// Create a clone of the underlying metadataobject:
			var tom = MetadataObject.Clone() as TOM.NamedExpression;

            if(Model.Database.CompatibilityLevel >= 1540 && !string.IsNullOrEmpty(LineageTag)) {
                tom.LineageTag = Guid.NewGuid().ToString();
            }

			// Assign a new, unique name:
			tom.Name = Parent.Expressions.GetNewName(string.IsNullOrEmpty(newName) ? tom.Name + " copy" : newName);
				
			// Create the TOM Wrapper object, representing the metadataobject
			NamedExpression obj = CreateFromMetadata(Parent, tom);

            Handler.EndUpdate();

            return obj;
		}

		TabularNamedObject IClonableObject.Clone(string newName, bool includeTranslations, TabularNamedObject newParent) 
		{
			if (newParent != null) throw new ArgumentException("This object can not be cloned to another parent. Argument newParent should be left as null.", "newParent");
			return Clone(newName);
		}

	
        internal override void RenewMetadataObject()
        {
            Handler.WrapperLookup.Remove(MetadataObject);
            var json = TOM.JsonSerializer.SerializeObject(MetadataObject, RenewMetadataOptions);
            MetadataObject = TOM.JsonSerializer.DeserializeObject<TOM.NamedExpression>(json);
            Handler.WrapperLookup.Add(MetadataObject, this);
        }

		///<summary>The parent Model of the current Named Expression.</summary>
		public Model Parent { 
			get {
				return Handler.WrapperLookup[MetadataObject.Parent] as Model;
			}
		}



		/// <summary>
		/// CTOR - only called from static factory methods on the class
		/// </summary>
		NamedExpression(TOM.NamedExpression metadataObject) : base(metadataObject)
		{
			
			// Create indexer for annotations:
			Annotations = new AnnotationCollection(this);
			
			// Create indexer for extended properties:
			ExtendedProperties = new ExtendedPropertyCollection(this);
		}



		internal override void Undelete(ITabularObjectCollection collection, Type tomObjectType, string tomJson) {
			base.Undelete(collection, tomObjectType, tomJson);
			Reinit();
			ReapplyReferences();
		}
		internal override sealed bool Browsable(string propertyName) {
			// Allow custom overrides to hide a property regardless of its compatibility level requirements:
			if(!base.Browsable(propertyName)) return false;

			switch (propertyName) {

				// Hide properties based on compatibility requirements (inferred from TOM):
				case Properties.LINEAGETAG:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1540 : Handler.CompatibilityLevel >= 1540;
				case Properties.MATTRIBUTES:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1535 : Handler.CompatibilityLevel >= 1535;
				case Properties.PARAMETERVALUESCOLUMN:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1545 : Handler.CompatibilityLevel >= 1545;
				case Properties.QUERYGROUP:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1480 : Handler.CompatibilityLevel >= 1480;
				case Properties.SOURCELINEAGETAG:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1550 : Handler.CompatibilityLevel >= 1550;
				case Properties.PARENT:
					return false;
				
				default:
					return true;
			}
		}

    }


	/// <summary>
	/// Collection class for NamedExpression. Provides convenient properties for setting a property on multiple objects at once.
	/// </summary>
	public sealed partial class NamedExpressionCollection: TabularObjectCollection<NamedExpression>
	{
		internal Model Model { get { return Parent as Model; } }
		TOM.NamedExpressionCollection TOM_Collection;
		internal NamedExpressionCollection(string collectionName, TOM.NamedExpressionCollection metadataObjectCollection, Model parent) : base(collectionName, parent)
		{
			TOM_Collection = metadataObjectCollection;
		}
		internal override Type GetItemType() { return typeof(NamedExpression); }
        internal override void TOM_Add(TOM.MetadataObject obj) { TOM_Collection.Add(obj as TOM.NamedExpression); }
        internal override bool TOM_Contains(TOM.MetadataObject obj) { return TOM_Collection.Contains(obj as TOM.NamedExpression); }
        internal override void TOM_Remove(TOM.MetadataObject obj) { TOM_Collection.Remove(obj as TOM.NamedExpression); }
        internal override void TOM_Clear() { TOM_Collection.Clear(); }
        internal override bool TOM_ContainsName(string name) { return TOM_Collection.ContainsName(name); }
		internal override TOM.MetadataObject TOM_Get(int index) { return TOM_Collection[index]; }
        internal override TOM.MetadataObject TOM_Get(string name) { return TOM_Collection[name]; }
        internal override TOM.MetadataObject TOM_Find(string name) { return TOM_Collection.Find(name); }
        internal override string GetNewName(string prefix = null) { return string.IsNullOrEmpty(prefix) ? TOM_Collection.GetNewName() : TOM_Collection.GetNewName(prefix); }
        internal override int IndexOf(TOM.MetadataObject obj) { return TOM_Collection.IndexOf(obj as TOM.NamedExpression); }
        /// <summary>The number of items in this collection.</summary>
		public override int Count { get { return TOM_Collection.Count; } }
		/// <summary>Returns an enumerator that iterates through the collection.</summary>
        public override IEnumerator<NamedExpression> GetEnumerator() { return TOM_Collection.Select(h => Handler.WrapperLookup[h]).OfType<NamedExpression>().GetEnumerator(); }
		internal override void Reinit() {
			var ixOffset = 0;
			for(int i = 0; i < Count; i++) {
				var metadataObj = TOM_Get(i) as TOM.NamedExpression;
				var item = Handler.WrapperLookup.TryGetValue(metadataObj, out var existingItem) ? existingItem as NamedExpression : CreateFromMetadata(metadataObj);
				Handler.WrapperLookup.Remove(item.MetadataObject);
				item.MetadataObject = Model.MetadataObject.Expressions[i + ixOffset] as TOM.NamedExpression;
				Handler.WrapperLookup.Add(item.MetadataObject, item);
				item.Collection = this;
			}
			TOM_Collection = Model.MetadataObject.Expressions;
			foreach(var item in this) item.Reinit();
		}

		internal override void ReapplyReferences() {
			foreach(var item in this) item.ReapplyReferences();
		}

		private NamedExpression CreateFromMetadata(TOM.NamedExpression obj)
		{
			if(obj is TOM.NamedExpression namedexpressionObj) return NamedExpression.CreateFromMetadata(Model, namedexpressionObj);
		    return null;
		}

		/// <summary>
		/// Calling this method will populate the NamedExpressionCollection with objects based on the MetadataObjects in the corresponding MetadataObjectCollection.
		/// </summary>
		internal override void CreateChildrenFromMetadata()
		{
			// Construct child objects (they are automatically added to the Handler's WrapperLookup dictionary):
			foreach(var obj in TOM_Collection)
			{
				CreateFromMetadata(obj);
			}
		}

		/// <summary>
		/// Sets the Description property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the Description property of all objects in the collection at once.")]
		public string Description {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("Description"));
				this.ToList().ForEach(item => { item.Description = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the Kind property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the Kind property of all objects in the collection at once.")]
		public ExpressionKind Kind {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("Kind"));
				this.ToList().ForEach(item => { item.Kind = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the Expression property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the Expression property of all objects in the collection at once.")]
		public string Expression {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("Expression"));
				this.ToList().ForEach(item => { item.Expression = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the MAttributes property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the MAttributes property of all objects in the collection at once.")]
		public string MAttributes {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("MAttributes"));
				this.ToList().ForEach(item => { item.MAttributes = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the SourceLineageTag property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the SourceLineageTag property of all objects in the collection at once.")]
		public string SourceLineageTag {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("SourceLineageTag"));
				this.ToList().ForEach(item => { item.SourceLineageTag = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the ParameterValuesColumn property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the ParameterValuesColumn property of all objects in the collection at once.")]
		public Column ParameterValuesColumn {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("ParameterValuesColumn"));
				this.ToList().ForEach(item => { item.ParameterValuesColumn = value; });
				Handler.UndoManager.EndBatch();
			}
		}
	}
  
	/// <summary>
///             Represents a collection of Calculation Items.
///             </summary><remarks>This metadata object is only supported when the compatibility level of the database is at 1470 or above.</remarks>
	[TypeConverter(typeof(DynamicPropertyConverter))]
	public sealed partial class CalculationGroup: TabularObject
			, IDescriptionObject
			, IInternalAnnotationObject
	{
	    internal new TOM.CalculationGroup MetadataObject 
		{ 
			get 
			{ 
				return base.MetadataObject as TOM.CalculationGroup; 
		    } 
			set 
			{ 
				base.MetadataObject = value; 
			}
		}

        private bool CanClearAnnotations() => GetAnnotationsCount() > 0;
        ///<summary>Removes all annotations from this object.</summary>
        [IntelliSense("Removes all annotations from this object.")]
        public void ClearAnnotations()
        {
            Handler.BeginUpdate("Clear annotations");
            foreach(var annotation in GetAnnotations().ToList()) {
                RemoveAnnotation(annotation);
            }
            Handler.EndUpdate();
        }

		///<summary>The collection of Annotations on the current Calculation Group.</summary>
        [Browsable(true),NoMultiselect,Category("Metadata"),Description("The collection of Annotations on the current Calculation Group."),Editor(typeof(AnnotationCollectionEditor), typeof(UITypeEditor))]
        [PropertyAction(nameof(ClearAnnotations))]
		public AnnotationCollection Annotations { get; private set; }
		///<summary>Gets the value of the annotation with the given index, assuming it exists.</summary>
		[IntelliSense("Gets the value of the annotation with the given index, assuming it exists.")]
		public string GetAnnotation(int index) {
			return MetadataObject.Annotations[index].Value;
		}
		///<summary>Returns true if an annotation with the given name exists. Otherwise false.</summary>
		[IntelliSense("Returns true if an annotation with the given name exists. Otherwise false.")]
		public bool HasAnnotation(string name) {
		    return MetadataObject.Annotations.ContainsName(name);
		}
		///<summary>Gets the value of the annotation with the given name. Returns null if no such annotation exists.</summary>
		[IntelliSense("Gets the value of the annotation with the given name. Returns null if no such annotation exists.")]
		public string GetAnnotation(string name) {
		    return HasAnnotation(name) ? MetadataObject.Annotations[name].Value : null;
		}
		///<summary>Sets the value of the annotation with the given index, assuming it exists.</summary>
		[IntelliSense("Sets the value of the annotation with the given index, assuming it exists.")]
		public void SetAnnotation(int index, string value) {
		    SetAnnotation(index, value, true);
		}
		internal void SetAnnotation(int index, string value, bool undoable) {
		    var name = MetadataObject.Annotations[index].Name;
			SetAnnotation(name, value, undoable);
		}
		void IInternalAnnotationObject.SetAnnotation(int index, string value, bool undoable) {
			SetAnnotation(index, value, undoable);
		}
		///<summary>Returns a unique name for a new annotation.</summary>
		public string GetNewAnnotationName() {
			return MetadataObject.Annotations.GetNewName("New Annotation");
		}
		///<summary>Sets the value of the annotation having the given name. If no such annotation exists, it will be created. If value is set to null, the annotation will be removed.</summary>
		[IntelliSense("Sets the value of the annotation having the given name. If no such annotation exists, it will be created. If value is set to null, the annotation will be removed.")]
		public void SetAnnotation(string name, string value) {
		    SetAnnotation(name, value, true);
		}
		internal void SetAnnotation(string name, string value, bool undoable) {
			if(name == null) name = GetNewAnnotationName();

			if(value == null) {
				// Remove annotation if set to null:
				RemoveAnnotation(name, undoable);
				return;
			}

			if(undoable) {
 				if(GetAnnotation(name) == value) return;
				bool undoable2 = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + value, ref undoable2, ref cancel);
				if (cancel) return;
			}

			if(MetadataObject.Annotations.Contains(name)) {
				// Change existing annotation:

				var oldValue = GetAnnotation(name);
				MetadataObject.Annotations[name].Value = value;
				if (undoable) {
					Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, oldValue));
					OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, name + ":" + value);
				}
			} else {
				// Add new annotation:

				MetadataObject.Annotations.Add(new TOM.Annotation{ Name = name, Value = value });
				if (undoable) {
					Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, null));
					OnPropertyChanged(Properties.ANNOTATIONS, null, name + ":" + value);
				}
			}
		}
		void IInternalAnnotationObject.SetAnnotation(string name, string value, bool undoable) {
			this.SetAnnotation(name, value, undoable);
		}
		///<summary>Remove an annotation by the given name.</summary>
		[IntelliSense("Remove an annotation by the given name.")]
		public void RemoveAnnotation(string name) {
		    RemoveAnnotation(name, true);
		}
		internal void RemoveAnnotation(string name, bool undoable) {
			if(MetadataObject.Annotations.Contains(name)) {
				if(undoable) 
				{
				    bool undoable2 = true;
				    bool cancel = false;
				    OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + GetAnnotation(name), ref undoable2, ref cancel);
				    if (cancel) return;
				}

			    var oldValue = MetadataObject.Annotations[name].Value;
				MetadataObject.Annotations.Remove(name);

				if (undoable) 
				{
					Handler.UndoManager.Add(new UndoAnnotationAction(this, name, null, oldValue));
					OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, null);
			    }
			}
		}
		void IInternalAnnotationObject.RemoveAnnotation(string name, bool undoable) {
			this.RemoveAnnotation(name, undoable);
		}
		///<summary>Gets the number of annotations on the current Calculation Group.</summary>
		[IntelliSense("Gets the number of annotations on the current Calculation Group.")]
		public int GetAnnotationsCount() {
			return MetadataObject.Annotations.Count;
		}
		///<summary>Gets a collection of all annotation names on the current Calculation Group.</summary>
		[IntelliSense("Gets a collection of all annotation names on the current Calculation Group.")]
		public IEnumerable<string> GetAnnotations() {
			return MetadataObject.Annotations.Select(a => a.Name);
		}

		/// <summary>
///             The description of the CalculationGroup, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio.
///             </summary>
		[DisplayName("Description")]
		[Category("Basic"),Description(@"The description of the CalculationGroup, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio."),IntelliSense(@"The description of the CalculationGroup, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio.")][Editor(typeof(System.ComponentModel.Design.MultilineStringEditor), typeof(System.Drawing.Design.UITypeEditor))]
		public string Description {
			get {
			    return MetadataObject.Description;
			}
			set {
				
				var oldValue = Description;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DESCRIPTION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.Description = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DESCRIPTION, oldValue, newValue));
				OnPropertyChanged(Properties.DESCRIPTION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeDescription() { return false; }
/// <summary>
///             Defines an evaluation order of CalculationGroup objects.
///             </summary>
		[DisplayName("Precedence")]
		[Category("Options"),Description(@"Defines an evaluation order of CalculationGroup objects."),IntelliSense(@"Defines an evaluation order of CalculationGroup objects.")]
		public int Precedence {
			get {
			    return MetadataObject.Precedence;
			}
			set {
				
				var oldValue = Precedence;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.PRECEDENCE, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.Precedence = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.PRECEDENCE, oldValue, newValue));
				OnPropertyChanged(Properties.PRECEDENCE, oldValue, newValue);
			}
		}
		private bool ShouldSerializePrecedence() { return false; }
		///<summary>The parent table of the current Calculation Group.</summary>
		[Browsable(false)]
		public Table Table
		{ 
			get 
			{ 
				TabularObject t = null;
				if(MetadataObject == null || MetadataObject.Table == null) return null;
				if(!Handler.WrapperLookup.TryGetValue(MetadataObject.Table, out t)) {
				    if(!MetadataObject.Table.IsRemoved)
						t = Model.Tables[MetadataObject.Table.Name];
				}
				return t as Table;
			} 
		}

	
        internal override void RenewMetadataObject()
        {
            Handler.WrapperLookup.Remove(MetadataObject);
            var json = TOM.JsonSerializer.SerializeObject(MetadataObject, RenewMetadataOptions);
            MetadataObject = TOM.JsonSerializer.DeserializeObject<TOM.CalculationGroup>(json);
            Handler.WrapperLookup.Add(MetadataObject, this);
        }


        internal override ITabularObjectCollection GetCollectionForChild(TabularObject child)
        {
			if (child is CalculationItem) return CalculationItems;
            return base.GetCollectionForChild(child);
        }

        /// <summary>
        /// The collection of CalculationItem objects on this CalculationGroup.
        /// </summary>
		[DisplayName("Calculation Items")]
		[Category("Options"),IntelliSense("The collection of Calculation Item objects on the current Calculation Group.")][Browsable(false)]
		public CalculationItemCollection CalculationItems { get; private set; }

		/// <summary>
		/// CTOR - only called from static factory methods on the class
		/// </summary>
		CalculationGroup(TOM.CalculationGroup metadataObject) : base(metadataObject)
		{
			
			// Create indexer for annotations:
			Annotations = new AnnotationCollection(this);
			
			// Instantiate child collections:
			CalculationItems = new CalculationItemCollection(this.GetObjectPath() + ".CalculationItems", MetadataObject.CalculationItems, this);

			// Populate child collections:
			CalculationItems.CreateChildrenFromMetadata();

			// Hook up event handlers on child collections:
			CalculationItems.CollectionChanged += Children_CollectionChanged;
		}


		internal override void Reinit() {
			CalculationItems.Reinit();
		}

		internal override void Undelete(ITabularObjectCollection collection, Type tomObjectType, string tomJson) {
			base.Undelete(collection, tomObjectType, tomJson);
			Reinit();
			ReapplyReferences();
		}
		internal override sealed bool Browsable(string propertyName) {
			// Allow custom overrides to hide a property regardless of its compatibility level requirements:
			if(!base.Browsable(propertyName)) return false;

			switch (propertyName) {

				// Hide properties based on compatibility requirements (inferred from TOM):
				
				default:
					return true;
			}
		}

    }

  
	/// <summary>
///             A Tabular Calculation Item.
///             </summary><remarks>This metadata object is only supported when the compatibility level of the database is at 1470 or above.</remarks>
	[TypeConverter(typeof(DynamicPropertyConverter))]
	public sealed partial class CalculationItem: TabularNamedObject
			, IErrorMessageObject
			, IDescriptionObject
			, IExpressionObject
			, IClonableObject
	{
	    internal new TOM.CalculationItem MetadataObject 
		{ 
			get 
			{ 
				return base.MetadataObject as TOM.CalculationItem; 
		    } 
			set 
			{ 
				base.MetadataObject = value; 
			}
		}

/// <summary>
///             The description of the CalculationItem, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio.
///             </summary>
		[DisplayName("Description")]
		[Category("Basic"),Description(@"The description of the CalculationItem, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio."),IntelliSense(@"The description of the CalculationItem, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio.")][Editor(typeof(System.ComponentModel.Design.MultilineStringEditor), typeof(System.Drawing.Design.UITypeEditor))]
		public string Description {
			get {
			    return MetadataObject.Description;
			}
			set {
				
				var oldValue = Description;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DESCRIPTION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.Description = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DESCRIPTION, oldValue, newValue));
				OnPropertyChanged(Properties.DESCRIPTION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeDescription() { return false; }
/// <summary>
///             Provides information on the state of the Expression. Possible values and their interpretation are as follows. Ready (1) The Expression is queryable and has up-to-date data. SemanticError (5) The Expression has a semantic error. DependencyError (7) A dependency associated with this Expression is in an error state (SemanticError, EvaluationError, or DependencyError). SyntaxError (9) The Expression has a syntax error.
///             </summary>
		[DisplayName("State")]
		[Category("Metadata"),Description(@"Provides information on the state of the Expression. Possible values and their interpretation are as follows. Ready (1) The Expression is queryable and has up-to-date data. SemanticError (5) The Expression has a semantic error. DependencyError (7) A dependency associated with this Expression is in an error state (SemanticError, EvaluationError, or DependencyError). SyntaxError (9) The Expression has a syntax error."),IntelliSense(@"Provides information on the state of the Expression. Possible values and their interpretation are as follows. Ready (1) The Expression is queryable and has up-to-date data. SemanticError (5) The Expression has a semantic error. DependencyError (7) A dependency associated with this Expression is in an error state (SemanticError, EvaluationError, or DependencyError). SyntaxError (9) The Expression has a syntax error.")]
		public ObjectState State {
			get {
			    return (ObjectState)MetadataObject.State;
			}
			
		}
		private bool ShouldSerializeState() { return false; }
/// <summary>
///             The DAX expression that is evaluated for this CalculationItem.
///             </summary>
		[DisplayName("Expression")]
		[Category("Options"),Description(@"The DAX expression that is evaluated for this CalculationItem."),IntelliSense(@"The DAX expression that is evaluated for this CalculationItem.")][Editor(typeof(System.ComponentModel.Design.MultilineStringEditor), typeof(System.Drawing.Design.UITypeEditor))]
		public string Expression {
			get {
			    return MetadataObject.Expression;
			}
			set {
				
				var oldValue = Expression;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.EXPRESSION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.Expression = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.EXPRESSION, oldValue, newValue));
				OnPropertyChanged(Properties.EXPRESSION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeExpression() { return false; }
/// <summary>
///             The zero-based ordinal value associated with a Calculation Item.
///             </summary><remarks>This property is only supported when the compatibility level of the database is at 1500 or above.</remarks>
		[DisplayName("Ordinal")]
		[Category("Basic"),Description(@"The zero-based ordinal value associated with a Calculation Item."),IntelliSense(@"The zero-based ordinal value associated with a Calculation Item.")][NoMultiselect()]
		public int Ordinal {
			get {
			    return MetadataObject.Ordinal;
			}
			set {
				
				var oldValue = Ordinal;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ORDINAL, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.Ordinal = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.ORDINAL, oldValue, newValue));
				OnPropertyChanged(Properties.ORDINAL, oldValue, newValue);
			}
		}
		private bool ShouldSerializeOrdinal() { return false; }

		internal static CalculationItem CreateFromMetadata(CalculationGroup parent, TOM.CalculationItem metadataObject) {
			var obj = new CalculationItem(metadataObject);
			parent.CalculationItems.Add(obj);
			
			obj.Init();

			return obj;
		}


		/// <summary>
		/// Creates a new CalculationItem and adds it to the parent CalculationGroup.
		/// Also creates the underlying metadataobject and adds it to the TOM tree.
		/// </summary>
		public static CalculationItem CreateNew(CalculationGroup parent, string name = null)
		{
			if(!parent.Handler.PowerBIGovernance.AllowCreate(typeof(CalculationItem))) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(CalculationItem).GetTypeName()));
			}

			var metadataObject = new TOM.CalculationItem();
			metadataObject.Name = parent.CalculationItems.GetNewName(string.IsNullOrWhiteSpace(name) ? "New " + typeof(CalculationItem).GetTypeName() : name);
            InitMetadata(metadataObject, parent);
            var obj = new CalculationItem(metadataObject);

			parent.CalculationItems.Add(obj);
			
			obj.Init();

			return obj;
		}

        static partial void InitMetadata(TOM.CalculationItem metadataObject, CalculationGroup parent);


		/// <summary>
		/// Creates an exact copy of this CalculationItem object.
		/// </summary>
		[IntelliSense("Creates an exact copy of this CalculationItem object.")]
		public CalculationItem Clone(string newName = null, CalculationGroup newParent = null) {
			if(!Handler.PowerBIGovernance.AllowCreate(this.GetType())) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(CalculationItem).GetTypeName()));
			}

		    Handler.BeginUpdate("Clone CalculationItem");

			// Create a clone of the underlying metadataobject:
			var tom = MetadataObject.Clone() as TOM.CalculationItem;


			// Assign a new, unique name:
			tom.Name = Parent.CalculationItems.GetNewName(string.IsNullOrEmpty(newName) ? tom.Name + " copy" : newName);
				
			// Create the TOM Wrapper object, representing the metadataobject
			CalculationItem obj = CreateFromMetadata(newParent ?? Parent, tom);

            Handler.EndUpdate();

            return obj;
		}

		TabularNamedObject IClonableObject.Clone(string newName, bool includeTranslations, TabularNamedObject newParent) 
		{
			return Clone(newName);
		}

	
        internal override void RenewMetadataObject()
        {
            Handler.WrapperLookup.Remove(MetadataObject);
            var json = TOM.JsonSerializer.SerializeObject(MetadataObject, RenewMetadataOptions);
            MetadataObject = TOM.JsonSerializer.DeserializeObject<TOM.CalculationItem>(json);
            Handler.WrapperLookup.Add(MetadataObject, this);
        }

		///<summary>The parent Calculation Group of the current Calculation Item.</summary>
		public CalculationGroup Parent { 
			get {
				return Handler.WrapperLookup[MetadataObject.Parent] as CalculationGroup;
			}
		}



		/// <summary>
		/// CTOR - only called from static factory methods on the class
		/// </summary>
		CalculationItem(TOM.CalculationItem metadataObject) : base(metadataObject)
		{
		}



		internal override void Undelete(ITabularObjectCollection collection, Type tomObjectType, string tomJson) {
			base.Undelete(collection, tomObjectType, tomJson);
			Reinit();
			ReapplyReferences();
		}
		internal override sealed bool Browsable(string propertyName) {
			// Allow custom overrides to hide a property regardless of its compatibility level requirements:
			if(!base.Browsable(propertyName)) return false;

			switch (propertyName) {

				// Hide properties based on compatibility requirements (inferred from TOM):
				case Properties.ORDINAL:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1500 : Handler.CompatibilityLevel >= 1500;
				case Properties.PARENT:
					return false;
				
				default:
					return true;
			}
		}

    }


	/// <summary>
	/// Collection class for CalculationItem. Provides convenient properties for setting a property on multiple objects at once.
	/// </summary>
	public sealed partial class CalculationItemCollection: TabularObjectCollection<CalculationItem>
	{
		internal CalculationGroup CalculationGroup { get { return Parent as CalculationGroup; } }
		TOM.CalculationItemCollection TOM_Collection;
		internal CalculationItemCollection(string collectionName, TOM.CalculationItemCollection metadataObjectCollection, CalculationGroup parent) : base(collectionName, parent)
		{
			TOM_Collection = metadataObjectCollection;
		}
		internal override Type GetItemType() { return typeof(CalculationItem); }
        internal override void TOM_Add(TOM.MetadataObject obj) { TOM_Collection.Add(obj as TOM.CalculationItem); }
        internal override bool TOM_Contains(TOM.MetadataObject obj) { return TOM_Collection.Contains(obj as TOM.CalculationItem); }
        internal override void TOM_Remove(TOM.MetadataObject obj) { TOM_Collection.Remove(obj as TOM.CalculationItem); }
        internal override void TOM_Clear() { TOM_Collection.Clear(); }
        internal override bool TOM_ContainsName(string name) { return TOM_Collection.ContainsName(name); }
		internal override TOM.MetadataObject TOM_Get(int index) { return TOM_Collection[index]; }
        internal override TOM.MetadataObject TOM_Get(string name) { return TOM_Collection[name]; }
        internal override TOM.MetadataObject TOM_Find(string name) { return TOM_Collection.Find(name); }
        internal override string GetNewName(string prefix = null) { return string.IsNullOrEmpty(prefix) ? TOM_Collection.GetNewName() : TOM_Collection.GetNewName(prefix); }
        internal override int IndexOf(TOM.MetadataObject obj) { return TOM_Collection.IndexOf(obj as TOM.CalculationItem); }
        /// <summary>The number of items in this collection.</summary>
		public override int Count { get { return TOM_Collection.Count; } }
		/// <summary>Returns an enumerator that iterates through the collection.</summary>
        public override IEnumerator<CalculationItem> GetEnumerator() { return TOM_Collection.Select(h => Handler.WrapperLookup[h]).OfType<CalculationItem>().GetEnumerator(); }
		internal override void Reinit() {
			var ixOffset = 0;
			for(int i = 0; i < Count; i++) {
				var metadataObj = TOM_Get(i) as TOM.CalculationItem;
				var item = Handler.WrapperLookup.TryGetValue(metadataObj, out var existingItem) ? existingItem as CalculationItem : CreateFromMetadata(metadataObj);
				Handler.WrapperLookup.Remove(item.MetadataObject);
				item.MetadataObject = CalculationGroup.MetadataObject.CalculationItems[i + ixOffset] as TOM.CalculationItem;
				Handler.WrapperLookup.Add(item.MetadataObject, item);
				item.Collection = this;
			}
			TOM_Collection = CalculationGroup.MetadataObject.CalculationItems;
			foreach(var item in this) item.Reinit();
		}

		internal override void ReapplyReferences() {
			foreach(var item in this) item.ReapplyReferences();
		}

		private CalculationItem CreateFromMetadata(TOM.CalculationItem obj)
		{
			if(obj is TOM.CalculationItem calculationitemObj) return CalculationItem.CreateFromMetadata(CalculationGroup, calculationitemObj);
		    return null;
		}

		/// <summary>
		/// Calling this method will populate the CalculationItemCollection with objects based on the MetadataObjects in the corresponding MetadataObjectCollection.
		/// </summary>
		internal override void CreateChildrenFromMetadata()
		{
			// Construct child objects (they are automatically added to the Handler's WrapperLookup dictionary):
			foreach(var obj in TOM_Collection)
			{
				CreateFromMetadata(obj);
			}
		}

		/// <summary>
		/// Sets the Description property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the Description property of all objects in the collection at once.")]
		public string Description {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("Description"));
				this.ToList().ForEach(item => { item.Description = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the Expression property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the Expression property of all objects in the collection at once.")]
		public string Expression {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("Expression"));
				this.ToList().ForEach(item => { item.Expression = value; });
				Handler.UndoManager.EndBatch();
			}
		}
	}
  
	/// <summary>
///             Defines the security rules of the Role on the Table. It is a child of a Role object.
///             </summary>
	[TypeConverter(typeof(DynamicPropertyConverter))]
	public sealed partial class TablePermission: TabularNamedObject
			, IErrorMessageObject
			, IInternalAnnotationObject
			, IInternalExtendedPropertyObject
			, IClonableObject
	{
	    internal new TOM.TablePermission MetadataObject 
		{ 
			get 
			{ 
				return base.MetadataObject as TOM.TablePermission; 
		    } 
			set 
			{ 
				base.MetadataObject = value; 
			}
		}

        private bool CanClearAnnotations() => GetAnnotationsCount() > 0;
        ///<summary>Removes all annotations from this object.</summary>
        [IntelliSense("Removes all annotations from this object.")]
        public void ClearAnnotations()
        {
            Handler.BeginUpdate("Clear annotations");
            foreach(var annotation in GetAnnotations().ToList()) {
                RemoveAnnotation(annotation);
            }
            Handler.EndUpdate();
        }

		///<summary>The collection of Annotations on the current Table Permission.</summary>
        [Browsable(true),NoMultiselect,Category("Metadata"),Description("The collection of Annotations on the current Table Permission."),Editor(typeof(AnnotationCollectionEditor), typeof(UITypeEditor))]
        [PropertyAction(nameof(ClearAnnotations))]
		public AnnotationCollection Annotations { get; private set; }
		///<summary>Gets the value of the annotation with the given index, assuming it exists.</summary>
		[IntelliSense("Gets the value of the annotation with the given index, assuming it exists.")]
		public string GetAnnotation(int index) {
			return MetadataObject.Annotations[index].Value;
		}
		///<summary>Returns true if an annotation with the given name exists. Otherwise false.</summary>
		[IntelliSense("Returns true if an annotation with the given name exists. Otherwise false.")]
		public bool HasAnnotation(string name) {
		    return MetadataObject.Annotations.ContainsName(name);
		}
		///<summary>Gets the value of the annotation with the given name. Returns null if no such annotation exists.</summary>
		[IntelliSense("Gets the value of the annotation with the given name. Returns null if no such annotation exists.")]
		public string GetAnnotation(string name) {
		    return HasAnnotation(name) ? MetadataObject.Annotations[name].Value : null;
		}
		///<summary>Sets the value of the annotation with the given index, assuming it exists.</summary>
		[IntelliSense("Sets the value of the annotation with the given index, assuming it exists.")]
		public void SetAnnotation(int index, string value) {
		    SetAnnotation(index, value, true);
		}
		internal void SetAnnotation(int index, string value, bool undoable) {
		    var name = MetadataObject.Annotations[index].Name;
			SetAnnotation(name, value, undoable);
		}
		void IInternalAnnotationObject.SetAnnotation(int index, string value, bool undoable) {
			SetAnnotation(index, value, undoable);
		}
		///<summary>Returns a unique name for a new annotation.</summary>
		public string GetNewAnnotationName() {
			return MetadataObject.Annotations.GetNewName("New Annotation");
		}
		///<summary>Sets the value of the annotation having the given name. If no such annotation exists, it will be created. If value is set to null, the annotation will be removed.</summary>
		[IntelliSense("Sets the value of the annotation having the given name. If no such annotation exists, it will be created. If value is set to null, the annotation will be removed.")]
		public void SetAnnotation(string name, string value) {
		    SetAnnotation(name, value, true);
		}
		internal void SetAnnotation(string name, string value, bool undoable) {
			if(name == null) name = GetNewAnnotationName();

			if(value == null) {
				// Remove annotation if set to null:
				RemoveAnnotation(name, undoable);
				return;
			}

			if(undoable) {
 				if(GetAnnotation(name) == value) return;
				bool undoable2 = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + value, ref undoable2, ref cancel);
				if (cancel) return;
			}

			if(MetadataObject.Annotations.Contains(name)) {
				// Change existing annotation:

				var oldValue = GetAnnotation(name);
				MetadataObject.Annotations[name].Value = value;
				if (undoable) {
					Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, oldValue));
					OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, name + ":" + value);
				}
			} else {
				// Add new annotation:

				MetadataObject.Annotations.Add(new TOM.Annotation{ Name = name, Value = value });
				if (undoable) {
					Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, null));
					OnPropertyChanged(Properties.ANNOTATIONS, null, name + ":" + value);
				}
			}
		}
		void IInternalAnnotationObject.SetAnnotation(string name, string value, bool undoable) {
			this.SetAnnotation(name, value, undoable);
		}
		///<summary>Remove an annotation by the given name.</summary>
		[IntelliSense("Remove an annotation by the given name.")]
		public void RemoveAnnotation(string name) {
		    RemoveAnnotation(name, true);
		}
		internal void RemoveAnnotation(string name, bool undoable) {
			if(MetadataObject.Annotations.Contains(name)) {
				if(undoable) 
				{
				    bool undoable2 = true;
				    bool cancel = false;
				    OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + GetAnnotation(name), ref undoable2, ref cancel);
				    if (cancel) return;
				}

			    var oldValue = MetadataObject.Annotations[name].Value;
				MetadataObject.Annotations.Remove(name);

				if (undoable) 
				{
					Handler.UndoManager.Add(new UndoAnnotationAction(this, name, null, oldValue));
					OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, null);
			    }
			}
		}
		void IInternalAnnotationObject.RemoveAnnotation(string name, bool undoable) {
			this.RemoveAnnotation(name, undoable);
		}
		///<summary>Gets the number of annotations on the current Table Permission.</summary>
		[IntelliSense("Gets the number of annotations on the current Table Permission.")]
		public int GetAnnotationsCount() {
			return MetadataObject.Annotations.Count;
		}
		///<summary>Gets a collection of all annotation names on the current Table Permission.</summary>
		[IntelliSense("Gets a collection of all annotation names on the current Table Permission.")]
		public IEnumerable<string> GetAnnotations() {
			return MetadataObject.Annotations.Select(a => a.Name);
		}

		        private bool CanClearExtendedProperties() => GetExtendedPropertyCount() > 0;
        ///<summary>Removes all Extended Properties from this object.</summary>
        [IntelliSense("Removes all Extended Properties from this object.")]
        public void ClearExtendedProperties()
        {
            Handler.BeginUpdate("Clear extended properties");
            foreach(var extendedProperty in GetExtendedProperties().ToList()) {
                RemoveExtendedProperty(extendedProperty);
            }
            Handler.EndUpdate();
        }

		///<summary>The collection of Extended Properties on the current Table Permission.</summary>
        [DisplayName("Extended Properties"),NoMultiselect,Category("Metadata"),Description("The collection of Extended Properties on the current Table Permission."),Editor(typeof(ExtendedPropertyCollectionEditor), typeof(UITypeEditor))]
        [PropertyAction(nameof(ClearExtendedProperties))]
		public ExtendedPropertyCollection ExtendedProperties { get; private set; }

		///<summary>Returns true if an ExtendedProperty with the given name exists. Otherwise false.</summary>
		[IntelliSense("Returns true if an ExtendedProperty with the given name exists. Otherwise false.")]
		public bool HasExtendedProperty(string name) {
		    return MetadataObject.ExtendedProperties.ContainsName(name);
		}
		///<summary>Gets the type of the ExtendedProperty with the given index, assuming it exists.</summary>
		public ExtendedPropertyType GetExtendedPropertyType(int index) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[index].Type;
		}
		///<summary>Gets the type of the ExtendedProperty with the given name, assuming it exists.</summary>
		public ExtendedPropertyType GetExtendedPropertyType(string name) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[name].Type;
		}
		///<summary>Gets the value of the ExtendedProperty with the given index, assuming it exists.</summary>
		public string GetExtendedProperty(int index) {
			var ep = MetadataObject.ExtendedProperties[index];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		///<summary>Gets the value of the ExtendedProperty with the given name. Returns null if no such ExtendedProperty exists.</summary>
		[IntelliSense("Gets the value of the ExtendedProperty with the given name. Returns null if no such ExtendedProperty exists.")]
		public string GetExtendedProperty(string name) {
		    if(!HasExtendedProperty(name)) return null;
			var ep = MetadataObject.ExtendedProperties[name];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		///<summary>Sets the value of the ExtendedProperty with the given index, optionally specifiying the type (string or JSON) of the ExtendedProperty.</summary>
		public void SetExtendedProperty(int index, string value, ExtendedPropertyType type) {
			SetExtendedProperty(index, value, type, true);
		}
		void IInternalExtendedPropertyObject.SetExtendedProperty(int index, string value, ExtendedPropertyType type, bool undoable) {
			SetExtendedProperty(index, value, type, undoable);
		}
		internal void SetExtendedProperty(int index, string value, ExtendedPropertyType type, bool undoable) {
			var name = MetadataObject.ExtendedProperties[index].Name;
			SetExtendedProperty(name, value, type, undoable);
		}
		///<summary>Returns a unique name for a new ExtendedProperty.</summary>
		public string GetNewExtendedPropertyName() {
			return MetadataObject.ExtendedProperties.GetNewName("New ExtendedProperty");
		}
		///<summary>Sets the value of the ExtendedProperty having the given name. If no such ExtendedProperty exists, it will be created. If value is set to null, the ExtendedProperty will be removed.</summary>
		[IntelliSense("Sets the value of the ExtendedProperty having the given name. If no such ExtendedProperty exists, it will be created. If value is set to null, the ExtendedProperty will be removed.")]
		public void SetExtendedProperty(string name, string value, ExtendedPropertyType type) {
			SetExtendedProperty(name, value, type, true);
		}
		internal void SetExtendedProperty(string name, string value, ExtendedPropertyType type, bool undoable) {
			if(name == null) name = GetNewExtendedPropertyName();

			if(value == null) {
				// Remove ExtendedProperty if set to null:
				RemoveExtendedProperty(name);
				return;
			}

			if(GetExtendedProperty(name) == value) return;
			if(undoable) {
				bool cancel = false;
				OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + value, ref undoable, ref cancel);
				if (cancel) return;
			}

			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Change existing ExtendedProperty:
				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				var ep = MetadataObject.ExtendedProperties[name];
				if (ep is TOM.JsonExtendedProperty)
					(ep as TOM.JsonExtendedProperty).Value = value;
				else 
					(ep as TOM.StringExtendedProperty).Value = value;
					
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, name + ":" + value);
			} else {
				// Add new ExtendedProperty:
				if (type == ExtendedPropertyType.Json)
					MetadataObject.ExtendedProperties.Add(new TOM.JsonExtendedProperty{ Name = name, Value = value });
				else
					MetadataObject.ExtendedProperties.Add(new TOM.StringExtendedProperty{ Name = name, Value = value });

				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, null, type));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, null, name + ":" + value);
			}
		}
		void IInternalExtendedPropertyObject.SetExtendedProperty(string name, string value, ExtendedPropertyType type, bool undoable) {
			this.SetExtendedProperty(name, value, type, undoable);
		}

		///<summary>Remove an ExtendedProperty by the given name.</summary>
		[IntelliSense("Remove an ExtendedProperty by the given name.")]
		public void RemoveExtendedProperty(string name) {
			RemoveExtendedProperty(name, true);
		}

		internal void RemoveExtendedProperty(string name, bool undoable) {
			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Get current value:
				if(undoable) {
					bool cancel = false;
					OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + GetExtendedProperty(name), ref undoable, ref cancel);
					if (cancel) return;
				}

				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				MetadataObject.ExtendedProperties.Remove(name);

				// Undo-handling:
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, null, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, null);
			}
		}
		void IInternalExtendedPropertyObject.RemoveExtendedProperty(string name, bool undoable) {
			this.RemoveExtendedProperty(name, undoable);
		}
		///<summary>Gets the number of ExtendedProperties on the current object.</summary>
		[IntelliSense("Gets the number of ExtendedProperties on the current object.")]
		public int GetExtendedPropertyCount() {
			return MetadataObject.ExtendedProperties.Count;
		}
		///<summary>Gets a collection of all ExtendedProperty names on the current object.</summary>
		[IntelliSense("Gets a collection of all ExtendedProperty names on the current object.")]
		public IEnumerable<string> GetExtendedProperties() {
			return MetadataObject.ExtendedProperties.Select(a => a.Name);
		}

		/// <summary>
///             The DAX expression that filters the rows in the table when this security role is in effect.
///             </summary>
		[DisplayName("Filter Expression")]
		[Category("Translations, Perspectives, Security"),Description(@"The DAX expression that filters the rows in the table when this security role is in effect."),IntelliSense(@"The DAX expression that filters the rows in the table when this security role is in effect.")][Editor(typeof(System.ComponentModel.Design.MultilineStringEditor), typeof(System.Drawing.Design.UITypeEditor))]
		public string FilterExpression {
			get {
			    return MetadataObject.FilterExpression;
			}
			set {
				
				var oldValue = FilterExpression;
				var newValue = value?.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.FILTEREXPRESSION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.FilterExpression = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.FILTEREXPRESSION, oldValue, newValue));
				OnPropertyChanged(Properties.FILTEREXPRESSION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeFilterExpression() { return false; }
/// <summary>
///             Provides information on the state of the permission. Possible values and their interpretation are as follows. Ready (1) The permission has a valid expression. NoData (3) Not applicable. CalculationNeeded (4) Not applicable. SemanticError (5) The expression of the TablePermission object has a semantic error. EvaluationError (6) Not applicable. DependencyError (7) A dependency associated with this TablePermission object is in an error state (SemanticError, EvaluationError, or DependencyError). Incomplete (8) Not applicable. SyntaxError (9) The TablePermission object is in an error state because of a syntax error in its expression. The TablePermission object is not queryable. This state applies only to TablePermission objects of the type Calculated.
///             </summary>
		[DisplayName("State")]
		[Category("Metadata"),Description(@"Provides information on the state of the permission. Possible values and their interpretation are as follows. Ready (1) The permission has a valid expression. NoData (3) Not applicable. CalculationNeeded (4) Not applicable. SemanticError (5) The expression of the TablePermission object has a semantic error. EvaluationError (6) Not applicable. DependencyError (7) A dependency associated with this TablePermission object is in an error state (SemanticError, EvaluationError, or DependencyError). Incomplete (8) Not applicable. SyntaxError (9) The TablePermission object is in an error state because of a syntax error in its expression. The TablePermission object is not queryable. This state applies only to TablePermission objects of the type Calculated."),IntelliSense(@"Provides information on the state of the permission. Possible values and their interpretation are as follows. Ready (1) The permission has a valid expression. NoData (3) Not applicable. CalculationNeeded (4) Not applicable. SemanticError (5) The expression of the TablePermission object has a semantic error. EvaluationError (6) Not applicable. DependencyError (7) A dependency associated with this TablePermission object is in an error state (SemanticError, EvaluationError, or DependencyError). Incomplete (8) Not applicable. SyntaxError (9) The TablePermission object is in an error state because of a syntax error in its expression. The TablePermission object is not queryable. This state applies only to TablePermission objects of the type Calculated.")]
		public ObjectState State {
			get {
			    return (ObjectState)MetadataObject.State;
			}
			
		}
		private bool ShouldSerializeState() { return false; }
/// <summary>
///             A string that explains the error state associated with the current object. It is set by the engine only when the state of the object is one of these three values: SemanticError, DependencyError, or EvaluationError.
///             </summary>
		[DisplayName("Error Message")]
		[Category("Metadata"),Description(@"A string that explains the error state associated with the current object. It is set by the engine only when the state of the object is one of these three values: SemanticError, DependencyError, or EvaluationError."),IntelliSense(@"A string that explains the error state associated with the current object. It is set by the engine only when the state of the object is one of these three values: SemanticError, DependencyError, or EvaluationError.")]
		public string ErrorMessage {
			get {
			    return MetadataObject.ErrorMessage;
			}
			
		}
		private bool ShouldSerializeErrorMessage() { return false; }
/// <summary>
///             Defines whether the metadata of this table should be secured from users belonging to this role.
///             </summary><remarks>This property is only supported when the compatibility level of the database is at 1400 or above.</remarks>
		[DisplayName("OLS Table Permission")]
		[Category("Translations, Perspectives, Security"),Description(@"Defines whether the metadata of this table should be secured from users belonging to this role."),IntelliSense(@"Defines whether the metadata of this table should be secured from users belonging to this role.")]
		public MetadataPermission MetadataPermission {
			get {
			    return (MetadataPermission)MetadataObject.MetadataPermission;
			}
			set {
				
				var oldValue = MetadataPermission;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.METADATAPERMISSION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				if (!MetadataObject.IsRemoved) MetadataObject.MetadataPermission = (TOM.MetadataPermission)newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.METADATAPERMISSION, oldValue, newValue));
				OnPropertyChanged(Properties.METADATAPERMISSION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeMetadataPermission() { return false; }
/// <summary>
///             A reference to a Role object that owns this TablePermission.
///             </summary>
		[DisplayName("Role")]
		[Category("Options"),Description(@"A reference to a Role object that owns this TablePermission."),IntelliSense(@"A reference to a Role object that owns this TablePermission.")]
		public ModelRole Role {
			get {
				if (MetadataObject.Role == null) return null;
			    return Handler.WrapperLookup[MetadataObject.Role] as ModelRole;
            }
			
		}
		private bool ShouldSerializeRole() { return false; }
		///<summary>The parent table of the current Table Permission.</summary>
		[Browsable(false)]
		public Table Table
		{ 
			get 
			{ 
				TabularObject t = null;
				if(MetadataObject == null || MetadataObject.Table == null) return null;
				if(!Handler.WrapperLookup.TryGetValue(MetadataObject.Table, out t)) {
				    if(!MetadataObject.Table.IsRemoved)
						t = Model.Tables[MetadataObject.Table.Name];
				}
				return t as Table;
			} 
		}

		internal static TablePermission CreateFromMetadata(ModelRole parent, TOM.TablePermission metadataObject) {
			var obj = new TablePermission(metadataObject);
			parent.TablePermissions.Add(obj);
			
			obj.Init();

			return obj;
		}


		/// <summary>
		/// Creates a new TablePermission and adds it to the parent ModelRole.
		/// Also creates the underlying metadataobject and adds it to the TOM tree.
		/// </summary>
		public static TablePermission CreateNew(ModelRole parent, string name = null)
		{
			if(!parent.Handler.PowerBIGovernance.AllowCreate(typeof(TablePermission))) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(TablePermission).GetTypeName()));
			}

			var metadataObject = new TOM.TablePermission();
			metadataObject.Name = parent.TablePermissions.GetNewName(string.IsNullOrWhiteSpace(name) ? "New " + typeof(TablePermission).GetTypeName() : name);
            InitMetadata(metadataObject, parent);
            var obj = new TablePermission(metadataObject);

			parent.TablePermissions.Add(obj);
			
			obj.Init();

			return obj;
		}

        static partial void InitMetadata(TOM.TablePermission metadataObject, ModelRole parent);


		/// <summary>
		/// Creates an exact copy of this TablePermission object.
		/// </summary>
		[IntelliSense("Creates an exact copy of this TablePermission object.")]
		public TablePermission Clone(string newName = null, ModelRole newParent = null) {
			if(!Handler.PowerBIGovernance.AllowCreate(this.GetType())) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(TablePermission).GetTypeName()));
			}

		    Handler.BeginUpdate("Clone TablePermission");

			// Create a clone of the underlying metadataobject:
			var tom = MetadataObject.Clone() as TOM.TablePermission;


			// Assign a new, unique name:
			tom.Name = Parent.TablePermissions.GetNewName(string.IsNullOrEmpty(newName) ? tom.Name + " copy" : newName);
				
			// Create the TOM Wrapper object, representing the metadataobject
			TablePermission obj = CreateFromMetadata(newParent ?? Parent, tom);

            Handler.EndUpdate();

            return obj;
		}

		TabularNamedObject IClonableObject.Clone(string newName, bool includeTranslations, TabularNamedObject newParent) 
		{
			return Clone(newName);
		}

	
        internal override void RenewMetadataObject()
        {
            Handler.WrapperLookup.Remove(MetadataObject);
            var json = TOM.JsonSerializer.SerializeObject(MetadataObject, RenewMetadataOptions);
            MetadataObject = TOM.JsonSerializer.DeserializeObject<TOM.TablePermission>(json);
            Handler.WrapperLookup.Add(MetadataObject, this);
        }

		///<summary>The parent Model Role of the current Table Permission.</summary>
		public ModelRole Parent { 
			get {
				return Handler.WrapperLookup[MetadataObject.Parent] as ModelRole;
			}
		}



		/// <summary>
		/// CTOR - only called from static factory methods on the class
		/// </summary>
		TablePermission(TOM.TablePermission metadataObject) : base(metadataObject)
		{
			
			// Create indexer for annotations:
			Annotations = new AnnotationCollection(this);
			
			// Create indexer for extended properties:
			ExtendedProperties = new ExtendedPropertyCollection(this);
		}



		internal override void Undelete(ITabularObjectCollection collection, Type tomObjectType, string tomJson) {
			base.Undelete(collection, tomObjectType, tomJson);
			Reinit();
			ReapplyReferences();
		}
		internal override sealed bool Browsable(string propertyName) {
			// Allow custom overrides to hide a property regardless of its compatibility level requirements:
			if(!base.Browsable(propertyName)) return false;

			switch (propertyName) {

				// Hide properties based on compatibility requirements (inferred from TOM):
				case Properties.COLUMNPERMISSIONS:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1400 : Handler.CompatibilityLevel >= 1400;
				case Properties.EXTENDEDPROPERTIES:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1400 : Handler.CompatibilityLevel >= 1400;
				case Properties.METADATAPERMISSION:
					return Handler.PbiMode ? Handler.CompatibilityLevel >= 1400 : Handler.CompatibilityLevel >= 1400;
				case Properties.PARENT:
					return false;
				
				default:
					return true;
			}
		}

    }


	/// <summary>
	/// Collection class for TablePermission. Provides convenient properties for setting a property on multiple objects at once.
	/// </summary>
	public sealed partial class TablePermissionCollection: TabularObjectCollection<TablePermission>
	{
		internal ModelRole ModelRole { get { return Parent as ModelRole; } }
		TOM.TablePermissionCollection TOM_Collection;
		internal TablePermissionCollection(string collectionName, TOM.TablePermissionCollection metadataObjectCollection, ModelRole parent) : base(collectionName, parent)
		{
			TOM_Collection = metadataObjectCollection;
		}
		internal override Type GetItemType() { return typeof(TablePermission); }
        internal override void TOM_Add(TOM.MetadataObject obj) { TOM_Collection.Add(obj as TOM.TablePermission); }
        internal override bool TOM_Contains(TOM.MetadataObject obj) { return TOM_Collection.Contains(obj as TOM.TablePermission); }
        internal override void TOM_Remove(TOM.MetadataObject obj) { TOM_Collection.Remove(obj as TOM.TablePermission); }
        internal override void TOM_Clear() { TOM_Collection.Clear(); }
        internal override bool TOM_ContainsName(string name) { return TOM_Collection.ContainsName(name); }
		internal override TOM.MetadataObject TOM_Get(int index) { return TOM_Collection[index]; }
        internal override TOM.MetadataObject TOM_Get(string name) { return TOM_Collection[name]; }
        internal override TOM.MetadataObject TOM_Find(string name) { return TOM_Collection.Find(name); }
        internal override string GetNewName(string prefix = null) { return string.IsNullOrEmpty(prefix) ? TOM_Collection.GetNewName() : TOM_Collection.GetNewName(prefix); }
        internal override int IndexOf(TOM.MetadataObject obj) { return TOM_Collection.IndexOf(obj as TOM.TablePermission); }
        /// <summary>The number of items in this collection.</summary>
		public override int Count { get { return TOM_Collection.Count; } }
		/// <summary>Returns an enumerator that iterates through the collection.</summary>
        public override IEnumerator<TablePermission> GetEnumerator() { return TOM_Collection.Select(h => Handler.WrapperLookup[h]).OfType<TablePermission>().GetEnumerator(); }
		internal override void Reinit() {
			var ixOffset = 0;
			for(int i = 0; i < Count; i++) {
				var metadataObj = TOM_Get(i) as TOM.TablePermission;
				var item = Handler.WrapperLookup.TryGetValue(metadataObj, out var existingItem) ? existingItem as TablePermission : CreateFromMetadata(metadataObj);
				Handler.WrapperLookup.Remove(item.MetadataObject);
				item.MetadataObject = ModelRole.MetadataObject.TablePermissions[i + ixOffset] as TOM.TablePermission;
				Handler.WrapperLookup.Add(item.MetadataObject, item);
				item.Collection = this;
			}
			TOM_Collection = ModelRole.MetadataObject.TablePermissions;
			foreach(var item in this) item.Reinit();
		}

		internal override void ReapplyReferences() {
			foreach(var item in this) item.ReapplyReferences();
		}

		private TablePermission CreateFromMetadata(TOM.TablePermission obj)
		{
			if(obj is TOM.TablePermission tablepermissionObj) return TablePermission.CreateFromMetadata(ModelRole, tablepermissionObj);
		    return null;
		}

		/// <summary>
		/// Calling this method will populate the TablePermissionCollection with objects based on the MetadataObjects in the corresponding MetadataObjectCollection.
		/// </summary>
		internal override void CreateChildrenFromMetadata()
		{
			// Construct child objects (they are automatically added to the Handler's WrapperLookup dictionary):
			foreach(var obj in TOM_Collection)
			{
				CreateFromMetadata(obj);
			}
		}

		/// <summary>
		/// Sets the FilterExpression property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the FilterExpression property of all objects in the collection at once.")]
		public string FilterExpression {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("FilterExpression"));
				this.ToList().ForEach(item => { item.FilterExpression = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the MetadataPermission property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the MetadataPermission property of all objects in the collection at once.")]
		public MetadataPermission MetadataPermission {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("MetadataPermission"));
				this.ToList().ForEach(item => { item.MetadataPermission = value; });
				Handler.UndoManager.EndBatch();
			}
		}
	}
}