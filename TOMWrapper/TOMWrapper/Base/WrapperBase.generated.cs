
// Code generated by a template
using System;
using System.Linq;
using System.Collections.Generic;
using System.ComponentModel;
using TabularEditor.PropertyGridUI;
using TabularEditor.TOMWrapper.Undo;
using TabularEditor.TOMWrapper.Utils;
using System.Drawing.Design;
using TOM = Microsoft.AnalysisServices.Tabular;
namespace TabularEditor.TOMWrapper
{
    internal static partial class Properties
    {
	    public const string ACCOUNT = "Account";
	    public const string ALIGNMENT = "Alignment";
	    public const string ALTERNATEOF = "AlternateOf";
	    public const string ALTERNATESOURCEPRECEDENCE = "AlternateSourcePrecedence";
	    public const string ANNOTATIONS = "Annotations";
	    public const string ATTRIBUTEHIERARCHY = "AttributeHierarchy";
	    public const string CALCULATIONGROUP = "CalculationGroup";
	    public const string COLLATION = "Collation";
	    public const string COLUMN = "Column";
	    public const string COLUMNORIGIN = "ColumnOrigin";
	    public const string COLUMNS = "Columns";
	    public const string CONNECTIONDETAILS = "ConnectionDetails";
	    public const string CONNECTIONSTRING = "ConnectionString";
	    public const string CONTEXTEXPRESSION = "ContextExpression";
	    public const string CREDENTIAL = "Credential";
	    public const string CROSSFILTERINGBEHAVIOR = "CrossFilteringBehavior";
	    public const string CULTURE = "Culture";
	    public const string CULTURES = "Cultures";
	    public const string DATAACCESSOPTIONS = "DataAccessOptions";
	    public const string DATABASE = "Database";
	    public const string DATACATEGORY = "DataCategory";
	    public const string DATASOURCES = "DataSources";
	    public const string DATATYPE = "DataType";
	    public const string DATAVIEW = "DataView";
	    public const string DEFAULTCOLUMN = "DefaultColumn";
	    public const string DEFAULTDATAVIEW = "DefaultDataView";
	    public const string DEFAULTDETAILROWSDEFINITION = "DefaultDetailRowsDefinition";
	    public const string DEFAULTHIERARCHY = "DefaultHierarchy";
	    public const string DEFAULTMEASURE = "DefaultMeasure";
	    public const string DEFAULTMODE = "DefaultMode";
	    public const string DEFAULTPOWERBIDATASOURCEVERSION = "DefaultPowerBIDataSourceVersion";
	    public const string DESCRIPTION = "Description";
	    public const string DETAILROWSDEFINITION = "DetailRowsDefinition";
	    public const string DISCOURAGEIMPLICITMEASURES = "DiscourageImplicitMeasures";
	    public const string DISCOURAGEREPORTMEASURES = "DiscourageReportMeasures";
	    public const string DISPLAYFOLDER = "DisplayFolder";
	    public const string DISPLAYORDINAL = "DisplayOrdinal";
	    public const string ENCODINGHINT = "EncodingHint";
	    public const string ERRORMESSAGE = "ErrorMessage";
	    public const string EXPRESSION = "Expression";
	    public const string EXPRESSIONS = "Expressions";
	    public const string EXTENDEDPROPERTIES = "ExtendedProperties";
	    public const string FORCEUNIQUENAMES = "ForceUniqueNames";
	    public const string FORMATSTRING = "FormatString";
	    public const string FORMATSTRINGDEFINITION = "FormatStringDefinition";
	    public const string FROMCARDINALITY = "FromCardinality";
	    public const string FROMCOLUMN = "FromColumn";
	    public const string FROMTABLE = "FromTable";
	    public const string HASLOCALCHANGES = "HasLocalChanges";
	    public const string HIDEMEMBERS = "HideMembers";
	    public const string HIERARCHIES = "Hierarchies";
	    public const string HIERARCHY = "Hierarchy";
	    public const string IDENTITYPROVIDER = "IdentityProvider";
	    public const string IMPERSONATIONMODE = "ImpersonationMode";
	    public const string INPERSPECTIVE = "InPerspective";
	    public const string ISACTIVE = "IsActive";
	    public const string ISAVAILABLEINMDX = "IsAvailableInMDX";
	    public const string ISDATATYPEINFERRED = "IsDataTypeInferred";
	    public const string ISDEFAULT = "IsDefault";
	    public const string ISDEFAULTIMAGE = "IsDefaultImage";
	    public const string ISDEFAULTLABEL = "IsDefaultLabel";
	    public const string ISHIDDEN = "IsHidden";
	    public const string ISKEY = "IsKey";
	    public const string ISNAMEINFERRED = "IsNameInferred";
	    public const string ISNULLABLE = "IsNullable";
	    public const string ISOLATION = "Isolation";
	    public const string ISPRIVATE = "IsPrivate";
	    public const string ISSIMPLEMEASURE = "IsSimpleMeasure";
	    public const string ISUNIQUE = "IsUnique";
	    public const string JOINONDATEBEHAVIOR = "JoinOnDateBehavior";
	    public const string KEEPUNIQUEROWS = "KeepUniqueRows";
	    public const string KIND = "Kind";
	    public const string KPI = "KPI";
	    public const string LEVELS = "Levels";
	    public const string LINGUISTICMETADATA = "LinguisticMetadata";
	    public const string MAXCONNECTIONS = "MaxConnections";
	    public const string MEASURE = "Measure";
	    public const string MEASURES = "Measures";
	    public const string MEMBERID = "MemberID";
	    public const string MEMBERNAME = "MemberName";
	    public const string MEMBERS = "Members";
	    public const string MEMBERTYPE = "MemberType";
	    public const string MODE = "Mode";
	    public const string MODELPERMISSION = "ModelPermission";
	    public const string MODIFIEDTIME = "ModifiedTime";
	    public const string NAME = "Name";
	    public const string OBJECTTRANSLATIONS = "ObjectTranslations";
	    public const string OBJECTTYPE = "ObjectType";
	    public const string OPTIONS = "Options";
	    public const string ORDINAL = "Ordinal";
	    public const string PARENT = "Parent";
	    public const string PARTITIONS = "Partitions";
	    public const string PASSWORD = "Password";
	    public const string PERSPECTIVES = "Perspectives";
	    public const string PERSPECTIVETABLES = "PerspectiveTables";
	    public const string PROVIDER = "Provider";
	    public const string REFRESHEDTIME = "RefreshedTime";
	    public const string REFRESHPOLICY = "RefreshPolicy";
	    public const string RELATIONSHIP = "Relationship";
	    public const string RELATIONSHIPS = "Relationships";
	    public const string RELYONREFERENTIALINTEGRITY = "RelyOnReferentialIntegrity";
	    public const string RETAINDATATILLFORCECALCULATE = "RetainDataTillForceCalculate";
	    public const string ROLE = "Role";
	    public const string ROLES = "Roles";
	    public const string SECURITYFILTERINGBEHAVIOR = "SecurityFilteringBehavior";
	    public const string SERVER = "Server";
	    public const string SHOWASVARIATIONSONLY = "ShowAsVariationsOnly";
	    public const string SORTBYCOLUMN = "SortByColumn";
	    public const string SOURCE = "Source";
	    public const string SOURCECOLUMN = "SourceColumn";
	    public const string SOURCEPROVIDERTYPE = "SourceProviderType";
	    public const string SOURCETYPE = "SourceType";
	    public const string STATE = "State";
	    public const string STATUSDESCRIPTION = "StatusDescription";
	    public const string STATUSEXPRESSION = "StatusExpression";
	    public const string STATUSGRAPHIC = "StatusGraphic";
	    public const string STORAGELOCATION = "StorageLocation";
	    public const string STRUCTUREMODIFIEDTIME = "StructureModifiedTime";
	    public const string SUMMARIZEBY = "SummarizeBy";
	    public const string TABLE = "Table";
	    public const string TABLEDETAILPOSITION = "TableDetailPosition";
	    public const string TABLEPERMISSIONS = "TablePermissions";
	    public const string TABLES = "Tables";
	    public const string TARGETDESCRIPTION = "TargetDescription";
	    public const string TARGETEXPRESSION = "TargetExpression";
	    public const string TARGETFORMATSTRING = "TargetFormatString";
	    public const string TIMEOUT = "Timeout";
	    public const string TOCARDINALITY = "ToCardinality";
	    public const string TOCOLUMN = "ToColumn";
	    public const string TOTABLE = "ToTable";
	    public const string TRANSLATEDDESCRIPTIONS = "TranslatedDescriptions";
	    public const string TRANSLATEDDISPLAYFOLDERS = "TranslatedDisplayFolders";
	    public const string TRANSLATEDNAMES = "TranslatedNames";
	    public const string TRENDDESCRIPTION = "TrendDescription";
	    public const string TRENDEXPRESSION = "TrendExpression";
	    public const string TRENDGRAPHIC = "TrendGraphic";
	    public const string TYPE = "Type";
	    public const string VARIATIONS = "Variations";
    }

	internal static class ObjectMetadata
	{
		private static readonly Dictionary<Type, Type> TOMMap = new Dictionary<Type, Type>() {
            { typeof(Variation) , typeof(TOM.Variation) },
            { typeof(StructuredDataSource) , typeof(TOM.StructuredDataSource) },
            { typeof(CalculatedColumn) , typeof(TOM.CalculatedColumn) },
            { typeof(CalculatedTableColumn) , typeof(TOM.CalculatedTableColumn) },
            { typeof(Column) , typeof(TOM.Column) },
            { typeof(Culture) , typeof(TOM.Culture) },
            { typeof(DataColumn) , typeof(TOM.DataColumn) },
            { typeof(DataSource) , typeof(TOM.DataSource) },
            { typeof(ExternalModelRoleMember) , typeof(TOM.ExternalModelRoleMember) },
            { typeof(Hierarchy) , typeof(TOM.Hierarchy) },
            { typeof(KPI) , typeof(TOM.KPI) },
            { typeof(Level) , typeof(TOM.Level) },
            { typeof(Measure) , typeof(TOM.Measure) },
            { typeof(Model) , typeof(TOM.Model) },
            { typeof(ModelRole) , typeof(TOM.ModelRole) },
            { typeof(ModelRoleMember) , typeof(TOM.ModelRoleMember) },
            { typeof(Partition) , typeof(TOM.Partition) },
            { typeof(Perspective) , typeof(TOM.Perspective) },
            { typeof(ProviderDataSource) , typeof(TOM.ProviderDataSource) },
            { typeof(Relationship) , typeof(TOM.Relationship) },
            { typeof(SingleColumnRelationship) , typeof(TOM.SingleColumnRelationship) },
            { typeof(Table) , typeof(TOM.Table) },
            { typeof(WindowsModelRoleMember) , typeof(TOM.WindowsModelRoleMember) },
            { typeof(NamedExpression) , typeof(TOM.NamedExpression) },
	    };

		public static Type ToTOM(Type wrapperType) {
			return TOMMap[wrapperType];
		}

		public static Type FromTOM(Type tomType) {
			return TOMMap.FirstOrDefault(kvp => kvp.Value == tomType).Key;
		}

		public static readonly Type[] Creatable = {
            typeof(Variation),
            typeof(StructuredDataSource),
            typeof(CalculatedColumn),
            typeof(Culture),
            typeof(DataColumn),
            typeof(ExternalModelRoleMember),
            typeof(Hierarchy),
            typeof(Level),
            typeof(Measure),
            typeof(ModelRole),
            typeof(Partition),
            typeof(Perspective),
            typeof(ProviderDataSource),
            typeof(SingleColumnRelationship),
            typeof(Table),
            typeof(WindowsModelRoleMember),
            typeof(NamedExpression),
	        typeof(CalculatedTable)
        };
	}
	/// <summary>
///             Indicates the dialect of the query expression.
///             </summary><remarks>This enum is only supported when the compatibility level of the database is at 1400 or above.</remarks>
	public enum ExpressionKind {    
        M = 0,
	}
	/// <summary>
///             The type of DataSource. Currently, the only possible value is Provider.
///             </summary>
	public enum DataSourceType {    
        Provider = 1,
        Structured = 2,
	}
	/// <summary>
///             An enumeration of possible values for a partition source.
///             </summary>
	public enum PartitionSourceType {    
        Query = 1,
        Calculated = 2,
        None = 3,
        M = 4,
        Entity = 5,
        PolicyRange = 6,
        CalculationGroup = 7,
	}
	/// <summary>
///             Describes the type of data contained in the column. 
///             </summary>
	public enum DataType {    
        Automatic = 1,
        String = 2,
        Int64 = 6,
        Double = 8,
        DateTime = 9,
        Decimal = 10,
        Boolean = 11,
        Binary = 17,
        Unknown = 19,
        Variant = 20,
	}
	/// <summary>
///             An enumeration of possible values for object state.
///             </summary>
	public enum ObjectState {    
        Ready = 1,
        NoData = 3,
        CalculationNeeded = 4,
        SemanticError = 5,
        EvaluationError = 6,
        DependencyError = 7,
        Incomplete = 8,
	}
	/// <summary>
///             An enumeration of possible values for aligning data in a cell. 
///             </summary>
	public enum Alignment {    
        Default = 1,
        Left = 2,
        Right = 3,
        Center = 4,
	}
	/// <summary>
///             Specifies the aggregate function to be used by reporting tools to summarize column values.
///             </summary>
	public enum AggregateFunction {    
        Default = 1,
        None = 2,
        Sum = 3,
        Min = 4,
        Max = 5,
        Count = 6,
        Average = 7,
        DistinctCount = 8,
	}
	/// <summary>
///             An enumeration of possible values for a column type. 
///             </summary>
	public enum ColumnType {    
        Data = 1,
        Calculated = 2,
        RowNumber = 3,
        CalculatedTableColumn = 4,
	}
	/// <summary>
///             Indicates whether the particular member of a security role is an individual user or a group of users, or if the member is automatically detected.
///             </summary>
	public enum RoleMemberType {    
        Auto = 1,
        User = 2,
        Group = 3,
	}
	/// <summary>
///             Defines the method for making data available in the partition.
///             </summary>
	public enum ModeType {    
        Import = 0,
        DirectQuery = 1,
        Default = 2,
        Dual = 4,
	}
	/// <summary>
///             Determines which partitions are to be selected to run queries against the model.
///             </summary>
	public enum DataViewType {    
        Full = 0,
        Sample = 1,
        Default = 3,
	}
	/// <summary>
///             An enumeration of possible model permissions that can be used in a Role object.
///             </summary>
	public enum ModelPermission {    
        None = 1,
        Read = 2,
        ReadRefresh = 3,
        Refresh = 4,
        Administrator = 5,
	}
	/// <summary>
///             Determines how credentials are obtained for an impersonated connection to a data source during data import or refresh.
///             </summary>
	public enum ImpersonationMode {    
        Default = 1,
        ImpersonateAccount = 2,
        ImpersonateAnonymous = 3,
        ImpersonateCurrentUser = 4,
        ImpersonateServiceAccount = 5,
        ImpersonateUnattendedAccount = 6,
	}
	/// <summary>
///             Controls the locking behavior of the SQL statements when executing commands against the data source. 
///             </summary>
	public enum DatasourceIsolation {    
        ReadCommitted = 1,
        Snapshot = 2,
	}
	/// <summary>
///             The type of relationship. Currently, the only possible value is SingleColumn.
///             </summary>
	public enum RelationshipType {    
        SingleColumn = 1,
	}
	/// <summary>
///             Indicates how relationships influence filtering of data. The enumeration defines the possible behaviors.
///             </summary>
	public enum CrossFilteringBehavior {    
        OneDirection = 1,
        BothDirections = 2,
        Automatic = 3,
	}
	/// <summary>
///             Indicates how relationships influence filtering of data when evaluating row-level security expressions. The enumeration defines the possible behaviors.
///             </summary>
	public enum SecurityFilteringBehavior {    
        OneDirection = 1,
        BothDirections = 2,
	}
	/// <summary>
///             When joining two date time columns, indicates whether to join on date and time parts or on date part only.
///             </summary>
	public enum DateTimeRelationshipBehavior {    
        DateAndTime = 1,
        DatePartOnly = 2,
	}
	/// <summary>
///             An enumeration of possible values for defining cardinality on either side of a table relationship.
///             </summary>
	public enum RelationshipEndCardinality {    
        None = 0,
        One = 1,
        Many = 2,
	}
	/// <summary>
///             Ragged/unbalanced hierarchies can be enabled by hiding members.
///             </summary><remarks>This enum is only supported when the compatibility level of the database is at 1400 or above.</remarks>
	public enum HierarchyHideMembersType {    
        Default = 0,
        HideBlankMembers = 1,
	}
	/// <summary>
///             Encoding hint to suggest whether a column should use hash encoding.
///             </summary><remarks>This enum is only supported when the compatibility level of the database is at 1400 or above.</remarks>
	public enum EncodingHintType {    
        Default = 0,
        Hash = 1,
        Value = 2,
	}
	/// <summary>
///             An enumeration of possible values for a refresh type.
///             </summary>
	public enum RefreshType {    
        Full = 1,
        ClearValues = 2,
        Calculate = 3,
        DataOnly = 4,
        Automatic = 5,
        Add = 7,
        Defragment = 8,
	}
	/// <summary>
///             An enumeration of possible values for the type of value stored in extended property.
///             </summary><remarks>This enum is only supported when the compatibility level of the database is at 1400 or above.</remarks>
	public enum ExtendedPropertyType {    
        String = 0,
        Json = 1,
	}
  
	/// <summary>
///             Variation object.
///             </summary><remarks>This metadata object is only supported when the compatibility level of the database is at 1400 or above.</remarks>
	[TypeConverter(typeof(DynamicPropertyConverter))]
	public sealed partial class Variation: TabularNamedObject
			, IDescriptionObject
			, IAnnotationObject
			, IExtendedPropertyObject
			, IClonableObject
	{
	    internal new TOM.Variation MetadataObject 
		{ 
			get 
			{ 
				return base.MetadataObject as TOM.Variation; 
		    } 
			set 
			{ 
				base.MetadataObject = value; 
			}
		}

        [Browsable(true),NoMultiselect,Category("Translations and Perspectives"),Description("The collection of Annotations on this object."),Editor(typeof(AnnotationCollectionEditor), typeof(UITypeEditor))]
		public AnnotationCollection Annotations { get; private set; }
		public string GetAnnotation(int index) {
			return MetadataObject.Annotations[index].Value;
		}
		[IntelliSense("Returns true if an annotation with the given name exists. Otherwise false.")]
		public bool HasAnnotation(string name) {
		    return MetadataObject.Annotations.ContainsName(name);
		}
		[IntelliSense("Gets the value of the annotation with the given name. Returns null if no such annotation exists.")]
		public string GetAnnotation(string name) {
		    return HasAnnotation(name) ? MetadataObject.Annotations[name].Value : null;
		}
		public void SetAnnotation(int index, string value, bool undoable = true) {
			var name = MetadataObject.Annotations[index].Name;
			SetAnnotation(name, value, undoable);
		}
		public string GetNewAnnotationName() {
			return MetadataObject.Annotations.GetNewName("New Annotation");
		}
		[IntelliSense("Sets the value of the annotation having the given name. If no such annotation exists, it will be created. If value is set to null, the annotation will be removed.")]
		public void SetAnnotation(string name, string value) {
		    SetAnnotation(name, value, true);
		}
		public void SetAnnotation(string name, string value, bool undoable) {
			if(name == null) name = GetNewAnnotationName();

			if(value == null) {
				// Remove annotation if set to null:
				RemoveAnnotation(name, undoable);
				return;
			}

			if(GetAnnotation(name) == value) return;
			bool undoable2 = true;
			bool cancel = false;
			OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + value, ref undoable2, ref cancel);
			if (cancel) return;

			if(MetadataObject.Annotations.Contains(name)) {
				// Change existing annotation:
				var oldValue = GetAnnotation(name);
				MetadataObject.Annotations[name].Value = value;
				if (undoable) Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, oldValue));
				OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, name + ":" + value);
			} else {
				// Add new annotation:
				MetadataObject.Annotations.Add(new TOM.Annotation{ Name = name, Value = value });
				if (undoable) Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, null));
				OnPropertyChanged(Properties.ANNOTATIONS, null, name + ":" + value);
			}

		}
		[IntelliSense("Remove an annotation by the given name.")]
		public void RemoveAnnotation(string name) {
		    RemoveAnnotation(name, true);
		}
		public void RemoveAnnotation(string name, bool undoable) {
			if(MetadataObject.Annotations.Contains(name)) {
				// Get current value:
				bool undoable2 = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + GetAnnotation(name), ref undoable2, ref cancel);
				if (cancel) return;

				var oldValue = MetadataObject.Annotations[name].Value;
				MetadataObject.Annotations.Remove(name);

				// Undo-handling:
				if (undoable) Handler.UndoManager.Add(new UndoAnnotationAction(this, name, null, oldValue));
				OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, null);
			}
		}
		[IntelliSense("Gets the number of annotations on the current object.")]
		public int GetAnnotationsCount() {
			return MetadataObject.Annotations.Count;
		}
		[IntelliSense("Gets a collection of all annotation names on the current object.")]
		public IEnumerable<string> GetAnnotations() {
			return MetadataObject.Annotations.Select(a => a.Name);
		}

		        [DisplayName("Extended Properties"),NoMultiselect,Category("Translations and Perspectives"),Description("The collection of Extended Properties on this object."),Editor(typeof(ExtendedPropertyCollectionEditor), typeof(UITypeEditor))]
		public ExtendedPropertyCollection ExtendedProperties { get; private set; }

		[IntelliSense("Returns true if an ExtendedProperty with the given name exists. Otherwise false.")]
		public bool HasExtendedProperty(string name) {
		    return MetadataObject.ExtendedProperties.ContainsName(name);
		}
		public ExtendedPropertyType GetExtendedPropertyType(int index) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[index].Type;
		}
		public ExtendedPropertyType GetExtendedPropertyType(string name) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[name].Type;
		}
		public string GetExtendedProperty(int index) {
			var ep = MetadataObject.ExtendedProperties[index];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		[IntelliSense("Gets the value of the ExtendedProperty with the given name. Returns null if no such ExtendedProperty exists.")]
		public string GetExtendedProperty(string name) {
		    if(!HasExtendedProperty(name)) return null;
			var ep = MetadataObject.ExtendedProperties[name];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		public void SetExtendedProperty(int index, string value, ExtendedPropertyType type = ExtendedPropertyType.String) {
			var name = MetadataObject.ExtendedProperties[index].Name;
			SetExtendedProperty(name, value, type);
		}
		public string GetNewExtendedPropertyName() {
			return MetadataObject.ExtendedProperties.GetNewName("New ExtendedProperty");
		}
		[IntelliSense("Sets the value of the ExtendedProperty having the given name. If no such ExtendedProperty exists, it will be created. If value is set to null, the ExtendedProperty will be removed.")]
		public void SetExtendedProperty(string name, string value, ExtendedPropertyType type = ExtendedPropertyType.String) {
			if(name == null) name = GetNewExtendedPropertyName();

			if(value == null) {
				// Remove ExtendedProperty if set to null:
				RemoveExtendedProperty(name);
				return;
			}

			if(GetExtendedProperty(name) == value) return;
			bool undoable = true;
			bool cancel = false;
			OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + value, ref undoable, ref cancel);
			if (cancel) return;

			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Change existing ExtendedProperty:
				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				var ep = MetadataObject.ExtendedProperties[name];
				if (ep is TOM.JsonExtendedProperty)
					(ep as TOM.JsonExtendedProperty).Value = value;
				else 
					(ep as TOM.StringExtendedProperty).Value = value;
					
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, name + ":" + value);
			} else {
				// Add new ExtendedProperty:
				if (type == ExtendedPropertyType.Json)
					MetadataObject.ExtendedProperties.Add(new TOM.JsonExtendedProperty{ Name = name, Value = value });
				else
					MetadataObject.ExtendedProperties.Add(new TOM.StringExtendedProperty{ Name = name, Value = value });

				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, null, type));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, null, name + ":" + value);
			}

		}
		[IntelliSense("Remove an ExtendedProperty by the given name.")]
		public void RemoveExtendedProperty(string name) {
			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Get current value:
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + GetExtendedProperty(name), ref undoable, ref cancel);
				if (cancel) return;

				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				MetadataObject.ExtendedProperties.Remove(name);

				// Undo-handling:
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, null, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, null);
			}
		}
		[IntelliSense("Gets the number of ExtendedProperties on the current object.")]
		public int GetExtendedPropertyCount() {
			return MetadataObject.ExtendedProperties.Count;
		}
		[IntelliSense("Gets a collection of all ExtendedProperty names on the current object.")]
		public IEnumerable<string> GetExtendedProperties() {
			return MetadataObject.ExtendedProperties.Select(a => a.Name);
		}

		/// <summary>
///             Missing comment
///             </summary>
		[DisplayName("Description")]
		[Category("Basic"),Description(@"The Description of this Variation"),IntelliSense(@"The Description of this Variation")][Editor(typeof(System.ComponentModel.Design.MultilineStringEditor), typeof(System.Drawing.Design.UITypeEditor))]
		public string Description {
			get {
			    return MetadataObject.Description;
			}
			set {
				
				var oldValue = Description;
				var newValue = value.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DESCRIPTION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.Description = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DESCRIPTION, oldValue, newValue));
				OnPropertyChanged(Properties.DESCRIPTION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeDescription() { return false; }
/// <summary>
///             If true, the Variation is the Default one for the Column.
///             </summary>
		[DisplayName("Default")]
		[Category("Variation Options"),Description(@"If true, the Variation is the Default one for the Column."),IntelliSense(@"If true, the Variation is the Default one for the Column.")]
		public bool IsDefault {
			get {
			    return MetadataObject.IsDefault;
			}
			set {
				
				var oldValue = IsDefault;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ISDEFAULT, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.IsDefault = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.ISDEFAULT, oldValue, newValue));
				OnPropertyChanged(Properties.ISDEFAULT, oldValue, newValue);
			}
		}
		private bool ShouldSerializeIsDefault() { return false; }
/// <summary>
///             Missing comment
///             </summary>
		[DisplayName("Parent Column")]
		[Category("Basic"),Description(@"The Column of this Variation"),IntelliSense(@"The Column of this Variation")][TypeConverter(typeof(TableColumnConverter)),ReadOnly(true)]
		public Column Column {
			get {
				if (MetadataObject.Column == null) return null;
			    return Handler.WrapperLookup[MetadataObject.Column] as Column;
            }
			
		}
		private bool ShouldSerializeColumn() { return false; }
/// <summary>
///             Missing comment
///             </summary>
		[DisplayName("Relationship")]
		[Category("Variation Options"),Description(@"The Relationship of this Variation"),IntelliSense(@"The Relationship of this Variation")][TypeConverter(typeof(AllRelationshipConverter))]
		public Relationship Relationship {
			get {
				if (MetadataObject.Relationship == null) return null;
			    return Handler.WrapperLookup[MetadataObject.Relationship] as Relationship;
            }
			set {
				
				var oldValue = Relationship;
				var newValue = value;
				if (oldValue?.MetadataObject == newValue?.MetadataObject) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.RELATIONSHIP, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.Relationship = value == null ? null : value.MetadataObject;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.RELATIONSHIP, oldValue, newValue));
				OnPropertyChanged(Properties.RELATIONSHIP, oldValue, newValue);
			}
		}
		private bool ShouldSerializeRelationship() { return false; }
/// <summary>
///             Missing comment
///             </summary>
		[DisplayName("Default Hierarchy")]
		[Category("Variation Options"),Description(@"The DefaultHierarchy of this Variation"),IntelliSense(@"The DefaultHierarchy of this Variation")][TypeConverter(typeof(AllHierarchyConverter))]
		public Hierarchy DefaultHierarchy {
			get {
				if (MetadataObject.DefaultHierarchy == null) return null;
			    return Handler.WrapperLookup[MetadataObject.DefaultHierarchy] as Hierarchy;
            }
			set {
				
				var oldValue = DefaultHierarchy;
				var newValue = value;
				if (oldValue?.MetadataObject == newValue?.MetadataObject) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DEFAULTHIERARCHY, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.DefaultHierarchy = value == null ? null : value.MetadataObject;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DEFAULTHIERARCHY, oldValue, newValue));
				OnPropertyChanged(Properties.DEFAULTHIERARCHY, oldValue, newValue);
			}
		}
		private bool ShouldSerializeDefaultHierarchy() { return false; }
/// <summary>
///             Missing comment
///             </summary>
		[DisplayName("Default Column")]
		[Category("Variation Options"),Description(@"The DefaultColumn of this Variation"),IntelliSense(@"The DefaultColumn of this Variation")][TypeConverter(typeof(AllColumnConverter))]
		public Column DefaultColumn {
			get {
				if (MetadataObject.DefaultColumn == null) return null;
			    return Handler.WrapperLookup[MetadataObject.DefaultColumn] as Column;
            }
			set {
				
				var oldValue = DefaultColumn;
				var newValue = value;
				if (oldValue?.MetadataObject == newValue?.MetadataObject) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DEFAULTCOLUMN, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.DefaultColumn = value == null ? null : value.MetadataObject;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DEFAULTCOLUMN, oldValue, newValue));
				OnPropertyChanged(Properties.DEFAULTCOLUMN, oldValue, newValue);
			}
		}
		private bool ShouldSerializeDefaultColumn() { return false; }

		internal static Variation CreateFromMetadata(Column parent, TOM.Variation metadataObject) {
			var obj = new Variation(metadataObject);
			parent.Variations.Add(obj);
			
			obj.Init();

			return obj;
		}


		/// <summary>
		/// Creates a new Variation and adds it to the parent Column.
		/// Also creates the underlying metadataobject and adds it to the TOM tree.
		/// </summary>
		public static Variation CreateNew(Column parent, string name = null)
		{
			if(TabularModelHandler.Singleton.UsePowerBIGovernance && !PowerBI.PowerBIGovernance.AllowCreate(typeof(Variation))) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(Variation).GetTypeName()));
			}

			var metadataObject = new TOM.Variation();
			metadataObject.Name = parent.Variations.GetNewName(string.IsNullOrWhiteSpace(name) ? "New " + typeof(Variation).GetTypeName() : name);

			var obj = new Variation(metadataObject);

			parent.Variations.Add(obj);
			
			obj.Init();

			return obj;
		}


		/// <summary>
		/// Creates an exact copy of this Variation object.
		/// </summary>
		public Variation Clone(string newName = null, Column newParent = null) {
			if(TabularModelHandler.Singleton.UsePowerBIGovernance && !PowerBI.PowerBIGovernance.AllowCreate(typeof(Variation))) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(Variation).GetTypeName()));
			}

		    Handler.BeginUpdate("Clone Variation");

			// Create a clone of the underlying metadataobject:
			var tom = MetadataObject.Clone() as TOM.Variation;


			// Assign a new, unique name:
			tom.Name = Parent.Variations.GetNewName(string.IsNullOrEmpty(newName) ? tom.Name + " copy" : newName);
				
			// Create the TOM Wrapper object, representing the metadataobject
			Variation obj = CreateFromMetadata(newParent ?? Parent, tom);

            Handler.EndUpdate();

            return obj;
		}

		TabularNamedObject IClonableObject.Clone(string newName, bool includeTranslations, TabularNamedObject newParent) 
		{
			return Clone(newName);
		}

	
        internal override void RenewMetadataObject()
        {
            Handler.WrapperLookup.Remove(MetadataObject);
            MetadataObject = MetadataObject.Clone() as TOM.Variation;
            Handler.WrapperLookup.Add(MetadataObject, this);
        }

		public Column Parent { 
			get {
				return Handler.WrapperLookup[MetadataObject.Parent] as Column;
			}
		}



		/// <summary>
		/// CTOR - only called from static factory methods on the class
		/// </summary>
		Variation(TOM.Variation metadataObject) : base(metadataObject)
		{
			
			// Create indexer for annotations:
			Annotations = new AnnotationCollection(this);
			
			// Create indexer for extended properties:
			ExtendedProperties = new ExtendedPropertyCollection(this);
		}



		internal override void Undelete(ITabularObjectCollection collection) {
			base.Undelete(collection);
			Reinit();
			ReapplyReferences();
		}

		public override bool Browsable(string propertyName) {
			switch (propertyName) {
 
				case Properties.EXTENDEDPROPERTIES:
					return Handler.CompatibilityLevel >= 1400;
				case Properties.PARENT:
					return false;
				
				default:
					return base.Browsable(propertyName);
			}
		}

    }


	/// <summary>
	/// Collection class for Variation. Provides convenient properties for setting a property on multiple objects at once.
	/// </summary>
	public sealed partial class VariationCollection: TabularObjectCollection<Variation>
	{
		internal Column Column { get { return Parent as Column; } }
		TOM.VariationCollection TOM_Collection;
		internal VariationCollection(string collectionName, TOM.VariationCollection metadataObjectCollection, Column parent) : base(collectionName, parent)
		{
			TOM_Collection = metadataObjectCollection;
		}
		internal override Type GetItemType() { return typeof(Variation); }
        protected override void TOM_Add(TOM.MetadataObject obj) { TOM_Collection.Add(obj as TOM.Variation); }
        protected override bool TOM_Contains(TOM.MetadataObject obj) { return TOM_Collection.Contains(obj as TOM.Variation); }
        protected override void TOM_Remove(TOM.MetadataObject obj) { TOM_Collection.Remove(obj as TOM.Variation); }
        protected override void TOM_Clear() { TOM_Collection.Clear(); }
        protected override bool TOM_ContainsName(string name) { return TOM_Collection.ContainsName(name); }
        protected override TOM.MetadataObject TOM_Get(int index) { return TOM_Collection[index]; }
        protected override TOM.MetadataObject TOM_Get(string name) { return TOM_Collection[name]; }
        internal override string GetNewName(string prefix = null) { return string.IsNullOrEmpty(prefix) ? TOM_Collection.GetNewName() : TOM_Collection.GetNewName(prefix); }
        public override int IndexOf(TOM.MetadataObject obj) { return TOM_Collection.IndexOf(obj as TOM.Variation); }
        public override int Count { get { return TOM_Collection.Count; } }
        public override IEnumerator<Variation> GetEnumerator() { return TOM_Collection.Select(h => Handler.WrapperLookup[h]).OfType<Variation>().GetEnumerator(); }
		internal override void Reinit() {
			var ixOffset = 0;
			for(int i = 0; i < Count; i++) {
				var item = this[i];
				Handler.WrapperLookup.Remove(item.MetadataObject);
				item.MetadataObject = Column.MetadataObject.Variations[i + ixOffset] as TOM.Variation;
				Handler.WrapperLookup.Add(item.MetadataObject, item);
				item.Collection = this;
			}
			TOM_Collection = Column.MetadataObject.Variations;
			foreach(var item in this) item.Reinit();
		}

		internal override void ReapplyReferences() {
			foreach(var item in this) item.ReapplyReferences();
		}

		/// <summary>
		/// Calling this method will populate the VariationCollection with objects based on the MetadataObjects in the corresponding MetadataObjectCollection.
		/// </summary>
		internal override void CreateChildrenFromMetadata()
		{
			// Construct child objects (they are automatically added to the Handler's WrapperLookup dictionary):
			foreach(var obj in TOM_Collection) {
				if(obj is TOM.Variation) Variation.CreateFromMetadata(Column, obj as TOM.Variation);
		    }
		}

		/// <summary>
		/// Sets the Description property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the Description property of all objects in the collection at once.")]
		public string Description {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("Description"));
				this.ToList().ForEach(item => { item.Description = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the IsDefault property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the IsDefault property of all objects in the collection at once.")]
		public bool IsDefault {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("IsDefault"));
				this.ToList().ForEach(item => { item.IsDefault = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the Relationship property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the Relationship property of all objects in the collection at once.")]
		public Relationship Relationship {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("Relationship"));
				this.ToList().ForEach(item => { item.Relationship = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the DefaultHierarchy property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the DefaultHierarchy property of all objects in the collection at once.")]
		public Hierarchy DefaultHierarchy {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("DefaultHierarchy"));
				this.ToList().ForEach(item => { item.DefaultHierarchy = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the DefaultColumn property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the DefaultColumn property of all objects in the collection at once.")]
		public Column DefaultColumn {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("DefaultColumn"));
				this.ToList().ForEach(item => { item.DefaultColumn = value; });
				Handler.UndoManager.EndBatch();
			}
		}

		public override string ToString() {
			return string.Format("({0} {1})", Count, (Count == 1 ? "Variation" : "Variations").ToLower());
		}
	}
  
	/// <summary>
///             Represents a data source that uses JSON-based extensible protocol to define the location and mechanism of retrieving the data.
///             </summary><remarks>This metadata object is only supported when the compatibility level of the database is at 1400 or above.</remarks>
	[TypeConverter(typeof(DynamicPropertyConverter))]
	public sealed partial class StructuredDataSource: DataSource
			, IClonableObject
	{
	    internal new TOM.StructuredDataSource MetadataObject 
		{ 
			get 
			{ 
				return base.MetadataObject as TOM.StructuredDataSource; 
		    } 
			set 
			{ 
				base.MetadataObject = value; 
			}
		}

/// <summary>
///             For internal use only.
///             </summary>
		[DisplayName("Context Expression")]
		[Category("Other"),Description(@"For internal use only."),IntelliSense(@"For internal use only.")][Editor(typeof(System.ComponentModel.Design.MultilineStringEditor), typeof(System.Drawing.Design.UITypeEditor))]
		public string ContextExpression {
			get {
			    return MetadataObject.ContextExpression;
			}
			set {
				
				var oldValue = ContextExpression;
				var newValue = value.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.CONTEXTEXPRESSION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.ContextExpression = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.CONTEXTEXPRESSION, oldValue, newValue));
				OnPropertyChanged(Properties.CONTEXTEXPRESSION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeContextExpression() { return false; }

		internal static StructuredDataSource CreateFromMetadata(Model parent, TOM.StructuredDataSource metadataObject) {
			var obj = new StructuredDataSource(metadataObject);
			parent.DataSources.Add(obj);
			
			obj.Init();

			return obj;
		}


		/// <summary>
		/// Creates a new StructuredDataSource and adds it to the parent Model.
		/// Also creates the underlying metadataobject and adds it to the TOM tree.
		/// </summary>
		public static StructuredDataSource CreateNew(Model parent, string name = null)
		{
			if(TabularModelHandler.Singleton.UsePowerBIGovernance && !PowerBI.PowerBIGovernance.AllowCreate(typeof(StructuredDataSource))) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(StructuredDataSource).GetTypeName()));
			}

			var metadataObject = new TOM.StructuredDataSource();
			metadataObject.Name = parent.DataSources.GetNewName(string.IsNullOrWhiteSpace(name) ? "New " + typeof(StructuredDataSource).GetTypeName() : name);

			var obj = new StructuredDataSource(metadataObject);

			parent.DataSources.Add(obj);
			
			obj.Init();

			return obj;
		}

		/// <summary>
		/// Creates a new StructuredDataSource and adds it to the current Model.
		/// Also creates the underlying metadataobject and adds it to the TOM tree.
		/// </summary>		
		public static StructuredDataSource CreateNew(string name = null)
		{
			return CreateNew(TabularModelHandler.Singleton.Model, name);
		}


		/// <summary>
		/// Creates an exact copy of this StructuredDataSource object.
		/// </summary>
		public StructuredDataSource Clone(string newName = null) {
			if(TabularModelHandler.Singleton.UsePowerBIGovernance && !PowerBI.PowerBIGovernance.AllowCreate(typeof(StructuredDataSource))) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(StructuredDataSource).GetTypeName()));
			}

		    Handler.BeginUpdate("Clone StructuredDataSource");

			// Create a clone of the underlying metadataobject:
			var tom = MetadataObject.Clone() as TOM.StructuredDataSource;


			// Assign a new, unique name:
			tom.Name = Parent.DataSources.GetNewName(string.IsNullOrEmpty(newName) ? tom.Name + " copy" : newName);
				
			// Create the TOM Wrapper object, representing the metadataobject
			StructuredDataSource obj = CreateFromMetadata(Parent, tom);

            Handler.EndUpdate();

            return obj;
		}

		TabularNamedObject IClonableObject.Clone(string newName, bool includeTranslations, TabularNamedObject newParent) 
		{
			if (newParent != null) throw new ArgumentException("This object can not be cloned to another parent. Argument newParent should be left as null.", "newParent");
			return Clone(newName);
		}

	
        internal override void RenewMetadataObject()
        {
            Handler.WrapperLookup.Remove(MetadataObject);
            MetadataObject = MetadataObject.Clone() as TOM.StructuredDataSource;
            Handler.WrapperLookup.Add(MetadataObject, this);
        }

		public new Model Parent { 
			get {
				return Handler.WrapperLookup[MetadataObject.Parent] as Model;
			}
		}



		/// <summary>
		/// CTOR - only called from static factory methods on the class
		/// </summary>
		StructuredDataSource(TOM.StructuredDataSource metadataObject) : base(metadataObject)
		{
		}



		internal override void Undelete(ITabularObjectCollection collection) {
			base.Undelete(collection);
			Reinit();
			ReapplyReferences();
		}

		public override bool Browsable(string propertyName) {
			switch (propertyName) {
				case Properties.PARENT:
					return false;
				
				default:
					return base.Browsable(propertyName);
			}
		}

    }

  
	/// <summary>
///             Represents a column that is based on a DAX expression in a Table that also contains DataColumns and a RowNumberColumn. A CalculatedColumn can also be added to a calculated table.
///             </summary>
	[TypeConverter(typeof(DynamicPropertyConverter))]
	public sealed partial class CalculatedColumn: Column
			, IExpressionObject
			, IClonableObject
	{
	    internal new TOM.CalculatedColumn MetadataObject 
		{ 
			get 
			{ 
				return base.MetadataObject as TOM.CalculatedColumn; 
		    } 
			set 
			{ 
				base.MetadataObject = value; 
			}
		}

/// <summary>
///             A boolean value indicating whether the data type is inferred.
///             </summary>
		[DisplayName("Data Type Inferred")]
		[Category("Other"),Description(@"A boolean value indicating whether the data type is inferred."),IntelliSense(@"A boolean value indicating whether the data type is inferred.")]
		public bool IsDataTypeInferred {
			get {
			    return MetadataObject.IsDataTypeInferred;
			}
			set {
				
				var oldValue = IsDataTypeInferred;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ISDATATYPEINFERRED, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.IsDataTypeInferred = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.ISDATATYPEINFERRED, oldValue, newValue));
				OnPropertyChanged(Properties.ISDATATYPEINFERRED, oldValue, newValue);
			}
		}
		private bool ShouldSerializeIsDataTypeInferred() { return false; }
/// <summary>
///             The DAX expression that is evaluated for the calculated column.
///             </summary>
		[DisplayName("Expression")]
		[Category("Options"),Description(@"The DAX expression that is evaluated for the calculated column."),IntelliSense(@"The DAX expression that is evaluated for the calculated column.")][Editor(typeof(System.ComponentModel.Design.MultilineStringEditor), typeof(System.Drawing.Design.UITypeEditor))]
		public string Expression {
			get {
			    return MetadataObject.Expression;
			}
			set {
				
				var oldValue = Expression;
				var newValue = value.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.EXPRESSION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.Expression = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.EXPRESSION, oldValue, newValue));
				OnPropertyChanged(Properties.EXPRESSION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeExpression() { return false; }

		internal static CalculatedColumn CreateFromMetadata(Table parent, TOM.CalculatedColumn metadataObject) {
			var obj = new CalculatedColumn(metadataObject);
			parent.Columns.Add(obj);
			
			obj.Init();

			return obj;
		}


		/// <summary>
		/// Creates a new CalculatedColumn and adds it to the parent Table.
		/// Also creates the underlying metadataobject and adds it to the TOM tree.
		/// </summary>
		public static CalculatedColumn CreateNew(Table parent, string name = null)
		{
			if(TabularModelHandler.Singleton.UsePowerBIGovernance && !PowerBI.PowerBIGovernance.AllowCreate(typeof(CalculatedColumn))) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(CalculatedColumn).GetTypeName()));
			}

			var metadataObject = new TOM.CalculatedColumn();
			metadataObject.Name = parent.Columns.GetNewName(string.IsNullOrWhiteSpace(name) ? "New " + typeof(CalculatedColumn).GetTypeName() : name);

			var obj = new CalculatedColumn(metadataObject);

			parent.Columns.Add(obj);
			
			obj.Init();

			return obj;
		}


		/// <summary>
		/// Creates an exact copy of this CalculatedColumn object.
		/// </summary>
		public CalculatedColumn Clone(string newName = null, bool includeTranslations = true, Table newParent = null) {
			if(TabularModelHandler.Singleton.UsePowerBIGovernance && !PowerBI.PowerBIGovernance.AllowCreate(typeof(CalculatedColumn))) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(CalculatedColumn).GetTypeName()));
			}

		    Handler.BeginUpdate("Clone CalculatedColumn");

			// Create a clone of the underlying metadataobject:
			var tom = MetadataObject.Clone() as TOM.CalculatedColumn;


			// Assign a new, unique name:
			tom.Name = Parent.Columns.GetNewName(string.IsNullOrEmpty(newName) ? tom.Name + " copy" : newName);
				
			// Create the TOM Wrapper object, representing the metadataobject
			CalculatedColumn obj = CreateFromMetadata(newParent ?? Parent, tom);

			// Copy translations, if applicable:
			if(includeTranslations) {
				obj.CopyTranslationsFrom(this);
			}
				
			// Copy perspectives:
			obj.InPerspective.CopyFrom(InPerspective);

			// TODO: Make sure that dependency trees are properly rebuilt when IDaxDependantObjects are cloned
			// FormulaFixup.BuildDependencyTree(this);
            Handler.EndUpdate();

            return obj;
		}

		TabularNamedObject IClonableObject.Clone(string newName, bool includeTranslations, TabularNamedObject newParent) 
		{
			return Clone(newName);
		}

	
        internal override void RenewMetadataObject()
        {
            Handler.WrapperLookup.Remove(MetadataObject);
            MetadataObject = MetadataObject.Clone() as TOM.CalculatedColumn;
            Handler.WrapperLookup.Add(MetadataObject, this);
        }

		public Table Parent { 
			get {
				return Handler.WrapperLookup[MetadataObject.Parent] as Table;
			}
		}



		/// <summary>
		/// CTOR - only called from static factory methods on the class
		/// </summary>
		CalculatedColumn(TOM.CalculatedColumn metadataObject) : base(metadataObject)
		{
		}



		internal override void Undelete(ITabularObjectCollection collection) {
			base.Undelete(collection);
			Reinit();
			ReapplyReferences();
		}

		public override bool Browsable(string propertyName) {
			switch (propertyName) {
				case Properties.PARENT:
					return false;
				
				default:
					return base.Browsable(propertyName);
			}
		}

    }

  
	/// <summary>
///             Represents a column in a Table that is based on a DAX expression. A collection of CalculatedTableColumn, under a Table object bound to a partition with Source of type CalculatedPartitionSource, results in a calculated table.
///             </summary>
	[TypeConverter(typeof(DynamicPropertyConverter))]
	public sealed partial class CalculatedTableColumn: Column
	{
	    internal new TOM.CalculatedTableColumn MetadataObject 
		{ 
			get 
			{ 
				return base.MetadataObject as TOM.CalculatedTableColumn; 
		    } 
			set 
			{ 
				base.MetadataObject = value; 
			}
		}

/// <summary>
///             A boolean value indicating whether name of the column is inferred by the server.
///             </summary>
		[DisplayName("Name Inferred")]
		[Category("Other"),Description(@"A boolean value indicating whether name of the column is inferred by the server."),IntelliSense(@"A boolean value indicating whether name of the column is inferred by the server.")]
		public bool IsNameInferred {
			get {
			    return MetadataObject.IsNameInferred;
			}
			set {
				
				var oldValue = IsNameInferred;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ISNAMEINFERRED, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.IsNameInferred = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.ISNAMEINFERRED, oldValue, newValue));
				OnPropertyChanged(Properties.ISNAMEINFERRED, oldValue, newValue);
			}
		}
		private bool ShouldSerializeIsNameInferred() { return false; }
/// <summary>
///             A boolean value indicating whether the data type is inferred.
///             </summary>
		[DisplayName("Data Type Inferred")]
		[Category("Other"),Description(@"A boolean value indicating whether the data type is inferred."),IntelliSense(@"A boolean value indicating whether the data type is inferred.")]
		public bool IsDataTypeInferred {
			get {
			    return MetadataObject.IsDataTypeInferred;
			}
			set {
				
				var oldValue = IsDataTypeInferred;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ISDATATYPEINFERRED, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.IsDataTypeInferred = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.ISDATATYPEINFERRED, oldValue, newValue));
				OnPropertyChanged(Properties.ISDATATYPEINFERRED, oldValue, newValue);
			}
		}
		private bool ShouldSerializeIsDataTypeInferred() { return false; }
/// <summary>
///             Name of the column from which data will be retrieved. The name must match a column returned during processing or refresh, where the partition source is an expression (as the Expression of a CalculatedPartitionSource).
///             </summary>
		[DisplayName("Source Column")]
		[Category("Options"),Description(@"Name of the column from which data will be retrieved. The name must match a column returned during processing or refresh, where the partition source is an expression (as the Expression of a CalculatedPartitionSource)."),IntelliSense(@"Name of the column from which data will be retrieved. The name must match a column returned during processing or refresh, where the partition source is an expression (as the Expression of a CalculatedPartitionSource).")]
		public string SourceColumn {
			get {
			    return MetadataObject.SourceColumn;
			}
			set {
				
				var oldValue = SourceColumn;
				var newValue = value.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.SOURCECOLUMN, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.SourceColumn = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.SOURCECOLUMN, oldValue, newValue));
				OnPropertyChanged(Properties.SOURCECOLUMN, oldValue, newValue);
			}
		}
		private bool ShouldSerializeSourceColumn() { return false; }
/// <summary>
///             Returns a ColumnOrigin object. Applicable only to non-calculated columns of a calculated table. ColumnOrigin points to another column which is the source of this column' metadata and data.
///             </summary>
		[DisplayName("Column Origin")]
		[Category("Other"),Description(@"Returns a ColumnOrigin object. Applicable only to non-calculated columns of a calculated table. ColumnOrigin points to another column which is the source of this column' metadata and data."),IntelliSense(@"Returns a ColumnOrigin object. Applicable only to non-calculated columns of a calculated table. ColumnOrigin points to another column which is the source of this column' metadata and data.")][Browsable(false)]
		public Column ColumnOrigin {
			get {
				if (MetadataObject.ColumnOrigin == null) return null;
			    return Handler.WrapperLookup[MetadataObject.ColumnOrigin] as Column;
            }
			
		}
		private bool ShouldSerializeColumnOrigin() { return false; }

		internal static CalculatedTableColumn CreateFromMetadata(Table parent, TOM.CalculatedTableColumn metadataObject) {
			var obj = new CalculatedTableColumn(metadataObject);
			parent.Columns.Add(obj);
			
			obj.Init();

			return obj;
		}

	
        internal override void RenewMetadataObject()
        {
            Handler.WrapperLookup.Remove(MetadataObject);
            MetadataObject = MetadataObject.Clone() as TOM.CalculatedTableColumn;
            Handler.WrapperLookup.Add(MetadataObject, this);
        }

		public Table Parent { 
			get {
				return Handler.WrapperLookup[MetadataObject.Parent] as Table;
			}
		}



		/// <summary>
		/// CTOR - only called from static factory methods on the class
		/// </summary>
		CalculatedTableColumn(TOM.CalculatedTableColumn metadataObject) : base(metadataObject)
		{
		}



		internal override void Undelete(ITabularObjectCollection collection) {
			base.Undelete(collection);
			Reinit();
			ReapplyReferences();
		}

		public override bool Browsable(string propertyName) {
			switch (propertyName) {
				case Properties.PARENT:
					return false;
				
				default:
					return base.Browsable(propertyName);
			}
		}

    }

  
	/// <summary>
///             Represents a base class of a column object of a Tabular model, used to specify a DataColumn, RowNumberColumn, CalculatedColumn, or CalculatedTableColumn.
///             </summary>
	[TypeConverter(typeof(DynamicPropertyConverter))]
	public abstract partial class Column: TabularNamedObject
			, IFolderObject
			, IHideableObject
			, IErrorMessageObject
			, ITabularTableObject
			, IDescriptionObject
			, IFormattableObject
			, IAnnotationObject
			, IExtendedPropertyObject
			, ITabularPerspectiveObject
			, ITranslatableObject
	{
	    internal new TOM.Column MetadataObject 
		{ 
			get 
			{ 
				return base.MetadataObject as TOM.Column; 
		    } 
			set 
			{ 
				base.MetadataObject = value; 
			}
		}

/// <summary> 
///             For a DataColumn, specifies the data type. See <see href="https://msdn.microsoft.com/library/gg492146.aspx" /> for a list of supported data types.  
///             </summary>
		[DisplayName("Data Type")]
		[Category("Metadata"),Description(@"For a DataColumn, specifies the data type. See <see href=""https://msdn.microsoft.com/library/gg492146.aspx for a list of supported data types."),IntelliSense(@"For a DataColumn, specifies the data type. See <see href=""https://msdn.microsoft.com/library/gg492146.aspx for a list of supported data types.")][TypeConverter(typeof(DataTypeEnumConverter))]
		public DataType DataType {
			get {
			    return (DataType)MetadataObject.DataType;
			}
			set {
				
				var oldValue = DataType;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DATATYPE, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.DataType = (TOM.DataType)newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DATATYPE, oldValue, newValue));
				OnPropertyChanged(Properties.DATATYPE, oldValue, newValue);
			}
		}
		private bool ShouldSerializeDataType() { return false; }
        [Browsable(true),NoMultiselect,Category("Translations and Perspectives"),Description("The collection of Annotations on this object."),Editor(typeof(AnnotationCollectionEditor), typeof(UITypeEditor))]
		public AnnotationCollection Annotations { get; private set; }
		public string GetAnnotation(int index) {
			return MetadataObject.Annotations[index].Value;
		}
		[IntelliSense("Returns true if an annotation with the given name exists. Otherwise false.")]
		public bool HasAnnotation(string name) {
		    return MetadataObject.Annotations.ContainsName(name);
		}
		[IntelliSense("Gets the value of the annotation with the given name. Returns null if no such annotation exists.")]
		public string GetAnnotation(string name) {
		    return HasAnnotation(name) ? MetadataObject.Annotations[name].Value : null;
		}
		public void SetAnnotation(int index, string value, bool undoable = true) {
			var name = MetadataObject.Annotations[index].Name;
			SetAnnotation(name, value, undoable);
		}
		public string GetNewAnnotationName() {
			return MetadataObject.Annotations.GetNewName("New Annotation");
		}
		[IntelliSense("Sets the value of the annotation having the given name. If no such annotation exists, it will be created. If value is set to null, the annotation will be removed.")]
		public void SetAnnotation(string name, string value) {
		    SetAnnotation(name, value, true);
		}
		public void SetAnnotation(string name, string value, bool undoable) {
			if(name == null) name = GetNewAnnotationName();

			if(value == null) {
				// Remove annotation if set to null:
				RemoveAnnotation(name, undoable);
				return;
			}

			if(GetAnnotation(name) == value) return;
			bool undoable2 = true;
			bool cancel = false;
			OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + value, ref undoable2, ref cancel);
			if (cancel) return;

			if(MetadataObject.Annotations.Contains(name)) {
				// Change existing annotation:
				var oldValue = GetAnnotation(name);
				MetadataObject.Annotations[name].Value = value;
				if (undoable) Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, oldValue));
				OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, name + ":" + value);
			} else {
				// Add new annotation:
				MetadataObject.Annotations.Add(new TOM.Annotation{ Name = name, Value = value });
				if (undoable) Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, null));
				OnPropertyChanged(Properties.ANNOTATIONS, null, name + ":" + value);
			}

		}
		[IntelliSense("Remove an annotation by the given name.")]
		public void RemoveAnnotation(string name) {
		    RemoveAnnotation(name, true);
		}
		public void RemoveAnnotation(string name, bool undoable) {
			if(MetadataObject.Annotations.Contains(name)) {
				// Get current value:
				bool undoable2 = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + GetAnnotation(name), ref undoable2, ref cancel);
				if (cancel) return;

				var oldValue = MetadataObject.Annotations[name].Value;
				MetadataObject.Annotations.Remove(name);

				// Undo-handling:
				if (undoable) Handler.UndoManager.Add(new UndoAnnotationAction(this, name, null, oldValue));
				OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, null);
			}
		}
		[IntelliSense("Gets the number of annotations on the current object.")]
		public int GetAnnotationsCount() {
			return MetadataObject.Annotations.Count;
		}
		[IntelliSense("Gets a collection of all annotation names on the current object.")]
		public IEnumerable<string> GetAnnotations() {
			return MetadataObject.Annotations.Select(a => a.Name);
		}

		        [DisplayName("Extended Properties"),NoMultiselect,Category("Translations and Perspectives"),Description("The collection of Extended Properties on this object."),Editor(typeof(ExtendedPropertyCollectionEditor), typeof(UITypeEditor))]
		public ExtendedPropertyCollection ExtendedProperties { get; private set; }

		[IntelliSense("Returns true if an ExtendedProperty with the given name exists. Otherwise false.")]
		public bool HasExtendedProperty(string name) {
		    return MetadataObject.ExtendedProperties.ContainsName(name);
		}
		public ExtendedPropertyType GetExtendedPropertyType(int index) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[index].Type;
		}
		public ExtendedPropertyType GetExtendedPropertyType(string name) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[name].Type;
		}
		public string GetExtendedProperty(int index) {
			var ep = MetadataObject.ExtendedProperties[index];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		[IntelliSense("Gets the value of the ExtendedProperty with the given name. Returns null if no such ExtendedProperty exists.")]
		public string GetExtendedProperty(string name) {
		    if(!HasExtendedProperty(name)) return null;
			var ep = MetadataObject.ExtendedProperties[name];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		public void SetExtendedProperty(int index, string value, ExtendedPropertyType type = ExtendedPropertyType.String) {
			var name = MetadataObject.ExtendedProperties[index].Name;
			SetExtendedProperty(name, value, type);
		}
		public string GetNewExtendedPropertyName() {
			return MetadataObject.ExtendedProperties.GetNewName("New ExtendedProperty");
		}
		[IntelliSense("Sets the value of the ExtendedProperty having the given name. If no such ExtendedProperty exists, it will be created. If value is set to null, the ExtendedProperty will be removed.")]
		public void SetExtendedProperty(string name, string value, ExtendedPropertyType type = ExtendedPropertyType.String) {
			if(name == null) name = GetNewExtendedPropertyName();

			if(value == null) {
				// Remove ExtendedProperty if set to null:
				RemoveExtendedProperty(name);
				return;
			}

			if(GetExtendedProperty(name) == value) return;
			bool undoable = true;
			bool cancel = false;
			OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + value, ref undoable, ref cancel);
			if (cancel) return;

			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Change existing ExtendedProperty:
				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				var ep = MetadataObject.ExtendedProperties[name];
				if (ep is TOM.JsonExtendedProperty)
					(ep as TOM.JsonExtendedProperty).Value = value;
				else 
					(ep as TOM.StringExtendedProperty).Value = value;
					
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, name + ":" + value);
			} else {
				// Add new ExtendedProperty:
				if (type == ExtendedPropertyType.Json)
					MetadataObject.ExtendedProperties.Add(new TOM.JsonExtendedProperty{ Name = name, Value = value });
				else
					MetadataObject.ExtendedProperties.Add(new TOM.StringExtendedProperty{ Name = name, Value = value });

				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, null, type));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, null, name + ":" + value);
			}

		}
		[IntelliSense("Remove an ExtendedProperty by the given name.")]
		public void RemoveExtendedProperty(string name) {
			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Get current value:
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + GetExtendedProperty(name), ref undoable, ref cancel);
				if (cancel) return;

				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				MetadataObject.ExtendedProperties.Remove(name);

				// Undo-handling:
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, null, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, null);
			}
		}
		[IntelliSense("Gets the number of ExtendedProperties on the current object.")]
		public int GetExtendedPropertyCount() {
			return MetadataObject.ExtendedProperties.Count;
		}
		[IntelliSense("Gets a collection of all ExtendedProperty names on the current object.")]
		public IEnumerable<string> GetExtendedProperties() {
			return MetadataObject.ExtendedProperties.Select(a => a.Name);
		}

		/// <summary>
///             Specifies the type of data contained in the column so that you can add custom behaviors based on column type. There are 248 possible values. The first ten are Invalid (-1), All (1), Regular (2), Image (3), ImageBMP (4), ImageGIF (5), ImageJPG (6), ImagePNG (7), ImageTIFF (8), ImageURL (9), Id (10). For the rest, please refer to the MS-SSAS-T SQL Server Analysis Services Tabular Protocol documentation on MSDN.
///             </summary>
		[DisplayName("Data Category")]
		[Category("Metadata"),Description(@"Specifies the type of data contained in the column so that you can add custom behaviors based on column type. There are 248 possible values. The first ten are Invalid (-1), All (1), Regular (2), Image (3), ImageBMP (4), ImageGIF (5), ImageJPG (6), ImagePNG (7), ImageTIFF (8), ImageURL (9), Id (10). For the rest, please refer to the MS-SSAS-T SQL Server Analysis Services Tabular Protocol documentation on MSDN."),IntelliSense(@"Specifies the type of data contained in the column so that you can add custom behaviors based on column type. There are 248 possible values. The first ten are Invalid (-1), All (1), Regular (2), Image (3), ImageBMP (4), ImageGIF (5), ImageJPG (6), ImagePNG (7), ImageTIFF (8), ImageURL (9), Id (10). For the rest, please refer to the MS-SSAS-T SQL Server Analysis Services Tabular Protocol documentation on MSDN.")]
		public string DataCategory {
			get {
			    return MetadataObject.DataCategory;
			}
			set {
				
				var oldValue = DataCategory;
				var newValue = value.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DATACATEGORY, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.DataCategory = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DATACATEGORY, oldValue, newValue));
				OnPropertyChanged(Properties.DATACATEGORY, oldValue, newValue);
			}
		}
		private bool ShouldSerializeDataCategory() { return false; }
/// <summary>
///             The description of the column, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio.
///             </summary>
		[DisplayName("Description")]
		[Category("Basic"),Description(@"The description of the column, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio."),IntelliSense(@"The description of the column, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio.")][Editor(typeof(System.ComponentModel.Design.MultilineStringEditor), typeof(System.Drawing.Design.UITypeEditor))]
		public string Description {
			get {
			    return MetadataObject.Description;
			}
			set {
				
				var oldValue = Description;
				var newValue = value.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DESCRIPTION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.Description = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DESCRIPTION, oldValue, newValue));
				OnPropertyChanged(Properties.DESCRIPTION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeDescription() { return false; }
/// <summary>
///             A boolean value that indicates whether a column is treated as hidden by client visualization tools. True if the column is treated as hidden; otherwise false.
///             </summary>
		[DisplayName("Hidden")]
		[Category("Basic"),Description(@"A boolean value that indicates whether a column is treated as hidden by client visualization tools. True if the column is treated as hidden; otherwise false."),IntelliSense(@"A boolean value that indicates whether a column is treated as hidden by client visualization tools. True if the column is treated as hidden; otherwise false.")]
		public bool IsHidden {
			get {
			    return MetadataObject.IsHidden;
			}
			set {
				
				var oldValue = IsHidden;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ISHIDDEN, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.IsHidden = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.ISHIDDEN, oldValue, newValue));
				OnPropertyChanged(Properties.ISHIDDEN, oldValue, newValue);
				Handler.UpdateObject(this);
			}
		}
		private bool ShouldSerializeIsHidden() { return false; }
/// <summary>
///             Enumerates the state of the column. Possible values include the following. Ready (1) The column is queryable and has up-to-date data. NoData (3) The column is queryable but has no data. This state is applicable only to columns of the type Data. CalculationNeeded (4) The column is not queryable and needs to be refreshed (that is, recalculated) to become functional. This state applies only to columns of the type Calculated or CalculatedTableColumn. SemanticError (5) The column is in an error state because of an invalid expression. The column is not queryable. This state applies only to columns of the type Calculated or CalculatedTableColumn. EvaluationError (6) The column is in an error state because of an error during expression evaluation. The column is not queryable.  This state applies only to columns of the type Calculated or CalculatedTableColumn. DependencyError (7) The column is in an error state because some of its calculation dependencies are in an error state.  The column is not queryable. This state applies only to columns of the type Calculated or CalculatedTableColumn. Incomplete (8) Some parts of the column have no data, and the column needs to be refreshed to bring the data in. The column is queryable. This state applies only to columns of the type Data. SyntaxError (9) The column is in an error state because of a syntax error in its expression. The column is not queryable. This state applies only to columns of the type Calculated.
///             </summary>
		[DisplayName("State")]
		[Category("Metadata"),Description(@"Enumerates the state of the column. Possible values include the following. Ready (1) The column is queryable and has up-to-date data. NoData (3) The column is queryable but has no data. This state is applicable only to columns of the type Data. CalculationNeeded (4) The column is not queryable and needs to be refreshed (that is, recalculated) to become functional. This state applies only to columns of the type Calculated or CalculatedTableColumn. SemanticError (5) The column is in an error state because of an invalid expression. The column is not queryable. This state applies only to columns of the type Calculated or CalculatedTableColumn. EvaluationError (6) The column is in an error state because of an error during expression evaluation. The column is not queryable.  This state applies only to columns of the type Calculated or CalculatedTableColumn. DependencyError (7) The column is in an error state because some of its calculation dependencies are in an error state.  The column is not queryable. This state applies only to columns of the type Calculated or CalculatedTableColumn. Incomplete (8) Some parts of the column have no data, and the column needs to be refreshed to bring the data in. The column is queryable. This state applies only to columns of the type Data. SyntaxError (9) The column is in an error state because of a syntax error in its expression. The column is not queryable. This state applies only to columns of the type Calculated."),IntelliSense(@"Enumerates the state of the column. Possible values include the following. Ready (1) The column is queryable and has up-to-date data. NoData (3) The column is queryable but has no data. This state is applicable only to columns of the type Data. CalculationNeeded (4) The column is not queryable and needs to be refreshed (that is, recalculated) to become functional. This state applies only to columns of the type Calculated or CalculatedTableColumn. SemanticError (5) The column is in an error state because of an invalid expression. The column is not queryable. This state applies only to columns of the type Calculated or CalculatedTableColumn. EvaluationError (6) The column is in an error state because of an error during expression evaluation. The column is not queryable.  This state applies only to columns of the type Calculated or CalculatedTableColumn. DependencyError (7) The column is in an error state because some of its calculation dependencies are in an error state.  The column is not queryable. This state applies only to columns of the type Calculated or CalculatedTableColumn. Incomplete (8) Some parts of the column have no data, and the column needs to be refreshed to bring the data in. The column is queryable. This state applies only to columns of the type Data. SyntaxError (9) The column is in an error state because of a syntax error in its expression. The column is not queryable. This state applies only to columns of the type Calculated.")]
		public ObjectState State {
			get {
			    return (ObjectState)MetadataObject.State;
			}
			
		}
		private bool ShouldSerializeState() { return false; }
/// <summary>
///             A boolean value that indicates whether the column contains only unique values. True if the values are unique; otherwise false.
///             </summary>
		[DisplayName("Unique")]
		[Category("Other"),Description(@"A boolean value that indicates whether the column contains only unique values. True if the values are unique; otherwise false."),IntelliSense(@"A boolean value that indicates whether the column contains only unique values. True if the values are unique; otherwise false.")]
		public bool IsUnique {
			get {
			    return MetadataObject.IsUnique;
			}
			set {
				
				var oldValue = IsUnique;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ISUNIQUE, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.IsUnique = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.ISUNIQUE, oldValue, newValue));
				OnPropertyChanged(Properties.ISUNIQUE, oldValue, newValue);
			}
		}
		private bool ShouldSerializeIsUnique() { return false; }
/// <summary>
///             A boolean value that indicates whether the column is a key of the table. True if the column is a key of the table; otherwise false.
///             </summary>
		[DisplayName("Key")]
		[Category("Other"),Description(@"A boolean value that indicates whether the column is a key of the table. True if the column is a key of the table; otherwise false."),IntelliSense(@"A boolean value that indicates whether the column is a key of the table. True if the column is a key of the table; otherwise false.")]
		public bool IsKey {
			get {
			    return MetadataObject.IsKey;
			}
			set {
				
				var oldValue = IsKey;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ISKEY, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.IsKey = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.ISKEY, oldValue, newValue));
				OnPropertyChanged(Properties.ISKEY, oldValue, newValue);
			}
		}
		private bool ShouldSerializeIsKey() { return false; }
/// <summary>
///             If <b>false</b>, the column cannot contain nulls. Even if <b>true</b>, it may still not allow nulls if it's a key column.
///             </summary>
		[DisplayName("Nullable")]
		[Category("Other"),Description(@"If <b>false</b>, the column cannot contain nulls. Even if <b>true</b>, it may still not allow nulls if it's a key column."),IntelliSense(@"If <b>false</b>, the column cannot contain nulls. Even if <b>true</b>, it may still not allow nulls if it's a key column.")]
		public bool IsNullable {
			get {
			    return MetadataObject.IsNullable;
			}
			set {
				
				var oldValue = IsNullable;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ISNULLABLE, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.IsNullable = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.ISNULLABLE, oldValue, newValue));
				OnPropertyChanged(Properties.ISNULLABLE, oldValue, newValue);
			}
		}
		private bool ShouldSerializeIsNullable() { return false; }
/// <summary>
///             Specifies the text alignment of the column in report visualizations. The possible values are Default (1), Left (2), Right (3), Center (4).
///             </summary>
		[DisplayName("Alignment")]
		[Category("Other"),Description(@"Specifies the text alignment of the column in report visualizations. The possible values are Default (1), Left (2), Right (3), Center (4)."),IntelliSense(@"Specifies the text alignment of the column in report visualizations. The possible values are Default (1), Left (2), Right (3), Center (4).")]
		public Alignment Alignment {
			get {
			    return (Alignment)MetadataObject.Alignment;
			}
			set {
				
				var oldValue = Alignment;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ALIGNMENT, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.Alignment = (TOM.Alignment)newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.ALIGNMENT, oldValue, newValue));
				OnPropertyChanged(Properties.ALIGNMENT, oldValue, newValue);
			}
		}
		private bool ShouldSerializeAlignment() { return false; }
/// <summary>
///             Determines whether you can place this column in the DefaultDetails collection of the Table. This collection is an ordered set of Column types. A positive value indicates participation in the collection. The collection is sorted in ascending order of this element. The DefaultDetails collection is returned as part of the CSDL metadata returned by the DISCOVER_CSDL_METADATA operation.
///             </summary>
		[DisplayName("Table Detail Position")]
		[Category("Other"),Description(@"Determines whether you can place this column in the DefaultDetails collection of the Table. This collection is an ordered set of Column types. A positive value indicates participation in the collection. The collection is sorted in ascending order of this element. The DefaultDetails collection is returned as part of the CSDL metadata returned by the DISCOVER_CSDL_METADATA operation."),IntelliSense(@"Determines whether you can place this column in the DefaultDetails collection of the Table. This collection is an ordered set of Column types. A positive value indicates participation in the collection. The collection is sorted in ascending order of this element. The DefaultDetails collection is returned as part of the CSDL metadata returned by the DISCOVER_CSDL_METADATA operation.")]
		public int TableDetailPosition {
			get {
			    return MetadataObject.TableDetailPosition;
			}
			set {
				
				var oldValue = TableDetailPosition;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.TABLEDETAILPOSITION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.TableDetailPosition = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.TABLEDETAILPOSITION, oldValue, newValue));
				OnPropertyChanged(Properties.TABLEDETAILPOSITION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeTableDetailPosition() { return false; }
/// <summary>
///             A boolean value that indicates whether this column is included in the DisplayKey element in CSDL.
///             </summary>
		[DisplayName("Default Label")]
		[Category("Other"),Description(@"A boolean value that indicates whether this column is included in the DisplayKey element in CSDL."),IntelliSense(@"A boolean value that indicates whether this column is included in the DisplayKey element in CSDL.")]
		public bool IsDefaultLabel {
			get {
			    return MetadataObject.IsDefaultLabel;
			}
			set {
				
				var oldValue = IsDefaultLabel;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ISDEFAULTLABEL, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.IsDefaultLabel = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.ISDEFAULTLABEL, oldValue, newValue));
				OnPropertyChanged(Properties.ISDEFAULTLABEL, oldValue, newValue);
			}
		}
		private bool ShouldSerializeIsDefaultLabel() { return false; }
/// <summary>
///             A boolean value that indicates whether this column is returned as the DefaultImage property in CSDL.
///             </summary>
		[DisplayName("Default Image")]
		[Category("Other"),Description(@"A boolean value that indicates whether this column is returned as the DefaultImage property in CSDL."),IntelliSense(@"A boolean value that indicates whether this column is returned as the DefaultImage property in CSDL.")]
		public bool IsDefaultImage {
			get {
			    return MetadataObject.IsDefaultImage;
			}
			set {
				
				var oldValue = IsDefaultImage;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ISDEFAULTIMAGE, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.IsDefaultImage = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.ISDEFAULTIMAGE, oldValue, newValue));
				OnPropertyChanged(Properties.ISDEFAULTIMAGE, oldValue, newValue);
			}
		}
		private bool ShouldSerializeIsDefaultImage() { return false; }
/// <summary>
///             A value indicating the default function, if any, used to aggregate this field. The possible values are Default (1), None (2), Sum (3), Min (4), Max (5), Count (6), Average (7), DistinctCount (8). If unspecified, Default is assumed for numeric fields, None for all other fields.
///             </summary>
		[DisplayName("Summarize By")]
		[Category("Other"),Description(@"A value indicating the default function, if any, used to aggregate this field. The possible values are Default (1), None (2), Sum (3), Min (4), Max (5), Count (6), Average (7), DistinctCount (8). If unspecified, Default is assumed for numeric fields, None for all other fields."),IntelliSense(@"A value indicating the default function, if any, used to aggregate this field. The possible values are Default (1), None (2), Sum (3), Min (4), Max (5), Count (6), Average (7), DistinctCount (8). If unspecified, Default is assumed for numeric fields, None for all other fields.")]
		public AggregateFunction SummarizeBy {
			get {
			    return (AggregateFunction)MetadataObject.SummarizeBy;
			}
			set {
				
				var oldValue = SummarizeBy;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.SUMMARIZEBY, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.SummarizeBy = (TOM.AggregateFunction)newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.SUMMARIZEBY, oldValue, newValue));
				OnPropertyChanged(Properties.SUMMARIZEBY, oldValue, newValue);
			}
		}
		private bool ShouldSerializeSummarizeBy() { return false; }
/// <summary>
///             Specifies the data binding. Values include Data (1) where the contents of this column come from a DataSource, Calculated (2) where the contents are computed from an expression after the Data columns have been populated, RowNumber (3) where the column is an internal column representing the row number, or CalculatedTableColumn (4) where tables that are based on a calculated expression will automatically infer and generate the columns in the table.
///             </summary>
		[DisplayName("Type")]
		[Category("Other"),Description(@"Specifies the data binding. Values include Data (1) where the contents of this column come from a DataSource, Calculated (2) where the contents are computed from an expression after the Data columns have been populated, RowNumber (3) where the column is an internal column representing the row number, or CalculatedTableColumn (4) where tables that are based on a calculated expression will automatically infer and generate the columns in the table."),IntelliSense(@"Specifies the data binding. Values include Data (1) where the contents of this column come from a DataSource, Calculated (2) where the contents are computed from an expression after the Data columns have been populated, RowNumber (3) where the column is an internal column representing the row number, or CalculatedTableColumn (4) where tables that are based on a calculated expression will automatically infer and generate the columns in the table.")][Browsable(false)]
		public ColumnType Type {
			get {
			    return (ColumnType)MetadataObject.Type;
			}
			
		}
		private bool ShouldSerializeType() { return false; }
/// <summary>
///             A string that specifies the format of the column contents. 
///             </summary>
		[DisplayName("Format String")]
		[Category("Options"),Description(@"A string that specifies the format of the column contents."),IntelliSense(@"A string that specifies the format of the column contents.")][TypeConverter(typeof(FormatStringConverter))]
		public string FormatString {
			get {
			    return MetadataObject.FormatString;
			}
			set {
				
				var oldValue = FormatString;
				var newValue = value.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.FORMATSTRING, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.FormatString = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.FORMATSTRING, oldValue, newValue));
				OnPropertyChanged(Properties.FORMATSTRING, oldValue, newValue);
			}
		}
		private bool ShouldSerializeFormatString() { return false; }
/// <summary>
///             A boolean value that indicates whether the column can be excluded from usage in MDX query tools. False if the column can be excluded from usage in MDX query tools; otherwise true.
///             </summary>
		[DisplayName("Available In MDX")]
		[Category("Other"),Description(@"A boolean value that indicates whether the column can be excluded from usage in MDX query tools. False if the column can be excluded from usage in MDX query tools; otherwise true."),IntelliSense(@"A boolean value that indicates whether the column can be excluded from usage in MDX query tools. False if the column can be excluded from usage in MDX query tools; otherwise true.")]
		public bool IsAvailableInMDX {
			get {
			    return MetadataObject.IsAvailableInMDX;
			}
			set {
				
				var oldValue = IsAvailableInMDX;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ISAVAILABLEINMDX, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.IsAvailableInMDX = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.ISAVAILABLEINMDX, oldValue, newValue));
				OnPropertyChanged(Properties.ISAVAILABLEINMDX, oldValue, newValue);
			}
		}
		private bool ShouldSerializeIsAvailableInMDX() { return false; }
/// <summary>
///             Specifies the grouping behavior used for building a hierarchy. True groups by entity key. False groups by value.
///             </summary>
		[DisplayName("Keep Unique Rows")]
		[Category("Other"),Description(@"Specifies the grouping behavior used for building a hierarchy. True groups by entity key. False groups by value."),IntelliSense(@"Specifies the grouping behavior used for building a hierarchy. True groups by entity key. False groups by value.")]
		public bool KeepUniqueRows {
			get {
			    return MetadataObject.KeepUniqueRows;
			}
			set {
				
				var oldValue = KeepUniqueRows;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.KEEPUNIQUEROWS, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.KeepUniqueRows = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.KEEPUNIQUEROWS, oldValue, newValue));
				OnPropertyChanged(Properties.KEEPUNIQUEROWS, oldValue, newValue);
			}
		}
		private bool ShouldSerializeKeepUniqueRows() { return false; }
/// <summary>
///             Indicates the visual position of the column, defined as a relative ordering rather than a strict ordering (example: 10, 20, 40, 50). It allows client applications to maintain a consistent column position.
///             </summary>
		[DisplayName("Display Ordinal")]
		[Category("Other"),Description(@"Indicates the visual position of the column, defined as a relative ordering rather than a strict ordering (example: 10, 20, 40, 50). It allows client applications to maintain a consistent column position."),IntelliSense(@"Indicates the visual position of the column, defined as a relative ordering rather than a strict ordering (example: 10, 20, 40, 50). It allows client applications to maintain a consistent column position.")]
		public int DisplayOrdinal {
			get {
			    return MetadataObject.DisplayOrdinal;
			}
			set {
				
				var oldValue = DisplayOrdinal;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DISPLAYORDINAL, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.DisplayOrdinal = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DISPLAYORDINAL, oldValue, newValue));
				OnPropertyChanged(Properties.DISPLAYORDINAL, oldValue, newValue);
			}
		}
		private bool ShouldSerializeDisplayOrdinal() { return false; }
/// <summary>
///             A string that explains the error state associated with the current object. It is set by the engine only when the state of the object is one of these three values: SemanticError, DependencyError, or EvaluationError. It is applicable only to columns of the type Calculated or CalculatedTableColumn. It will be empty for other column objects.
///             </summary>
		[DisplayName("Error Message")]
		[Category("Metadata"),Description(@"A string that explains the error state associated with the current object. It is set by the engine only when the state of the object is one of these three values: SemanticError, DependencyError, or EvaluationError. It is applicable only to columns of the type Calculated or CalculatedTableColumn. It will be empty for other column objects."),IntelliSense(@"A string that explains the error state associated with the current object. It is set by the engine only when the state of the object is one of these three values: SemanticError, DependencyError, or EvaluationError. It is applicable only to columns of the type Calculated or CalculatedTableColumn. It will be empty for other column objects.")]
		public string ErrorMessage {
			get {
			    return MetadataObject.ErrorMessage;
			}
			
		}
		private bool ShouldSerializeErrorMessage() { return false; }
/// <summary>
///             The original data type of the column as defined in the language of the data source. This data type is used to generate queries directly against the data source, for example in DirectQuery mode.
///             </summary>
		[DisplayName("Source Provider Type")]
		[Category("Other"),Description(@"The original data type of the column as defined in the language of the data source. This data type is used to generate queries directly against the data source, for example in DirectQuery mode."),IntelliSense(@"The original data type of the column as defined in the language of the data source. This data type is used to generate queries directly against the data source, for example in DirectQuery mode.")]
		public string SourceProviderType {
			get {
			    return MetadataObject.SourceProviderType;
			}
			set {
				
				var oldValue = SourceProviderType;
				var newValue = value.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.SOURCEPROVIDERTYPE, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.SourceProviderType = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.SOURCEPROVIDERTYPE, oldValue, newValue));
				OnPropertyChanged(Properties.SOURCEPROVIDERTYPE, oldValue, newValue);
			}
		}
		private bool ShouldSerializeSourceProviderType() { return false; }
/// <summary>
///             Defines the display folder for the column, for use by clients.
///             </summary>
		[DisplayName("Display Folder")]
		[Category("Basic"),Description(@"Defines the display folder for the column, for use by clients."),IntelliSense(@"Defines the display folder for the column, for use by clients.")][Editor(typeof(CustomDialogEditor), typeof(System.Drawing.Design.UITypeEditor))]
		public string DisplayFolder {
			get {
			    return MetadataObject.DisplayFolder;
			}
			set {
				if(value.Contains(@"\\")) throw new Exception("Display Folder names cannot be blank.");
				var oldValue = DisplayFolder;
				var newValue = value.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DISPLAYFOLDER, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.DisplayFolder = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DISPLAYFOLDER, oldValue, newValue));
				OnPropertyChanged(Properties.DISPLAYFOLDER, oldValue, newValue);
				Handler.UpdateFolders(Table);
			}
		}
		private bool ShouldSerializeDisplayFolder() { return false; }
        /// <summary>
        /// Collection of localized Display Folders for this Column.
        /// </summary>
        [Browsable(true),DisplayName("Translated Display Folders"),Description("Shows all translated Display Folders of this object."),Category("Translations and Perspectives")]
	    public TranslationIndexer TranslatedDisplayFolders { private set; get; }
/// <summary>
///             This property allows an encoding hint to be specified for the column. A numeric column may use either value-based encoding or hash-based encoding. Usually the server will automatically attempt detect which encoding to use, but re-encoding may occur later. This property allows hinting to the server that it should start with a different encoding type.
///             </summary><remarks>This property is only supported when the compatibility level of the database is at 1400 or above.</remarks>
		[DisplayName("Encoding Hint")]
		[Category("Other"),Description(@"This property allows an encoding hint to be specified for the column. A numeric column may use either value-based encoding or hash-based encoding. Usually the server will automatically attempt detect which encoding to use, but re-encoding may occur later. This property allows hinting to the server that it should start with a different encoding type."),IntelliSense(@"This property allows an encoding hint to be specified for the column. A numeric column may use either value-based encoding or hash-based encoding. Usually the server will automatically attempt detect which encoding to use, but re-encoding may occur later. This property allows hinting to the server that it should start with a different encoding type.")]
		public EncodingHintType EncodingHint {
			get {
			    return (EncodingHintType)MetadataObject.EncodingHint;
			}
			set {
				
				var oldValue = EncodingHint;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ENCODINGHINT, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.EncodingHint = (TOM.EncodingHintType)newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.ENCODINGHINT, oldValue, newValue));
				OnPropertyChanged(Properties.ENCODINGHINT, oldValue, newValue);
			}
		}
		private bool ShouldSerializeEncodingHint() { return false; }
		[Browsable(false)]
		public Table Table
		{ 
			get 
			{ 
				TabularObject t = null;
				if(MetadataObject == null || MetadataObject.Table == null) return null;
				if(!Handler.WrapperLookup.TryGetValue(MetadataObject.Table, out t)) {
				    t = Model.Tables[MetadataObject.Table.Name];
				}
				return t as Table;
			} 
		}
/// <summary>
///             Indicates that the column defining this property will be sorted by the values of the column referenced by this property.
///             </summary>
		[DisplayName("Sort By Column")]
		[Category("Options"),Description(@"Indicates that the column defining this property will be sorted by the values of the column referenced by this property."),IntelliSense(@"Indicates that the column defining this property will be sorted by the values of the column referenced by this property.")][TypeConverter(typeof(TableColumnConverter))]
		public Column SortByColumn {
			get {
				if (MetadataObject.SortByColumn == null) return null;
			    return Handler.WrapperLookup[MetadataObject.SortByColumn] as Column;
            }
			set {
				
				var oldValue = SortByColumn;
				var newValue = value;
				if (oldValue?.MetadataObject == newValue?.MetadataObject) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.SORTBYCOLUMN, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.SortByColumn = value == null ? null : Table.Columns[value.MetadataObject.Name].MetadataObject;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.SORTBYCOLUMN, oldValue, newValue));
				OnPropertyChanged(Properties.SORTBYCOLUMN, oldValue, newValue);
			}
		}
		private bool ShouldSerializeSortByColumn() { return false; }

        /// <Summary>
		/// Collection of perspectives in which this Column is visible.
		/// </Summary>
		[Browsable(true),DisplayName("Shown in Perspective"), Description("Provides an easy way to include or exclude this object from the perspectives of the model."), Category("Translations and Perspectives")]
        public PerspectiveColumnIndexer InPerspective { get; private set; }
		PerspectiveIndexer ITabularPerspectiveObject.InPerspective { get { return this.InPerspective; } }
        /// <summary>
        /// Collection of localized descriptions for this Column.
        /// </summary>
        [Browsable(true),DisplayName("Translated Descriptions"),Description("Shows all translated descriptions of this object."),Category("Translations and Perspectives")]
	    public TranslationIndexer TranslatedDescriptions { private set; get; }
        /// <summary>
        /// Collection of localized names for this Column.
        /// </summary>
        [Browsable(true),DisplayName("Translated Names"),Description("Shows all translated names of this object."),Category("Translations and Perspectives")]
	    public TranslationIndexer TranslatedNames { private set; get; }

	
        internal override void RenewMetadataObject()
        {
            Handler.WrapperLookup.Remove(MetadataObject);
            MetadataObject = MetadataObject.Clone() as TOM.Column;
            Handler.WrapperLookup.Add(MetadataObject, this);
        }


        internal override ITabularObjectCollection GetCollectionForChild(TabularObject child)
        {
			if (child is Variation) return Variations;
            return base.GetCollectionForChild(child);
        }

        /// <summary>
        /// The collection of Variation objects on this Column.
        /// </summary>
		[DisplayName("Variations")]
		[Category("Other"),IntelliSense("The collection of Variation objects on this Column.")][NoMultiselect(),Editor(typeof(VariationCollectionEditor),typeof(UITypeEditor))]
		public VariationCollection Variations { get; protected set; }

		/// <summary>
		/// CTOR - only called from static factory methods on the class
		/// </summary>
		protected Column(TOM.Column metadataObject) : base(metadataObject)
		{
			// Create indexers for translations:
			TranslatedNames = new TranslationIndexer(this, TOM.TranslatedProperty.Caption);
			TranslatedDescriptions = new TranslationIndexer(this, TOM.TranslatedProperty.Description);
			TranslatedDisplayFolders = new TranslationIndexer(this, TOM.TranslatedProperty.DisplayFolder);

			// Create indexer for perspectives:
			InPerspective = new PerspectiveColumnIndexer(this);
			
			// Create indexer for annotations:
			Annotations = new AnnotationCollection(this);
			
			// Create indexer for extended properties:
			ExtendedProperties = new ExtendedPropertyCollection(this);
			
			// Instantiate child collections:
			Variations = new VariationCollection(this.GetObjectPath() + ".Variations", MetadataObject.Variations, this);

			// Populate child collections:
			Variations.CreateChildrenFromMetadata();

			// Hook up event handlers on child collections:
			Variations.CollectionChanged += Children_CollectionChanged;
		}


		internal override void Reinit() {
			Variations.Reinit();
		}

		internal override void Undelete(ITabularObjectCollection collection) {
			base.Undelete(collection);
			Reinit();
			ReapplyReferences();
		}

		public override bool Browsable(string propertyName) {
			switch (propertyName) {
 
				case Properties.EXTENDEDPROPERTIES:
					return Handler.CompatibilityLevel >= 1400;
				
				// Hides translation properties in the grid, unless the model actually contains translations:
				case Properties.TRANSLATEDNAMES:
				case Properties.TRANSLATEDDESCRIPTIONS:
				case Properties.TRANSLATEDDISPLAYFOLDERS:
					return Model.Cultures.Any();
				
				// Hides the perspective property in the grid, unless the model actually contains perspectives:
				case Properties.INPERSPECTIVE:
					return Model.Perspectives.Any();
				
				default:
					return base.Browsable(propertyName);
			}
		}

    }


	/// <summary>
	/// Collection class for Column. Provides convenient properties for setting a property on multiple objects at once.
	/// </summary>
	public sealed partial class ColumnCollection: TabularObjectCollection<Column>
	{
		internal Table Table { get { return Parent as Table; } }
		TOM.ColumnCollection TOM_Collection;
		internal ColumnCollection(string collectionName, TOM.ColumnCollection metadataObjectCollection, Table parent) : base(collectionName, parent)
		{
			TOM_Collection = metadataObjectCollection;
		}
		internal override Type GetItemType() { return typeof(Column); }
        protected override void TOM_Add(TOM.MetadataObject obj) { TOM_Collection.Add(obj as TOM.Column); }
        protected override bool TOM_Contains(TOM.MetadataObject obj) { return TOM_Collection.Contains(obj as TOM.Column); }
        protected override void TOM_Remove(TOM.MetadataObject obj) { TOM_Collection.Remove(obj as TOM.Column); }
        protected override void TOM_Clear() { TOM_Collection.Clear(); }
        protected override bool TOM_ContainsName(string name) { return TOM_Collection.ContainsName(name); }
        protected override TOM.MetadataObject TOM_Get(int index) { return TOM_Collection[index]; }
        protected override TOM.MetadataObject TOM_Get(string name) { return TOM_Collection[name]; }
		internal override void Reinit() {
			var ixOffset = 0;
			for(int i = 0; i < Count; i++) {
				var item = this[i];
				Handler.WrapperLookup.Remove(item.MetadataObject);
				if(Table.MetadataObject.Columns[i] is TOM.RowNumberColumn) ixOffset++;
				item.MetadataObject = Table.MetadataObject.Columns[i + ixOffset] as TOM.Column;
				Handler.WrapperLookup.Add(item.MetadataObject, item);
				item.Collection = this;
			}
			TOM_Collection = Table.MetadataObject.Columns;
			foreach(var item in this) item.Reinit();
		}

		internal override void ReapplyReferences() {
			foreach(var item in this) item.ReapplyReferences();
		}

		/// <summary>
		/// Calling this method will populate the ColumnCollection with objects based on the MetadataObjects in the corresponding MetadataObjectCollection.
		/// </summary>
		internal override void CreateChildrenFromMetadata()
		{
			// Construct child objects (they are automatically added to the Handler's WrapperLookup dictionary):
			foreach(var obj in TOM_Collection) {
				if(obj is TOM.DataColumn) DataColumn.CreateFromMetadata(Table, obj as TOM.DataColumn);
				if(obj is TOM.CalculatedTableColumn) CalculatedTableColumn.CreateFromMetadata(Table, obj as TOM.CalculatedTableColumn);
				if(obj is TOM.CalculatedColumn) CalculatedColumn.CreateFromMetadata(Table, obj as TOM.CalculatedColumn);
		    }
		}

		/// <summary>
		/// Sets the DataType property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the DataType property of all objects in the collection at once.")]
		public DataType DataType {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("DataType"));
				this.ToList().ForEach(item => { item.DataType = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the DataCategory property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the DataCategory property of all objects in the collection at once.")]
		public string DataCategory {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("DataCategory"));
				this.ToList().ForEach(item => { item.DataCategory = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the Description property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the Description property of all objects in the collection at once.")]
		public string Description {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("Description"));
				this.ToList().ForEach(item => { item.Description = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the IsHidden property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the IsHidden property of all objects in the collection at once.")]
		public bool IsHidden {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("IsHidden"));
				this.ToList().ForEach(item => { item.IsHidden = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the IsUnique property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the IsUnique property of all objects in the collection at once.")]
		public bool IsUnique {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("IsUnique"));
				this.ToList().ForEach(item => { item.IsUnique = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the IsKey property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the IsKey property of all objects in the collection at once.")]
		public bool IsKey {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("IsKey"));
				this.ToList().ForEach(item => { item.IsKey = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the IsNullable property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the IsNullable property of all objects in the collection at once.")]
		public bool IsNullable {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("IsNullable"));
				this.ToList().ForEach(item => { item.IsNullable = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the Alignment property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the Alignment property of all objects in the collection at once.")]
		public Alignment Alignment {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("Alignment"));
				this.ToList().ForEach(item => { item.Alignment = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the TableDetailPosition property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the TableDetailPosition property of all objects in the collection at once.")]
		public int TableDetailPosition {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("TableDetailPosition"));
				this.ToList().ForEach(item => { item.TableDetailPosition = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the IsDefaultLabel property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the IsDefaultLabel property of all objects in the collection at once.")]
		public bool IsDefaultLabel {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("IsDefaultLabel"));
				this.ToList().ForEach(item => { item.IsDefaultLabel = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the IsDefaultImage property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the IsDefaultImage property of all objects in the collection at once.")]
		public bool IsDefaultImage {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("IsDefaultImage"));
				this.ToList().ForEach(item => { item.IsDefaultImage = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the SummarizeBy property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the SummarizeBy property of all objects in the collection at once.")]
		public AggregateFunction SummarizeBy {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("SummarizeBy"));
				this.ToList().ForEach(item => { item.SummarizeBy = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the FormatString property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the FormatString property of all objects in the collection at once.")]
		public string FormatString {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("FormatString"));
				this.ToList().ForEach(item => { item.FormatString = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the IsAvailableInMDX property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the IsAvailableInMDX property of all objects in the collection at once.")]
		public bool IsAvailableInMDX {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("IsAvailableInMDX"));
				this.ToList().ForEach(item => { item.IsAvailableInMDX = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the KeepUniqueRows property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the KeepUniqueRows property of all objects in the collection at once.")]
		public bool KeepUniqueRows {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("KeepUniqueRows"));
				this.ToList().ForEach(item => { item.KeepUniqueRows = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the DisplayOrdinal property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the DisplayOrdinal property of all objects in the collection at once.")]
		public int DisplayOrdinal {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("DisplayOrdinal"));
				this.ToList().ForEach(item => { item.DisplayOrdinal = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the SourceProviderType property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the SourceProviderType property of all objects in the collection at once.")]
		public string SourceProviderType {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("SourceProviderType"));
				this.ToList().ForEach(item => { item.SourceProviderType = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the DisplayFolder property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the DisplayFolder property of all objects in the collection at once.")]
		public string DisplayFolder {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("DisplayFolder"));
				this.ToList().ForEach(item => { item.DisplayFolder = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the EncodingHint property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the EncodingHint property of all objects in the collection at once.")]
		public EncodingHintType EncodingHint {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("EncodingHint"));
				this.ToList().ForEach(item => { item.EncodingHint = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the SortByColumn property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the SortByColumn property of all objects in the collection at once.")]
		public Column SortByColumn {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("SortByColumn"));
				this.ToList().ForEach(item => { item.SortByColumn = value; });
				Handler.UndoManager.EndBatch();
			}
		}

		public override string ToString() {
			return string.Format("({0} {1})", Count, (Count == 1 ? "Column" : "Columns").ToLower());
		}
	}
  
	/// <summary>
///             Represents a user culture. It is a child of a Model object, used for translating strings and formatting values.
///             </summary>
	[TypeConverter(typeof(DynamicPropertyConverter))]
	public sealed partial class Culture: TabularNamedObject
			, IAnnotationObject
			, IExtendedPropertyObject
			, IClonableObject
	{
	    internal new TOM.Culture MetadataObject 
		{ 
			get 
			{ 
				return base.MetadataObject as TOM.Culture; 
		    } 
			set 
			{ 
				base.MetadataObject = value; 
			}
		}

        [Browsable(true),NoMultiselect,Category("Translations and Perspectives"),Description("The collection of Annotations on this object."),Editor(typeof(AnnotationCollectionEditor), typeof(UITypeEditor))]
		public AnnotationCollection Annotations { get; private set; }
		public string GetAnnotation(int index) {
			return MetadataObject.Annotations[index].Value;
		}
		[IntelliSense("Returns true if an annotation with the given name exists. Otherwise false.")]
		public bool HasAnnotation(string name) {
		    return MetadataObject.Annotations.ContainsName(name);
		}
		[IntelliSense("Gets the value of the annotation with the given name. Returns null if no such annotation exists.")]
		public string GetAnnotation(string name) {
		    return HasAnnotation(name) ? MetadataObject.Annotations[name].Value : null;
		}
		public void SetAnnotation(int index, string value, bool undoable = true) {
			var name = MetadataObject.Annotations[index].Name;
			SetAnnotation(name, value, undoable);
		}
		public string GetNewAnnotationName() {
			return MetadataObject.Annotations.GetNewName("New Annotation");
		}
		[IntelliSense("Sets the value of the annotation having the given name. If no such annotation exists, it will be created. If value is set to null, the annotation will be removed.")]
		public void SetAnnotation(string name, string value) {
		    SetAnnotation(name, value, true);
		}
		public void SetAnnotation(string name, string value, bool undoable) {
			if(name == null) name = GetNewAnnotationName();

			if(value == null) {
				// Remove annotation if set to null:
				RemoveAnnotation(name, undoable);
				return;
			}

			if(GetAnnotation(name) == value) return;
			bool undoable2 = true;
			bool cancel = false;
			OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + value, ref undoable2, ref cancel);
			if (cancel) return;

			if(MetadataObject.Annotations.Contains(name)) {
				// Change existing annotation:
				var oldValue = GetAnnotation(name);
				MetadataObject.Annotations[name].Value = value;
				if (undoable) Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, oldValue));
				OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, name + ":" + value);
			} else {
				// Add new annotation:
				MetadataObject.Annotations.Add(new TOM.Annotation{ Name = name, Value = value });
				if (undoable) Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, null));
				OnPropertyChanged(Properties.ANNOTATIONS, null, name + ":" + value);
			}

		}
		[IntelliSense("Remove an annotation by the given name.")]
		public void RemoveAnnotation(string name) {
		    RemoveAnnotation(name, true);
		}
		public void RemoveAnnotation(string name, bool undoable) {
			if(MetadataObject.Annotations.Contains(name)) {
				// Get current value:
				bool undoable2 = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + GetAnnotation(name), ref undoable2, ref cancel);
				if (cancel) return;

				var oldValue = MetadataObject.Annotations[name].Value;
				MetadataObject.Annotations.Remove(name);

				// Undo-handling:
				if (undoable) Handler.UndoManager.Add(new UndoAnnotationAction(this, name, null, oldValue));
				OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, null);
			}
		}
		[IntelliSense("Gets the number of annotations on the current object.")]
		public int GetAnnotationsCount() {
			return MetadataObject.Annotations.Count;
		}
		[IntelliSense("Gets a collection of all annotation names on the current object.")]
		public IEnumerable<string> GetAnnotations() {
			return MetadataObject.Annotations.Select(a => a.Name);
		}

		        [DisplayName("Extended Properties"),NoMultiselect,Category("Translations and Perspectives"),Description("The collection of Extended Properties on this object."),Editor(typeof(ExtendedPropertyCollectionEditor), typeof(UITypeEditor))]
		public ExtendedPropertyCollection ExtendedProperties { get; private set; }

		[IntelliSense("Returns true if an ExtendedProperty with the given name exists. Otherwise false.")]
		public bool HasExtendedProperty(string name) {
		    return MetadataObject.ExtendedProperties.ContainsName(name);
		}
		public ExtendedPropertyType GetExtendedPropertyType(int index) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[index].Type;
		}
		public ExtendedPropertyType GetExtendedPropertyType(string name) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[name].Type;
		}
		public string GetExtendedProperty(int index) {
			var ep = MetadataObject.ExtendedProperties[index];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		[IntelliSense("Gets the value of the ExtendedProperty with the given name. Returns null if no such ExtendedProperty exists.")]
		public string GetExtendedProperty(string name) {
		    if(!HasExtendedProperty(name)) return null;
			var ep = MetadataObject.ExtendedProperties[name];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		public void SetExtendedProperty(int index, string value, ExtendedPropertyType type = ExtendedPropertyType.String) {
			var name = MetadataObject.ExtendedProperties[index].Name;
			SetExtendedProperty(name, value, type);
		}
		public string GetNewExtendedPropertyName() {
			return MetadataObject.ExtendedProperties.GetNewName("New ExtendedProperty");
		}
		[IntelliSense("Sets the value of the ExtendedProperty having the given name. If no such ExtendedProperty exists, it will be created. If value is set to null, the ExtendedProperty will be removed.")]
		public void SetExtendedProperty(string name, string value, ExtendedPropertyType type = ExtendedPropertyType.String) {
			if(name == null) name = GetNewExtendedPropertyName();

			if(value == null) {
				// Remove ExtendedProperty if set to null:
				RemoveExtendedProperty(name);
				return;
			}

			if(GetExtendedProperty(name) == value) return;
			bool undoable = true;
			bool cancel = false;
			OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + value, ref undoable, ref cancel);
			if (cancel) return;

			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Change existing ExtendedProperty:
				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				var ep = MetadataObject.ExtendedProperties[name];
				if (ep is TOM.JsonExtendedProperty)
					(ep as TOM.JsonExtendedProperty).Value = value;
				else 
					(ep as TOM.StringExtendedProperty).Value = value;
					
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, name + ":" + value);
			} else {
				// Add new ExtendedProperty:
				if (type == ExtendedPropertyType.Json)
					MetadataObject.ExtendedProperties.Add(new TOM.JsonExtendedProperty{ Name = name, Value = value });
				else
					MetadataObject.ExtendedProperties.Add(new TOM.StringExtendedProperty{ Name = name, Value = value });

				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, null, type));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, null, name + ":" + value);
			}

		}
		[IntelliSense("Remove an ExtendedProperty by the given name.")]
		public void RemoveExtendedProperty(string name) {
			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Get current value:
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + GetExtendedProperty(name), ref undoable, ref cancel);
				if (cancel) return;

				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				MetadataObject.ExtendedProperties.Remove(name);

				// Undo-handling:
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, null, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, null);
			}
		}
		[IntelliSense("Gets the number of ExtendedProperties on the current object.")]
		public int GetExtendedPropertyCount() {
			return MetadataObject.ExtendedProperties.Count;
		}
		[IntelliSense("Gets a collection of all ExtendedProperty names on the current object.")]
		public IEnumerable<string> GetExtendedProperties() {
			return MetadataObject.ExtendedProperties.Select(a => a.Name);
		}

		
		internal static Culture CreateFromMetadata(Model parent, TOM.Culture metadataObject) {
			var obj = new Culture(metadataObject);
			parent.Cultures.Add(obj);
			
			obj.Init();

			return obj;
		}


		/// <summary>
		/// Creates a new Culture and adds it to the parent Model.
		/// Also creates the underlying metadataobject and adds it to the TOM tree.
		/// </summary>
		public static Culture CreateNew(Model parent, string name = null)
		{
			if(TabularModelHandler.Singleton.UsePowerBIGovernance && !PowerBI.PowerBIGovernance.AllowCreate(typeof(Culture))) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(Culture).GetTypeName()));
			}

			var metadataObject = new TOM.Culture();
			metadataObject.Name = parent.Cultures.GetNewName(string.IsNullOrWhiteSpace(name) ? "New " + typeof(Culture).GetTypeName() : name);

			var obj = new Culture(metadataObject);

			parent.Cultures.Add(obj);
			
			obj.Init();

			return obj;
		}

		/// <summary>
		/// Creates a new Culture and adds it to the current Model.
		/// Also creates the underlying metadataobject and adds it to the TOM tree.
		/// </summary>		
		public static Culture CreateNew(string name = null)
		{
			return CreateNew(TabularModelHandler.Singleton.Model, name);
		}


		/// <summary>
		/// Creates an exact copy of this Culture object.
		/// </summary>
		public Culture Clone(string newName = null) {
			if(TabularModelHandler.Singleton.UsePowerBIGovernance && !PowerBI.PowerBIGovernance.AllowCreate(typeof(Culture))) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(Culture).GetTypeName()));
			}

		    Handler.BeginUpdate("Clone Culture");

			// Create a clone of the underlying metadataobject:
			var tom = MetadataObject.Clone() as TOM.Culture;


			// Assign a new, unique name:
			tom.Name = Parent.Cultures.GetNewName(string.IsNullOrEmpty(newName) ? tom.Name + " copy" : newName);
				
			// Create the TOM Wrapper object, representing the metadataobject
			Culture obj = CreateFromMetadata(Parent, tom);

            Handler.EndUpdate();

            return obj;
		}

		TabularNamedObject IClonableObject.Clone(string newName, bool includeTranslations, TabularNamedObject newParent) 
		{
			if (newParent != null) throw new ArgumentException("This object can not be cloned to another parent. Argument newParent should be left as null.", "newParent");
			return Clone(newName);
		}

	
        internal override void RenewMetadataObject()
        {
            Handler.WrapperLookup.Remove(MetadataObject);
            MetadataObject = MetadataObject.Clone() as TOM.Culture;
            Handler.WrapperLookup.Add(MetadataObject, this);
        }

		public Model Parent { 
			get {
				return Handler.WrapperLookup[MetadataObject.Parent] as Model;
			}
		}



		/// <summary>
		/// CTOR - only called from static factory methods on the class
		/// </summary>
		Culture(TOM.Culture metadataObject) : base(metadataObject)
		{
			
			// Create indexer for annotations:
			Annotations = new AnnotationCollection(this);
			
			// Create indexer for extended properties:
			ExtendedProperties = new ExtendedPropertyCollection(this);
		}



		internal override void Undelete(ITabularObjectCollection collection) {
			base.Undelete(collection);
			Reinit();
			ReapplyReferences();
		}

		public override bool Browsable(string propertyName) {
			switch (propertyName) {
 
				case Properties.EXTENDEDPROPERTIES:
					return Handler.CompatibilityLevel >= 1400;
				case Properties.PARENT:
					return false;
				
				default:
					return base.Browsable(propertyName);
			}
		}

    }


	/// <summary>
	/// Collection class for Culture. Provides convenient properties for setting a property on multiple objects at once.
	/// </summary>
	public sealed partial class CultureCollection: TabularObjectCollection<Culture>
	{
		internal Model Model { get { return Parent as Model; } }
		TOM.CultureCollection TOM_Collection;
		internal CultureCollection(string collectionName, TOM.CultureCollection metadataObjectCollection, Model parent) : base(collectionName, parent)
		{
			TOM_Collection = metadataObjectCollection;
		}
		internal override Type GetItemType() { return typeof(Culture); }
        protected override void TOM_Add(TOM.MetadataObject obj) { TOM_Collection.Add(obj as TOM.Culture); }
        protected override bool TOM_Contains(TOM.MetadataObject obj) { return TOM_Collection.Contains(obj as TOM.Culture); }
        protected override void TOM_Remove(TOM.MetadataObject obj) { TOM_Collection.Remove(obj as TOM.Culture); }
        protected override void TOM_Clear() { TOM_Collection.Clear(); }
        protected override bool TOM_ContainsName(string name) { return TOM_Collection.ContainsName(name); }
        protected override TOM.MetadataObject TOM_Get(int index) { return TOM_Collection[index]; }
        protected override TOM.MetadataObject TOM_Get(string name) { return TOM_Collection[name]; }
        internal override string GetNewName(string prefix = null) { return string.IsNullOrEmpty(prefix) ? TOM_Collection.GetNewName() : TOM_Collection.GetNewName(prefix); }
        public override int IndexOf(TOM.MetadataObject obj) { return TOM_Collection.IndexOf(obj as TOM.Culture); }
        public override int Count { get { return TOM_Collection.Count; } }
        public override IEnumerator<Culture> GetEnumerator() { return TOM_Collection.Select(h => Handler.WrapperLookup[h]).OfType<Culture>().GetEnumerator(); }
		internal override void Reinit() {
			var ixOffset = 0;
			for(int i = 0; i < Count; i++) {
				var item = this[i];
				Handler.WrapperLookup.Remove(item.MetadataObject);
				item.MetadataObject = Model.MetadataObject.Cultures[i + ixOffset] as TOM.Culture;
				Handler.WrapperLookup.Add(item.MetadataObject, item);
				item.Collection = this;
			}
			TOM_Collection = Model.MetadataObject.Cultures;
			foreach(var item in this) item.Reinit();
		}

		internal override void ReapplyReferences() {
			foreach(var item in this) item.ReapplyReferences();
		}

		/// <summary>
		/// Calling this method will populate the CultureCollection with objects based on the MetadataObjects in the corresponding MetadataObjectCollection.
		/// </summary>
		internal override void CreateChildrenFromMetadata()
		{
			// Construct child objects (they are automatically added to the Handler's WrapperLookup dictionary):
			foreach(var obj in TOM_Collection) {
				if(obj is TOM.Culture) Culture.CreateFromMetadata(Model, obj as TOM.Culture);
		    }
		}


		public override string ToString() {
			return string.Format("({0} {1})", Count, (Count == 1 ? "Culture" : "Cultures").ToLower());
		}
	}
  
	/// <summary>
///             Represents a column in a Table that gets data from an external data source.
///             </summary>
	[TypeConverter(typeof(DynamicPropertyConverter))]
	public sealed partial class DataColumn: Column
			, IClonableObject
	{
	    internal new TOM.DataColumn MetadataObject 
		{ 
			get 
			{ 
				return base.MetadataObject as TOM.DataColumn; 
		    } 
			set 
			{ 
				base.MetadataObject = value; 
			}
		}

/// <summary>
///             Name of the column from which data will be retrieved. The name must match a column returned during processing or refresh, where the partition source is a query (as the Query of a CalculatedPartitionSource).
///             </summary>
		[DisplayName("Source Column")]
		[Category("Options"),Description(@"Name of the column from which data will be retrieved. The name must match a column returned during processing or refresh, where the partition source is a query (as the Query of a CalculatedPartitionSource)."),IntelliSense(@"Name of the column from which data will be retrieved. The name must match a column returned during processing or refresh, where the partition source is a query (as the Query of a CalculatedPartitionSource).")]
		public string SourceColumn {
			get {
			    return MetadataObject.SourceColumn;
			}
			set {
				
				var oldValue = SourceColumn;
				var newValue = value.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.SOURCECOLUMN, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.SourceColumn = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.SOURCECOLUMN, oldValue, newValue));
				OnPropertyChanged(Properties.SOURCECOLUMN, oldValue, newValue);
			}
		}
		private bool ShouldSerializeSourceColumn() { return false; }

		internal static DataColumn CreateFromMetadata(Table parent, TOM.DataColumn metadataObject) {
			var obj = new DataColumn(metadataObject);
			parent.Columns.Add(obj);
			
			obj.Init();

			return obj;
		}


		/// <summary>
		/// Creates a new DataColumn and adds it to the parent Table.
		/// Also creates the underlying metadataobject and adds it to the TOM tree.
		/// </summary>
		public static DataColumn CreateNew(Table parent, string name = null)
		{
			if(TabularModelHandler.Singleton.UsePowerBIGovernance && !PowerBI.PowerBIGovernance.AllowCreate(typeof(DataColumn))) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(DataColumn).GetTypeName()));
			}

			var metadataObject = new TOM.DataColumn();
			metadataObject.Name = parent.Columns.GetNewName(string.IsNullOrWhiteSpace(name) ? "New " + typeof(DataColumn).GetTypeName() : name);

			var obj = new DataColumn(metadataObject);

			parent.Columns.Add(obj);
			
			obj.Init();

			return obj;
		}


		/// <summary>
		/// Creates an exact copy of this DataColumn object.
		/// </summary>
		public DataColumn Clone(string newName = null, bool includeTranslations = true, Table newParent = null) {
			if(TabularModelHandler.Singleton.UsePowerBIGovernance && !PowerBI.PowerBIGovernance.AllowCreate(typeof(DataColumn))) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(DataColumn).GetTypeName()));
			}

		    Handler.BeginUpdate("Clone DataColumn");

			// Create a clone of the underlying metadataobject:
			var tom = MetadataObject.Clone() as TOM.DataColumn;


			// Assign a new, unique name:
			tom.Name = Parent.Columns.GetNewName(string.IsNullOrEmpty(newName) ? tom.Name + " copy" : newName);
				
			// Create the TOM Wrapper object, representing the metadataobject
			DataColumn obj = CreateFromMetadata(newParent ?? Parent, tom);

			// Copy translations, if applicable:
			if(includeTranslations) {
				obj.CopyTranslationsFrom(this);
			}
				
			// Copy perspectives:
			obj.InPerspective.CopyFrom(InPerspective);

            Handler.EndUpdate();

            return obj;
		}

		TabularNamedObject IClonableObject.Clone(string newName, bool includeTranslations, TabularNamedObject newParent) 
		{
			return Clone(newName);
		}

	
        internal override void RenewMetadataObject()
        {
            Handler.WrapperLookup.Remove(MetadataObject);
            MetadataObject = MetadataObject.Clone() as TOM.DataColumn;
            Handler.WrapperLookup.Add(MetadataObject, this);
        }

		public Table Parent { 
			get {
				return Handler.WrapperLookup[MetadataObject.Parent] as Table;
			}
		}



		/// <summary>
		/// CTOR - only called from static factory methods on the class
		/// </summary>
		DataColumn(TOM.DataColumn metadataObject) : base(metadataObject)
		{
		}



		internal override void Undelete(ITabularObjectCollection collection) {
			base.Undelete(collection);
			Reinit();
			ReapplyReferences();
		}

		public override bool Browsable(string propertyName) {
			switch (propertyName) {
				case Properties.PARENT:
					return false;
				
				default:
					return base.Browsable(propertyName);
			}
		}

    }

  
	/// <summary>
///             Defines an open connection to an external data source for import, refresh, or DirectQuery operations on a Tabular <see cref="T:TabularEditor.TOMWrapper.Model" />.
///             </summary>
	[TypeConverter(typeof(DynamicPropertyConverter))]
	public abstract partial class DataSource: TabularNamedObject
			, IDescriptionObject
			, IAnnotationObject
			, IExtendedPropertyObject
	{
	    internal new TOM.DataSource MetadataObject 
		{ 
			get 
			{ 
				return base.MetadataObject as TOM.DataSource; 
		    } 
			set 
			{ 
				base.MetadataObject = value; 
			}
		}

        [Browsable(true),NoMultiselect,Category("Translations and Perspectives"),Description("The collection of Annotations on this object."),Editor(typeof(AnnotationCollectionEditor), typeof(UITypeEditor))]
		public AnnotationCollection Annotations { get; private set; }
		public string GetAnnotation(int index) {
			return MetadataObject.Annotations[index].Value;
		}
		[IntelliSense("Returns true if an annotation with the given name exists. Otherwise false.")]
		public bool HasAnnotation(string name) {
		    return MetadataObject.Annotations.ContainsName(name);
		}
		[IntelliSense("Gets the value of the annotation with the given name. Returns null if no such annotation exists.")]
		public string GetAnnotation(string name) {
		    return HasAnnotation(name) ? MetadataObject.Annotations[name].Value : null;
		}
		public void SetAnnotation(int index, string value, bool undoable = true) {
			var name = MetadataObject.Annotations[index].Name;
			SetAnnotation(name, value, undoable);
		}
		public string GetNewAnnotationName() {
			return MetadataObject.Annotations.GetNewName("New Annotation");
		}
		[IntelliSense("Sets the value of the annotation having the given name. If no such annotation exists, it will be created. If value is set to null, the annotation will be removed.")]
		public void SetAnnotation(string name, string value) {
		    SetAnnotation(name, value, true);
		}
		public void SetAnnotation(string name, string value, bool undoable) {
			if(name == null) name = GetNewAnnotationName();

			if(value == null) {
				// Remove annotation if set to null:
				RemoveAnnotation(name, undoable);
				return;
			}

			if(GetAnnotation(name) == value) return;
			bool undoable2 = true;
			bool cancel = false;
			OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + value, ref undoable2, ref cancel);
			if (cancel) return;

			if(MetadataObject.Annotations.Contains(name)) {
				// Change existing annotation:
				var oldValue = GetAnnotation(name);
				MetadataObject.Annotations[name].Value = value;
				if (undoable) Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, oldValue));
				OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, name + ":" + value);
			} else {
				// Add new annotation:
				MetadataObject.Annotations.Add(new TOM.Annotation{ Name = name, Value = value });
				if (undoable) Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, null));
				OnPropertyChanged(Properties.ANNOTATIONS, null, name + ":" + value);
			}

		}
		[IntelliSense("Remove an annotation by the given name.")]
		public void RemoveAnnotation(string name) {
		    RemoveAnnotation(name, true);
		}
		public void RemoveAnnotation(string name, bool undoable) {
			if(MetadataObject.Annotations.Contains(name)) {
				// Get current value:
				bool undoable2 = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + GetAnnotation(name), ref undoable2, ref cancel);
				if (cancel) return;

				var oldValue = MetadataObject.Annotations[name].Value;
				MetadataObject.Annotations.Remove(name);

				// Undo-handling:
				if (undoable) Handler.UndoManager.Add(new UndoAnnotationAction(this, name, null, oldValue));
				OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, null);
			}
		}
		[IntelliSense("Gets the number of annotations on the current object.")]
		public int GetAnnotationsCount() {
			return MetadataObject.Annotations.Count;
		}
		[IntelliSense("Gets a collection of all annotation names on the current object.")]
		public IEnumerable<string> GetAnnotations() {
			return MetadataObject.Annotations.Select(a => a.Name);
		}

		        [DisplayName("Extended Properties"),NoMultiselect,Category("Translations and Perspectives"),Description("The collection of Extended Properties on this object."),Editor(typeof(ExtendedPropertyCollectionEditor), typeof(UITypeEditor))]
		public ExtendedPropertyCollection ExtendedProperties { get; private set; }

		[IntelliSense("Returns true if an ExtendedProperty with the given name exists. Otherwise false.")]
		public bool HasExtendedProperty(string name) {
		    return MetadataObject.ExtendedProperties.ContainsName(name);
		}
		public ExtendedPropertyType GetExtendedPropertyType(int index) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[index].Type;
		}
		public ExtendedPropertyType GetExtendedPropertyType(string name) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[name].Type;
		}
		public string GetExtendedProperty(int index) {
			var ep = MetadataObject.ExtendedProperties[index];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		[IntelliSense("Gets the value of the ExtendedProperty with the given name. Returns null if no such ExtendedProperty exists.")]
		public string GetExtendedProperty(string name) {
		    if(!HasExtendedProperty(name)) return null;
			var ep = MetadataObject.ExtendedProperties[name];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		public void SetExtendedProperty(int index, string value, ExtendedPropertyType type = ExtendedPropertyType.String) {
			var name = MetadataObject.ExtendedProperties[index].Name;
			SetExtendedProperty(name, value, type);
		}
		public string GetNewExtendedPropertyName() {
			return MetadataObject.ExtendedProperties.GetNewName("New ExtendedProperty");
		}
		[IntelliSense("Sets the value of the ExtendedProperty having the given name. If no such ExtendedProperty exists, it will be created. If value is set to null, the ExtendedProperty will be removed.")]
		public void SetExtendedProperty(string name, string value, ExtendedPropertyType type = ExtendedPropertyType.String) {
			if(name == null) name = GetNewExtendedPropertyName();

			if(value == null) {
				// Remove ExtendedProperty if set to null:
				RemoveExtendedProperty(name);
				return;
			}

			if(GetExtendedProperty(name) == value) return;
			bool undoable = true;
			bool cancel = false;
			OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + value, ref undoable, ref cancel);
			if (cancel) return;

			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Change existing ExtendedProperty:
				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				var ep = MetadataObject.ExtendedProperties[name];
				if (ep is TOM.JsonExtendedProperty)
					(ep as TOM.JsonExtendedProperty).Value = value;
				else 
					(ep as TOM.StringExtendedProperty).Value = value;
					
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, name + ":" + value);
			} else {
				// Add new ExtendedProperty:
				if (type == ExtendedPropertyType.Json)
					MetadataObject.ExtendedProperties.Add(new TOM.JsonExtendedProperty{ Name = name, Value = value });
				else
					MetadataObject.ExtendedProperties.Add(new TOM.StringExtendedProperty{ Name = name, Value = value });

				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, null, type));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, null, name + ":" + value);
			}

		}
		[IntelliSense("Remove an ExtendedProperty by the given name.")]
		public void RemoveExtendedProperty(string name) {
			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Get current value:
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + GetExtendedProperty(name), ref undoable, ref cancel);
				if (cancel) return;

				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				MetadataObject.ExtendedProperties.Remove(name);

				// Undo-handling:
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, null, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, null);
			}
		}
		[IntelliSense("Gets the number of ExtendedProperties on the current object.")]
		public int GetExtendedPropertyCount() {
			return MetadataObject.ExtendedProperties.Count;
		}
		[IntelliSense("Gets a collection of all ExtendedProperty names on the current object.")]
		public IEnumerable<string> GetExtendedProperties() {
			return MetadataObject.ExtendedProperties.Select(a => a.Name);
		}

		/// <summary>
///             The description of the data source, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio.
///             </summary>
		[DisplayName("Description")]
		[Category("Basic"),Description(@"The description of the data source, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio."),IntelliSense(@"The description of the data source, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio.")][Editor(typeof(System.ComponentModel.Design.MultilineStringEditor), typeof(System.Drawing.Design.UITypeEditor))]
		public string Description {
			get {
			    return MetadataObject.Description;
			}
			set {
				
				var oldValue = Description;
				var newValue = value.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DESCRIPTION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.Description = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DESCRIPTION, oldValue, newValue));
				OnPropertyChanged(Properties.DESCRIPTION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeDescription() { return false; }
/// <summary>
///             The type of DataSource. At present, the only possible value is Provider, which refers to a data source that accepts a connection string.
///             </summary>
		[DisplayName("Type")]
		[Category("Other"),Description(@"The type of DataSource. At present, the only possible value is Provider, which refers to a data source that accepts a connection string."),IntelliSense(@"The type of DataSource. At present, the only possible value is Provider, which refers to a data source that accepts a connection string.")]
		public DataSourceType Type {
			get {
			    return (DataSourceType)MetadataObject.Type;
			}
			
		}
		private bool ShouldSerializeType() { return false; }
/// <summary>
///             The maximum number of connections to be opened concurrently to the data source.
///             </summary>
		[DisplayName("Max Connections")]
		[Category("Other"),Description(@"The maximum number of connections to be opened concurrently to the data source."),IntelliSense(@"The maximum number of connections to be opened concurrently to the data source.")]
		public int MaxConnections {
			get {
			    return MetadataObject.MaxConnections;
			}
			set {
				
				var oldValue = MaxConnections;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.MAXCONNECTIONS, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.MaxConnections = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.MAXCONNECTIONS, oldValue, newValue));
				OnPropertyChanged(Properties.MAXCONNECTIONS, oldValue, newValue);
			}
		}
		private bool ShouldSerializeMaxConnections() { return false; }

	
        internal override void RenewMetadataObject()
        {
            Handler.WrapperLookup.Remove(MetadataObject);
            MetadataObject = MetadataObject.Clone() as TOM.DataSource;
            Handler.WrapperLookup.Add(MetadataObject, this);
        }

		public Model Parent { 
			get {
				return Handler.WrapperLookup[MetadataObject.Parent] as Model;
			}
		}



		/// <summary>
		/// CTOR - only called from static factory methods on the class
		/// </summary>
		protected DataSource(TOM.DataSource metadataObject) : base(metadataObject)
		{
			
			// Create indexer for annotations:
			Annotations = new AnnotationCollection(this);
			
			// Create indexer for extended properties:
			ExtendedProperties = new ExtendedPropertyCollection(this);
		}



		internal override void Undelete(ITabularObjectCollection collection) {
			base.Undelete(collection);
			Reinit();
			ReapplyReferences();
		}

		public override bool Browsable(string propertyName) {
			switch (propertyName) {
 
				case Properties.EXTENDEDPROPERTIES:
					return Handler.CompatibilityLevel >= 1400;
				case Properties.PARENT:
					return false;
				
				default:
					return base.Browsable(propertyName);
			}
		}

    }


	/// <summary>
	/// Collection class for DataSource. Provides convenient properties for setting a property on multiple objects at once.
	/// </summary>
	public sealed partial class DataSourceCollection: TabularObjectCollection<DataSource>
	{
		internal Model Model { get { return Parent as Model; } }
		TOM.DataSourceCollection TOM_Collection;
		internal DataSourceCollection(string collectionName, TOM.DataSourceCollection metadataObjectCollection, Model parent) : base(collectionName, parent)
		{
			TOM_Collection = metadataObjectCollection;
		}
		internal override Type GetItemType() { return typeof(DataSource); }
        protected override void TOM_Add(TOM.MetadataObject obj) { TOM_Collection.Add(obj as TOM.DataSource); }
        protected override bool TOM_Contains(TOM.MetadataObject obj) { return TOM_Collection.Contains(obj as TOM.DataSource); }
        protected override void TOM_Remove(TOM.MetadataObject obj) { TOM_Collection.Remove(obj as TOM.DataSource); }
        protected override void TOM_Clear() { TOM_Collection.Clear(); }
        protected override bool TOM_ContainsName(string name) { return TOM_Collection.ContainsName(name); }
        protected override TOM.MetadataObject TOM_Get(int index) { return TOM_Collection[index]; }
        protected override TOM.MetadataObject TOM_Get(string name) { return TOM_Collection[name]; }
        internal override string GetNewName(string prefix = null) { return string.IsNullOrEmpty(prefix) ? TOM_Collection.GetNewName() : TOM_Collection.GetNewName(prefix); }
        public override int IndexOf(TOM.MetadataObject obj) { return TOM_Collection.IndexOf(obj as TOM.DataSource); }
        public override int Count { get { return TOM_Collection.Count; } }
        public override IEnumerator<DataSource> GetEnumerator() { return TOM_Collection.Select(h => Handler.WrapperLookup[h]).OfType<DataSource>().GetEnumerator(); }
		internal override void Reinit() {
			var ixOffset = 0;
			for(int i = 0; i < Count; i++) {
				var item = this[i];
				Handler.WrapperLookup.Remove(item.MetadataObject);
				item.MetadataObject = Model.MetadataObject.DataSources[i + ixOffset] as TOM.DataSource;
				Handler.WrapperLookup.Add(item.MetadataObject, item);
				item.Collection = this;
			}
			TOM_Collection = Model.MetadataObject.DataSources;
			foreach(var item in this) item.Reinit();
		}

		internal override void ReapplyReferences() {
			foreach(var item in this) item.ReapplyReferences();
		}

		/// <summary>
		/// Calling this method will populate the DataSourceCollection with objects based on the MetadataObjects in the corresponding MetadataObjectCollection.
		/// </summary>
		internal override void CreateChildrenFromMetadata()
		{
			// Construct child objects (they are automatically added to the Handler's WrapperLookup dictionary):
			foreach(var obj in TOM_Collection) {
				if(obj is TOM.ProviderDataSource) ProviderDataSource.CreateFromMetadata(Model, obj as TOM.ProviderDataSource);
				if(obj is TOM.StructuredDataSource) StructuredDataSource.CreateFromMetadata(Model, obj as TOM.StructuredDataSource);
		    }
		}

		/// <summary>
		/// Sets the Description property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the Description property of all objects in the collection at once.")]
		public string Description {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("Description"));
				this.ToList().ForEach(item => { item.Description = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the MaxConnections property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the MaxConnections property of all objects in the collection at once.")]
		public int MaxConnections {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("MaxConnections"));
				this.ToList().ForEach(item => { item.MaxConnections = value; });
				Handler.UndoManager.EndBatch();
			}
		}

		public override string ToString() {
			return string.Format("({0} {1})", Count, (Count == 1 ? "DataSource" : "DataSources").ToLower());
		}
	}
  
	/// <summary>
///             For internal use only.
///             </summary>
	[TypeConverter(typeof(DynamicPropertyConverter))]
	public sealed partial class ExternalModelRoleMember: ModelRoleMember
			, IClonableObject
	{
	    internal new TOM.ExternalModelRoleMember MetadataObject 
		{ 
			get 
			{ 
				return base.MetadataObject as TOM.ExternalModelRoleMember; 
		    } 
			set 
			{ 
				base.MetadataObject = value; 
			}
		}

/// <summary>
///             A string that defines the identity provider used for authentication.
///             </summary>
		[DisplayName("Identity Provider")]
		[Category("Other"),Description(@"A string that defines the identity provider used for authentication."),IntelliSense(@"A string that defines the identity provider used for authentication.")]
		public string IdentityProvider {
			get {
			    return MetadataObject.IdentityProvider;
			}
			set {
				
				var oldValue = IdentityProvider;
				var newValue = value.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.IDENTITYPROVIDER, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.IdentityProvider = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.IDENTITYPROVIDER, oldValue, newValue));
				OnPropertyChanged(Properties.IDENTITYPROVIDER, oldValue, newValue);
			}
		}
		private bool ShouldSerializeIdentityProvider() { return false; }
/// <summary>
///             Indicates whether the particular member of a security role is an individual user or a group of users, or automatically detected. Possible values are as follows. Auto (1): Member is automatically detected. User (2): Member is an individual user. Group (3): Member is a security group.
///             </summary>
		[DisplayName("Member Type")]
		[Category("Other"),Description(@"Indicates whether the particular member of a security role is an individual user or a group of users, or automatically detected. Possible values are as follows. Auto (1): Member is automatically detected. User (2): Member is an individual user. Group (3): Member is a security group."),IntelliSense(@"Indicates whether the particular member of a security role is an individual user or a group of users, or automatically detected. Possible values are as follows. Auto (1): Member is automatically detected. User (2): Member is an individual user. Group (3): Member is a security group.")]
		public RoleMemberType MemberType {
			get {
			    return (RoleMemberType)MetadataObject.MemberType;
			}
			set {
				
				var oldValue = MemberType;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.MEMBERTYPE, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.MemberType = (TOM.RoleMemberType)newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.MEMBERTYPE, oldValue, newValue));
				OnPropertyChanged(Properties.MEMBERTYPE, oldValue, newValue);
			}
		}
		private bool ShouldSerializeMemberType() { return false; }

		internal static ExternalModelRoleMember CreateFromMetadata(ModelRole parent, TOM.ExternalModelRoleMember metadataObject) {
			var obj = new ExternalModelRoleMember(metadataObject);
			parent.Members.Add(obj);
			
			obj.Init();

			return obj;
		}


		/// <summary>
		/// Creates a new ExternalModelRoleMember and adds it to the parent ModelRole.
		/// Also creates the underlying metadataobject and adds it to the TOM tree.
		/// </summary>
		public static ExternalModelRoleMember CreateNew(ModelRole parent, string name = null)
		{
			if(TabularModelHandler.Singleton.UsePowerBIGovernance && !PowerBI.PowerBIGovernance.AllowCreate(typeof(ExternalModelRoleMember))) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(ExternalModelRoleMember).GetTypeName()));
			}

			var metadataObject = new TOM.ExternalModelRoleMember();
			metadataObject.Name = parent.Members.GetNewName(string.IsNullOrWhiteSpace(name) ? "New " + typeof(ExternalModelRoleMember).GetTypeName() : name);

			var obj = new ExternalModelRoleMember(metadataObject);

			parent.Members.Add(obj);
			
			obj.Init();

			return obj;
		}


		/// <summary>
		/// Creates an exact copy of this ExternalModelRoleMember object.
		/// </summary>
		public ExternalModelRoleMember Clone(string newName = null, ModelRole newParent = null) {
			if(TabularModelHandler.Singleton.UsePowerBIGovernance && !PowerBI.PowerBIGovernance.AllowCreate(typeof(ExternalModelRoleMember))) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(ExternalModelRoleMember).GetTypeName()));
			}

		    Handler.BeginUpdate("Clone ExternalModelRoleMember");

			// Create a clone of the underlying metadataobject:
			var tom = MetadataObject.Clone() as TOM.ExternalModelRoleMember;


			// Assign a new, unique name:
			tom.Name = Parent.Members.GetNewName(string.IsNullOrEmpty(newName) ? tom.Name + " copy" : newName);
				
			// Create the TOM Wrapper object, representing the metadataobject
			ExternalModelRoleMember obj = CreateFromMetadata(newParent ?? Parent, tom);

            Handler.EndUpdate();

            return obj;
		}

		TabularNamedObject IClonableObject.Clone(string newName, bool includeTranslations, TabularNamedObject newParent) 
		{
			return Clone(newName);
		}

	
        internal override void RenewMetadataObject()
        {
            Handler.WrapperLookup.Remove(MetadataObject);
            MetadataObject = MetadataObject.Clone() as TOM.ExternalModelRoleMember;
            Handler.WrapperLookup.Add(MetadataObject, this);
        }

		public new ModelRole Parent { 
			get {
				return Handler.WrapperLookup[MetadataObject.Parent] as ModelRole;
			}
		}



		/// <summary>
		/// CTOR - only called from static factory methods on the class
		/// </summary>
		ExternalModelRoleMember(TOM.ExternalModelRoleMember metadataObject) : base(metadataObject)
		{
		}



		internal override void Undelete(ITabularObjectCollection collection) {
			base.Undelete(collection);
			Reinit();
			ReapplyReferences();
		}

		public override bool Browsable(string propertyName) {
			switch (propertyName) {
				case Properties.PARENT:
					return false;
				
				default:
					return base.Browsable(propertyName);
			}
		}

    }

  
	/// <summary>
///             Represents a collection of levels that provide a logical hierarchical drilldown path for client applications. It is a child of a Table object.
///             </summary>
	[TypeConverter(typeof(DynamicPropertyConverter))]
	public sealed partial class Hierarchy: TabularNamedObject
			, IFolderObject
			, IHideableObject
			, ITabularTableObject
			, IDescriptionObject
			, IAnnotationObject
			, IExtendedPropertyObject
			, ITabularPerspectiveObject
			, ITranslatableObject
			, IClonableObject
	{
	    internal new TOM.Hierarchy MetadataObject 
		{ 
			get 
			{ 
				return base.MetadataObject as TOM.Hierarchy; 
		    } 
			set 
			{ 
				base.MetadataObject = value; 
			}
		}

        [Browsable(true),NoMultiselect,Category("Translations and Perspectives"),Description("The collection of Annotations on this object."),Editor(typeof(AnnotationCollectionEditor), typeof(UITypeEditor))]
		public AnnotationCollection Annotations { get; private set; }
		public string GetAnnotation(int index) {
			return MetadataObject.Annotations[index].Value;
		}
		[IntelliSense("Returns true if an annotation with the given name exists. Otherwise false.")]
		public bool HasAnnotation(string name) {
		    return MetadataObject.Annotations.ContainsName(name);
		}
		[IntelliSense("Gets the value of the annotation with the given name. Returns null if no such annotation exists.")]
		public string GetAnnotation(string name) {
		    return HasAnnotation(name) ? MetadataObject.Annotations[name].Value : null;
		}
		public void SetAnnotation(int index, string value, bool undoable = true) {
			var name = MetadataObject.Annotations[index].Name;
			SetAnnotation(name, value, undoable);
		}
		public string GetNewAnnotationName() {
			return MetadataObject.Annotations.GetNewName("New Annotation");
		}
		[IntelliSense("Sets the value of the annotation having the given name. If no such annotation exists, it will be created. If value is set to null, the annotation will be removed.")]
		public void SetAnnotation(string name, string value) {
		    SetAnnotation(name, value, true);
		}
		public void SetAnnotation(string name, string value, bool undoable) {
			if(name == null) name = GetNewAnnotationName();

			if(value == null) {
				// Remove annotation if set to null:
				RemoveAnnotation(name, undoable);
				return;
			}

			if(GetAnnotation(name) == value) return;
			bool undoable2 = true;
			bool cancel = false;
			OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + value, ref undoable2, ref cancel);
			if (cancel) return;

			if(MetadataObject.Annotations.Contains(name)) {
				// Change existing annotation:
				var oldValue = GetAnnotation(name);
				MetadataObject.Annotations[name].Value = value;
				if (undoable) Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, oldValue));
				OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, name + ":" + value);
			} else {
				// Add new annotation:
				MetadataObject.Annotations.Add(new TOM.Annotation{ Name = name, Value = value });
				if (undoable) Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, null));
				OnPropertyChanged(Properties.ANNOTATIONS, null, name + ":" + value);
			}

		}
		[IntelliSense("Remove an annotation by the given name.")]
		public void RemoveAnnotation(string name) {
		    RemoveAnnotation(name, true);
		}
		public void RemoveAnnotation(string name, bool undoable) {
			if(MetadataObject.Annotations.Contains(name)) {
				// Get current value:
				bool undoable2 = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + GetAnnotation(name), ref undoable2, ref cancel);
				if (cancel) return;

				var oldValue = MetadataObject.Annotations[name].Value;
				MetadataObject.Annotations.Remove(name);

				// Undo-handling:
				if (undoable) Handler.UndoManager.Add(new UndoAnnotationAction(this, name, null, oldValue));
				OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, null);
			}
		}
		[IntelliSense("Gets the number of annotations on the current object.")]
		public int GetAnnotationsCount() {
			return MetadataObject.Annotations.Count;
		}
		[IntelliSense("Gets a collection of all annotation names on the current object.")]
		public IEnumerable<string> GetAnnotations() {
			return MetadataObject.Annotations.Select(a => a.Name);
		}

		        [DisplayName("Extended Properties"),NoMultiselect,Category("Translations and Perspectives"),Description("The collection of Extended Properties on this object."),Editor(typeof(ExtendedPropertyCollectionEditor), typeof(UITypeEditor))]
		public ExtendedPropertyCollection ExtendedProperties { get; private set; }

		[IntelliSense("Returns true if an ExtendedProperty with the given name exists. Otherwise false.")]
		public bool HasExtendedProperty(string name) {
		    return MetadataObject.ExtendedProperties.ContainsName(name);
		}
		public ExtendedPropertyType GetExtendedPropertyType(int index) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[index].Type;
		}
		public ExtendedPropertyType GetExtendedPropertyType(string name) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[name].Type;
		}
		public string GetExtendedProperty(int index) {
			var ep = MetadataObject.ExtendedProperties[index];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		[IntelliSense("Gets the value of the ExtendedProperty with the given name. Returns null if no such ExtendedProperty exists.")]
		public string GetExtendedProperty(string name) {
		    if(!HasExtendedProperty(name)) return null;
			var ep = MetadataObject.ExtendedProperties[name];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		public void SetExtendedProperty(int index, string value, ExtendedPropertyType type = ExtendedPropertyType.String) {
			var name = MetadataObject.ExtendedProperties[index].Name;
			SetExtendedProperty(name, value, type);
		}
		public string GetNewExtendedPropertyName() {
			return MetadataObject.ExtendedProperties.GetNewName("New ExtendedProperty");
		}
		[IntelliSense("Sets the value of the ExtendedProperty having the given name. If no such ExtendedProperty exists, it will be created. If value is set to null, the ExtendedProperty will be removed.")]
		public void SetExtendedProperty(string name, string value, ExtendedPropertyType type = ExtendedPropertyType.String) {
			if(name == null) name = GetNewExtendedPropertyName();

			if(value == null) {
				// Remove ExtendedProperty if set to null:
				RemoveExtendedProperty(name);
				return;
			}

			if(GetExtendedProperty(name) == value) return;
			bool undoable = true;
			bool cancel = false;
			OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + value, ref undoable, ref cancel);
			if (cancel) return;

			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Change existing ExtendedProperty:
				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				var ep = MetadataObject.ExtendedProperties[name];
				if (ep is TOM.JsonExtendedProperty)
					(ep as TOM.JsonExtendedProperty).Value = value;
				else 
					(ep as TOM.StringExtendedProperty).Value = value;
					
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, name + ":" + value);
			} else {
				// Add new ExtendedProperty:
				if (type == ExtendedPropertyType.Json)
					MetadataObject.ExtendedProperties.Add(new TOM.JsonExtendedProperty{ Name = name, Value = value });
				else
					MetadataObject.ExtendedProperties.Add(new TOM.StringExtendedProperty{ Name = name, Value = value });

				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, null, type));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, null, name + ":" + value);
			}

		}
		[IntelliSense("Remove an ExtendedProperty by the given name.")]
		public void RemoveExtendedProperty(string name) {
			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Get current value:
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + GetExtendedProperty(name), ref undoable, ref cancel);
				if (cancel) return;

				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				MetadataObject.ExtendedProperties.Remove(name);

				// Undo-handling:
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, null, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, null);
			}
		}
		[IntelliSense("Gets the number of ExtendedProperties on the current object.")]
		public int GetExtendedPropertyCount() {
			return MetadataObject.ExtendedProperties.Count;
		}
		[IntelliSense("Gets a collection of all ExtendedProperty names on the current object.")]
		public IEnumerable<string> GetExtendedProperties() {
			return MetadataObject.ExtendedProperties.Select(a => a.Name);
		}

		/// <summary>
///             The description of the hierarchy, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio.
///             </summary>
		[DisplayName("Description")]
		[Category("Basic"),Description(@"The description of the hierarchy, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio."),IntelliSense(@"The description of the hierarchy, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio.")][Editor(typeof(System.ComponentModel.Design.MultilineStringEditor), typeof(System.Drawing.Design.UITypeEditor))]
		public string Description {
			get {
			    return MetadataObject.Description;
			}
			set {
				
				var oldValue = Description;
				var newValue = value.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DESCRIPTION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.Description = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DESCRIPTION, oldValue, newValue));
				OnPropertyChanged(Properties.DESCRIPTION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeDescription() { return false; }
/// <summary>
///             A boolean value that indicates whether the hierarchy is treated as hidden by client visualization tools. True if the hierarchy is treated as hidden; otherwise false.
///             </summary>
		[DisplayName("Hidden")]
		[Category("Basic"),Description(@"A boolean value that indicates whether the hierarchy is treated as hidden by client visualization tools. True if the hierarchy is treated as hidden; otherwise false."),IntelliSense(@"A boolean value that indicates whether the hierarchy is treated as hidden by client visualization tools. True if the hierarchy is treated as hidden; otherwise false.")]
		public bool IsHidden {
			get {
			    return MetadataObject.IsHidden;
			}
			set {
				
				var oldValue = IsHidden;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ISHIDDEN, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.IsHidden = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.ISHIDDEN, oldValue, newValue));
				OnPropertyChanged(Properties.ISHIDDEN, oldValue, newValue);
				Handler.UpdateObject(this);
			}
		}
		private bool ShouldSerializeIsHidden() { return false; }
/// <summary>
///             Provides information on the state of the hierarchy. Possible values and their interpretation are as follows. Ready (1) The hierarchy is queryable and has up-to-date data. NoData (3) Not applicable to Hierarchy. CalculationNeeded (4) The hierarchy does not contain any data because it was not refreshed. There is no error associated with the hierarchy. SemanticError (5) Not applicable to Hierarchy. EvaluationError (6) Not applicable to Hierarchy. DependencyError (7) A dependency associated with the hierarchy is in an error state (SemanticError, EvaluationError, or DependencyError). Incomplete (8) Not applicable to Hierarchy.
///             </summary>
		[DisplayName("State")]
		[Category("Metadata"),Description(@"Provides information on the state of the hierarchy. Possible values and their interpretation are as follows. Ready (1) The hierarchy is queryable and has up-to-date data. NoData (3) Not applicable to Hierarchy. CalculationNeeded (4) The hierarchy does not contain any data because it was not refreshed. There is no error associated with the hierarchy. SemanticError (5) Not applicable to Hierarchy. EvaluationError (6) Not applicable to Hierarchy. DependencyError (7) A dependency associated with the hierarchy is in an error state (SemanticError, EvaluationError, or DependencyError). Incomplete (8) Not applicable to Hierarchy."),IntelliSense(@"Provides information on the state of the hierarchy. Possible values and their interpretation are as follows. Ready (1) The hierarchy is queryable and has up-to-date data. NoData (3) Not applicable to Hierarchy. CalculationNeeded (4) The hierarchy does not contain any data because it was not refreshed. There is no error associated with the hierarchy. SemanticError (5) Not applicable to Hierarchy. EvaluationError (6) Not applicable to Hierarchy. DependencyError (7) A dependency associated with the hierarchy is in an error state (SemanticError, EvaluationError, or DependencyError). Incomplete (8) Not applicable to Hierarchy.")]
		public ObjectState State {
			get {
			    return (ObjectState)MetadataObject.State;
			}
			
		}
		private bool ShouldSerializeState() { return false; }
/// <summary>
///             Defines the display folder for the hierarchy, for use by clients.
///             </summary>
		[DisplayName("Display Folder")]
		[Category("Basic"),Description(@"Defines the display folder for the hierarchy, for use by clients."),IntelliSense(@"Defines the display folder for the hierarchy, for use by clients.")][Editor(typeof(CustomDialogEditor), typeof(System.Drawing.Design.UITypeEditor))]
		public string DisplayFolder {
			get {
			    return MetadataObject.DisplayFolder;
			}
			set {
				if(value.Contains(@"\\")) throw new Exception("Display Folder names cannot be blank.");
				var oldValue = DisplayFolder;
				var newValue = value.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DISPLAYFOLDER, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.DisplayFolder = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DISPLAYFOLDER, oldValue, newValue));
				OnPropertyChanged(Properties.DISPLAYFOLDER, oldValue, newValue);
				Handler.UpdateFolders(Table);
			}
		}
		private bool ShouldSerializeDisplayFolder() { return false; }
        /// <summary>
        /// Collection of localized Display Folders for this Hierarchy.
        /// </summary>
        [Browsable(true),DisplayName("Translated Display Folders"),Description("Shows all translated Display Folders of this object."),Category("Translations and Perspectives")]
	    public TranslationIndexer TranslatedDisplayFolders { private set; get; }
/// <summary>
///             Ragged/unbalanced hierarchies can be enabled by hiding members using this property.
///             </summary><remarks>This property is only supported when the compatibility level of the database is at 1400 or above.</remarks>
		[DisplayName("Hide Members")]
		[Category("Other"),Description(@"Ragged/unbalanced hierarchies can be enabled by hiding members using this property."),IntelliSense(@"Ragged/unbalanced hierarchies can be enabled by hiding members using this property.")]
		public HierarchyHideMembersType HideMembers {
			get {
			    return (HierarchyHideMembersType)MetadataObject.HideMembers;
			}
			set {
				
				var oldValue = HideMembers;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.HIDEMEMBERS, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.HideMembers = (TOM.HierarchyHideMembersType)newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.HIDEMEMBERS, oldValue, newValue));
				OnPropertyChanged(Properties.HIDEMEMBERS, oldValue, newValue);
			}
		}
		private bool ShouldSerializeHideMembers() { return false; }
		[Browsable(false)]
		public Table Table
		{ 
			get 
			{ 
				TabularObject t = null;
				if(MetadataObject == null || MetadataObject.Table == null) return null;
				if(!Handler.WrapperLookup.TryGetValue(MetadataObject.Table, out t)) {
				    t = Model.Tables[MetadataObject.Table.Name];
				}
				return t as Table;
			} 
		}

        /// <Summary>
		/// Collection of perspectives in which this Hierarchy is visible.
		/// </Summary>
		[Browsable(true),DisplayName("Shown in Perspective"), Description("Provides an easy way to include or exclude this object from the perspectives of the model."), Category("Translations and Perspectives")]
        public PerspectiveHierarchyIndexer InPerspective { get; private set; }
		PerspectiveIndexer ITabularPerspectiveObject.InPerspective { get { return this.InPerspective; } }
        /// <summary>
        /// Collection of localized descriptions for this Hierarchy.
        /// </summary>
        [Browsable(true),DisplayName("Translated Descriptions"),Description("Shows all translated descriptions of this object."),Category("Translations and Perspectives")]
	    public TranslationIndexer TranslatedDescriptions { private set; get; }
        /// <summary>
        /// Collection of localized names for this Hierarchy.
        /// </summary>
        [Browsable(true),DisplayName("Translated Names"),Description("Shows all translated names of this object."),Category("Translations and Perspectives")]
	    public TranslationIndexer TranslatedNames { private set; get; }

		internal static Hierarchy CreateFromMetadata(Table parent, TOM.Hierarchy metadataObject) {
			var obj = new Hierarchy(metadataObject);
			parent.Hierarchies.Add(obj);
			
			obj.Init();

			return obj;
		}


		/// <summary>
		/// Creates a new Hierarchy and adds it to the parent Table.
		/// Also creates the underlying metadataobject and adds it to the TOM tree.
		/// </summary>
		public static Hierarchy CreateNew(Table parent, string name = null)
		{
			if(TabularModelHandler.Singleton.UsePowerBIGovernance && !PowerBI.PowerBIGovernance.AllowCreate(typeof(Hierarchy))) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(Hierarchy).GetTypeName()));
			}

			var metadataObject = new TOM.Hierarchy();
			metadataObject.Name = parent.Hierarchies.GetNewName(string.IsNullOrWhiteSpace(name) ? "New " + typeof(Hierarchy).GetTypeName() : name);

			var obj = new Hierarchy(metadataObject);

			parent.Hierarchies.Add(obj);
			
			obj.Init();

			return obj;
		}


		/// <summary>
		/// Creates an exact copy of this Hierarchy object.
		/// </summary>
		public Hierarchy Clone(string newName = null, bool includeTranslations = true, Table newParent = null) {
			if(TabularModelHandler.Singleton.UsePowerBIGovernance && !PowerBI.PowerBIGovernance.AllowCreate(typeof(Hierarchy))) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(Hierarchy).GetTypeName()));
			}

		    Handler.BeginUpdate("Clone Hierarchy");

			// Create a clone of the underlying metadataobject:
			var tom = MetadataObject.Clone() as TOM.Hierarchy;


			// Assign a new, unique name:
			tom.Name = Parent.Hierarchies.GetNewName(string.IsNullOrEmpty(newName) ? tom.Name + " copy" : newName);
				
			// Create the TOM Wrapper object, representing the metadataobject
			Hierarchy obj = CreateFromMetadata(newParent ?? Parent, tom);

			// Copy translations, if applicable:
			if(includeTranslations) {
				obj.CopyTranslationsFrom(this);
				foreach(var objChild in obj.Levels) objChild.CopyTranslationsFrom(obj.Levels[objChild.MetadataIndex]);
			}
				
			// Copy perspectives:
			obj.InPerspective.CopyFrom(InPerspective);

            Handler.EndUpdate();

            return obj;
		}

		TabularNamedObject IClonableObject.Clone(string newName, bool includeTranslations, TabularNamedObject newParent) 
		{
			return Clone(newName, includeTranslations);
		}

	
        internal override void RenewMetadataObject()
        {
            Handler.WrapperLookup.Remove(MetadataObject);
            MetadataObject = MetadataObject.Clone() as TOM.Hierarchy;
            Handler.WrapperLookup.Add(MetadataObject, this);
        }

		public Table Parent { 
			get {
				return Handler.WrapperLookup[MetadataObject.Parent] as Table;
			}
		}

        internal override ITabularObjectCollection GetCollectionForChild(TabularObject child)
        {
			if (child is Level) return Levels;
            return base.GetCollectionForChild(child);
        }

        /// <summary>
        /// The collection of Level objects on this Hierarchy.
        /// </summary>
		[DisplayName("Levels")]
		[Category("Other"),IntelliSense("The collection of Level objects on this Hierarchy.")][Browsable(false)]
		public LevelCollection Levels { get; private set; }

		/// <summary>
		/// CTOR - only called from static factory methods on the class
		/// </summary>
		Hierarchy(TOM.Hierarchy metadataObject) : base(metadataObject)
		{
			// Create indexers for translations:
			TranslatedNames = new TranslationIndexer(this, TOM.TranslatedProperty.Caption);
			TranslatedDescriptions = new TranslationIndexer(this, TOM.TranslatedProperty.Description);
			TranslatedDisplayFolders = new TranslationIndexer(this, TOM.TranslatedProperty.DisplayFolder);

			// Create indexer for perspectives:
			InPerspective = new PerspectiveHierarchyIndexer(this);
			
			// Create indexer for annotations:
			Annotations = new AnnotationCollection(this);
			
			// Create indexer for extended properties:
			ExtendedProperties = new ExtendedPropertyCollection(this);
			
			// Instantiate child collections:
			Levels = new LevelCollection(this.GetObjectPath() + ".Levels", MetadataObject.Levels, this);

			// Populate child collections:
			Levels.CreateChildrenFromMetadata();

			// Hook up event handlers on child collections:
			Levels.CollectionChanged += Children_CollectionChanged;
		}


		internal override void Reinit() {
			Levels.Reinit();
		}

		internal override void Undelete(ITabularObjectCollection collection) {
			base.Undelete(collection);
			Reinit();
			ReapplyReferences();
		}

		public override bool Browsable(string propertyName) {
			switch (propertyName) {
 
				case Properties.EXTENDEDPROPERTIES:
					return Handler.CompatibilityLevel >= 1400;
				case Properties.PARENT:
					return false;
				
				// Hides translation properties in the grid, unless the model actually contains translations:
				case Properties.TRANSLATEDNAMES:
				case Properties.TRANSLATEDDESCRIPTIONS:
				case Properties.TRANSLATEDDISPLAYFOLDERS:
					return Model.Cultures.Any();
				
				// Hides the perspective property in the grid, unless the model actually contains perspectives:
				case Properties.INPERSPECTIVE:
					return Model.Perspectives.Any();
				
				default:
					return base.Browsable(propertyName);
			}
		}

    }


	/// <summary>
	/// Collection class for Hierarchy. Provides convenient properties for setting a property on multiple objects at once.
	/// </summary>
	public sealed partial class HierarchyCollection: TabularObjectCollection<Hierarchy>
	{
		internal Table Table { get { return Parent as Table; } }
		TOM.HierarchyCollection TOM_Collection;
		internal HierarchyCollection(string collectionName, TOM.HierarchyCollection metadataObjectCollection, Table parent) : base(collectionName, parent)
		{
			TOM_Collection = metadataObjectCollection;
		}
		internal override Type GetItemType() { return typeof(Hierarchy); }
        protected override void TOM_Add(TOM.MetadataObject obj) { TOM_Collection.Add(obj as TOM.Hierarchy); }
        protected override bool TOM_Contains(TOM.MetadataObject obj) { return TOM_Collection.Contains(obj as TOM.Hierarchy); }
        protected override void TOM_Remove(TOM.MetadataObject obj) { TOM_Collection.Remove(obj as TOM.Hierarchy); }
        protected override void TOM_Clear() { TOM_Collection.Clear(); }
        protected override bool TOM_ContainsName(string name) { return TOM_Collection.ContainsName(name); }
        protected override TOM.MetadataObject TOM_Get(int index) { return TOM_Collection[index]; }
        protected override TOM.MetadataObject TOM_Get(string name) { return TOM_Collection[name]; }
        internal override string GetNewName(string prefix = null) { return string.IsNullOrEmpty(prefix) ? TOM_Collection.GetNewName() : TOM_Collection.GetNewName(prefix); }
        public override int IndexOf(TOM.MetadataObject obj) { return TOM_Collection.IndexOf(obj as TOM.Hierarchy); }
        public override int Count { get { return TOM_Collection.Count; } }
        public override IEnumerator<Hierarchy> GetEnumerator() { return TOM_Collection.Select(h => Handler.WrapperLookup[h]).OfType<Hierarchy>().GetEnumerator(); }
		internal override void Reinit() {
			var ixOffset = 0;
			for(int i = 0; i < Count; i++) {
				var item = this[i];
				Handler.WrapperLookup.Remove(item.MetadataObject);
				item.MetadataObject = Table.MetadataObject.Hierarchies[i + ixOffset] as TOM.Hierarchy;
				Handler.WrapperLookup.Add(item.MetadataObject, item);
				item.Collection = this;
			}
			TOM_Collection = Table.MetadataObject.Hierarchies;
			foreach(var item in this) item.Reinit();
		}

		internal override void ReapplyReferences() {
			foreach(var item in this) item.ReapplyReferences();
		}

		/// <summary>
		/// Calling this method will populate the HierarchyCollection with objects based on the MetadataObjects in the corresponding MetadataObjectCollection.
		/// </summary>
		internal override void CreateChildrenFromMetadata()
		{
			// Construct child objects (they are automatically added to the Handler's WrapperLookup dictionary):
			foreach(var obj in TOM_Collection) {
				if(obj is TOM.Hierarchy) Hierarchy.CreateFromMetadata(Table, obj as TOM.Hierarchy);
		    }
		}

		/// <summary>
		/// Sets the Description property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the Description property of all objects in the collection at once.")]
		public string Description {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("Description"));
				this.ToList().ForEach(item => { item.Description = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the IsHidden property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the IsHidden property of all objects in the collection at once.")]
		public bool IsHidden {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("IsHidden"));
				this.ToList().ForEach(item => { item.IsHidden = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the DisplayFolder property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the DisplayFolder property of all objects in the collection at once.")]
		public string DisplayFolder {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("DisplayFolder"));
				this.ToList().ForEach(item => { item.DisplayFolder = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the HideMembers property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the HideMembers property of all objects in the collection at once.")]
		public HierarchyHideMembersType HideMembers {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("HideMembers"));
				this.ToList().ForEach(item => { item.HideMembers = value; });
				Handler.UndoManager.EndBatch();
			}
		}

		public override string ToString() {
			return string.Format("({0} {1})", Count, (Count == 1 ? "Hierarchy" : "Hierarchies").ToLower());
		}
	}
  
	/// <summary>
///             Represents a Key Performance Indicator object. It is a child of a Measure object.
///             </summary>
	[TypeConverter(typeof(DynamicPropertyConverter))]
	public sealed partial class KPI: TabularObject
			, IDescriptionObject
			, IAnnotationObject
			, IExtendedPropertyObject
	{
	    internal new TOM.KPI MetadataObject 
		{ 
			get 
			{ 
				return base.MetadataObject as TOM.KPI; 
		    } 
			set 
			{ 
				base.MetadataObject = value; 
			}
		}

        [Browsable(true),NoMultiselect,Category("Translations and Perspectives"),Description("The collection of Annotations on this object."),Editor(typeof(AnnotationCollectionEditor), typeof(UITypeEditor))]
		public AnnotationCollection Annotations { get; private set; }
		public string GetAnnotation(int index) {
			return MetadataObject.Annotations[index].Value;
		}
		[IntelliSense("Returns true if an annotation with the given name exists. Otherwise false.")]
		public bool HasAnnotation(string name) {
		    return MetadataObject.Annotations.ContainsName(name);
		}
		[IntelliSense("Gets the value of the annotation with the given name. Returns null if no such annotation exists.")]
		public string GetAnnotation(string name) {
		    return HasAnnotation(name) ? MetadataObject.Annotations[name].Value : null;
		}
		public void SetAnnotation(int index, string value, bool undoable = true) {
			var name = MetadataObject.Annotations[index].Name;
			SetAnnotation(name, value, undoable);
		}
		public string GetNewAnnotationName() {
			return MetadataObject.Annotations.GetNewName("New Annotation");
		}
		[IntelliSense("Sets the value of the annotation having the given name. If no such annotation exists, it will be created. If value is set to null, the annotation will be removed.")]
		public void SetAnnotation(string name, string value) {
		    SetAnnotation(name, value, true);
		}
		public void SetAnnotation(string name, string value, bool undoable) {
			if(name == null) name = GetNewAnnotationName();

			if(value == null) {
				// Remove annotation if set to null:
				RemoveAnnotation(name, undoable);
				return;
			}

			if(GetAnnotation(name) == value) return;
			bool undoable2 = true;
			bool cancel = false;
			OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + value, ref undoable2, ref cancel);
			if (cancel) return;

			if(MetadataObject.Annotations.Contains(name)) {
				// Change existing annotation:
				var oldValue = GetAnnotation(name);
				MetadataObject.Annotations[name].Value = value;
				if (undoable) Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, oldValue));
				OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, name + ":" + value);
			} else {
				// Add new annotation:
				MetadataObject.Annotations.Add(new TOM.Annotation{ Name = name, Value = value });
				if (undoable) Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, null));
				OnPropertyChanged(Properties.ANNOTATIONS, null, name + ":" + value);
			}

		}
		[IntelliSense("Remove an annotation by the given name.")]
		public void RemoveAnnotation(string name) {
		    RemoveAnnotation(name, true);
		}
		public void RemoveAnnotation(string name, bool undoable) {
			if(MetadataObject.Annotations.Contains(name)) {
				// Get current value:
				bool undoable2 = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + GetAnnotation(name), ref undoable2, ref cancel);
				if (cancel) return;

				var oldValue = MetadataObject.Annotations[name].Value;
				MetadataObject.Annotations.Remove(name);

				// Undo-handling:
				if (undoable) Handler.UndoManager.Add(new UndoAnnotationAction(this, name, null, oldValue));
				OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, null);
			}
		}
		[IntelliSense("Gets the number of annotations on the current object.")]
		public int GetAnnotationsCount() {
			return MetadataObject.Annotations.Count;
		}
		[IntelliSense("Gets a collection of all annotation names on the current object.")]
		public IEnumerable<string> GetAnnotations() {
			return MetadataObject.Annotations.Select(a => a.Name);
		}

		        [DisplayName("Extended Properties"),NoMultiselect,Category("Translations and Perspectives"),Description("The collection of Extended Properties on this object."),Editor(typeof(ExtendedPropertyCollectionEditor), typeof(UITypeEditor))]
		public ExtendedPropertyCollection ExtendedProperties { get; private set; }

		[IntelliSense("Returns true if an ExtendedProperty with the given name exists. Otherwise false.")]
		public bool HasExtendedProperty(string name) {
		    return MetadataObject.ExtendedProperties.ContainsName(name);
		}
		public ExtendedPropertyType GetExtendedPropertyType(int index) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[index].Type;
		}
		public ExtendedPropertyType GetExtendedPropertyType(string name) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[name].Type;
		}
		public string GetExtendedProperty(int index) {
			var ep = MetadataObject.ExtendedProperties[index];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		[IntelliSense("Gets the value of the ExtendedProperty with the given name. Returns null if no such ExtendedProperty exists.")]
		public string GetExtendedProperty(string name) {
		    if(!HasExtendedProperty(name)) return null;
			var ep = MetadataObject.ExtendedProperties[name];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		public void SetExtendedProperty(int index, string value, ExtendedPropertyType type = ExtendedPropertyType.String) {
			var name = MetadataObject.ExtendedProperties[index].Name;
			SetExtendedProperty(name, value, type);
		}
		public string GetNewExtendedPropertyName() {
			return MetadataObject.ExtendedProperties.GetNewName("New ExtendedProperty");
		}
		[IntelliSense("Sets the value of the ExtendedProperty having the given name. If no such ExtendedProperty exists, it will be created. If value is set to null, the ExtendedProperty will be removed.")]
		public void SetExtendedProperty(string name, string value, ExtendedPropertyType type = ExtendedPropertyType.String) {
			if(name == null) name = GetNewExtendedPropertyName();

			if(value == null) {
				// Remove ExtendedProperty if set to null:
				RemoveExtendedProperty(name);
				return;
			}

			if(GetExtendedProperty(name) == value) return;
			bool undoable = true;
			bool cancel = false;
			OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + value, ref undoable, ref cancel);
			if (cancel) return;

			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Change existing ExtendedProperty:
				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				var ep = MetadataObject.ExtendedProperties[name];
				if (ep is TOM.JsonExtendedProperty)
					(ep as TOM.JsonExtendedProperty).Value = value;
				else 
					(ep as TOM.StringExtendedProperty).Value = value;
					
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, name + ":" + value);
			} else {
				// Add new ExtendedProperty:
				if (type == ExtendedPropertyType.Json)
					MetadataObject.ExtendedProperties.Add(new TOM.JsonExtendedProperty{ Name = name, Value = value });
				else
					MetadataObject.ExtendedProperties.Add(new TOM.StringExtendedProperty{ Name = name, Value = value });

				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, null, type));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, null, name + ":" + value);
			}

		}
		[IntelliSense("Remove an ExtendedProperty by the given name.")]
		public void RemoveExtendedProperty(string name) {
			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Get current value:
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + GetExtendedProperty(name), ref undoable, ref cancel);
				if (cancel) return;

				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				MetadataObject.ExtendedProperties.Remove(name);

				// Undo-handling:
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, null, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, null);
			}
		}
		[IntelliSense("Gets the number of ExtendedProperties on the current object.")]
		public int GetExtendedPropertyCount() {
			return MetadataObject.ExtendedProperties.Count;
		}
		[IntelliSense("Gets a collection of all ExtendedProperty names on the current object.")]
		public IEnumerable<string> GetExtendedProperties() {
			return MetadataObject.ExtendedProperties.Select(a => a.Name);
		}

		/// <summary>
///             The description of the KPI, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio.
///             </summary>
		[DisplayName("Description")]
		[Category("Basic"),Description(@"The description of the KPI, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio."),IntelliSense(@"The description of the KPI, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio.")][Editor(typeof(System.ComponentModel.Design.MultilineStringEditor), typeof(System.Drawing.Design.UITypeEditor))]
		public string Description {
			get {
			    return MetadataObject.Description;
			}
			set {
				
				var oldValue = Description;
				var newValue = value.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DESCRIPTION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.Description = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DESCRIPTION, oldValue, newValue));
				OnPropertyChanged(Properties.DESCRIPTION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeDescription() { return false; }
/// <summary>
///             The description of the target value of the KPI.
///             </summary>
		[DisplayName("Target Description")]
		[Category("Other"),Description(@"The description of the target value of the KPI."),IntelliSense(@"The description of the target value of the KPI.")][Editor(typeof(System.ComponentModel.Design.MultilineStringEditor), typeof(System.Drawing.Design.UITypeEditor))]
		public string TargetDescription {
			get {
			    return MetadataObject.TargetDescription;
			}
			set {
				
				var oldValue = TargetDescription;
				var newValue = value.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.TARGETDESCRIPTION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.TargetDescription = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.TARGETDESCRIPTION, oldValue, newValue));
				OnPropertyChanged(Properties.TARGETDESCRIPTION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeTargetDescription() { return false; }
/// <summary>
///             An expression that evaluates to a number and indicates the goal for the KPI.
///             </summary>
		[DisplayName("Target Expression")]
		[Category("Other"),Description(@"An expression that evaluates to a number and indicates the goal for the KPI."),IntelliSense(@"An expression that evaluates to a number and indicates the goal for the KPI.")][Editor(typeof(System.ComponentModel.Design.MultilineStringEditor), typeof(System.Drawing.Design.UITypeEditor))]
		public string TargetExpression {
			get {
			    return MetadataObject.TargetExpression;
			}
			set {
				
				var oldValue = TargetExpression;
				var newValue = value.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.TARGETEXPRESSION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.TargetExpression = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.TARGETEXPRESSION, oldValue, newValue));
				OnPropertyChanged(Properties.TARGETEXPRESSION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeTargetExpression() { return false; }
/// <summary>
///             The format string to be used when presenting the target value for the KPI.
///             </summary>
		[DisplayName("Target Format String")]
		[Category("Other"),Description(@"The format string to be used when presenting the target value for the KPI."),IntelliSense(@"The format string to be used when presenting the target value for the KPI.")][TypeConverter(typeof(FormatStringConverter))]
		public string TargetFormatString {
			get {
			    return MetadataObject.TargetFormatString;
			}
			set {
				
				var oldValue = TargetFormatString;
				var newValue = value.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.TARGETFORMATSTRING, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.TargetFormatString = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.TARGETFORMATSTRING, oldValue, newValue));
				OnPropertyChanged(Properties.TARGETFORMATSTRING, oldValue, newValue);
			}
		}
		private bool ShouldSerializeTargetFormatString() { return false; }
/// <summary>
///             The recommended graphic to represent the status of this KPI.
///             </summary>
		[DisplayName("Status Graphic")]
		[Category("Other"),Description(@"The recommended graphic to represent the status of this KPI."),IntelliSense(@"The recommended graphic to represent the status of this KPI.")][TypeConverter(typeof(KPIStatusGraphicConverter))]
		public string StatusGraphic {
			get {
			    return MetadataObject.StatusGraphic;
			}
			set {
				
				var oldValue = StatusGraphic;
				var newValue = value.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.STATUSGRAPHIC, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.StatusGraphic = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.STATUSGRAPHIC, oldValue, newValue));
				OnPropertyChanged(Properties.STATUSGRAPHIC, oldValue, newValue);
			}
		}
		private bool ShouldSerializeStatusGraphic() { return false; }
/// <summary>
///             A description of the Status value for the KPI.
///             </summary>
		[DisplayName("Status Description")]
		[Category("Other"),Description(@"A description of the Status value for the KPI."),IntelliSense(@"A description of the Status value for the KPI.")][Editor(typeof(System.ComponentModel.Design.MultilineStringEditor), typeof(System.Drawing.Design.UITypeEditor))]
		public string StatusDescription {
			get {
			    return MetadataObject.StatusDescription;
			}
			set {
				
				var oldValue = StatusDescription;
				var newValue = value.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.STATUSDESCRIPTION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.StatusDescription = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.STATUSDESCRIPTION, oldValue, newValue));
				OnPropertyChanged(Properties.STATUSDESCRIPTION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeStatusDescription() { return false; }
/// <summary>
///             An expression that is used to calculate the status of the KPI.
///             </summary>
		[DisplayName("Status Expression")]
		[Category("Other"),Description(@"An expression that is used to calculate the status of the KPI."),IntelliSense(@"An expression that is used to calculate the status of the KPI.")][Editor(typeof(System.ComponentModel.Design.MultilineStringEditor), typeof(System.Drawing.Design.UITypeEditor))]
		public string StatusExpression {
			get {
			    return MetadataObject.StatusExpression;
			}
			set {
				
				var oldValue = StatusExpression;
				var newValue = value.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.STATUSEXPRESSION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.StatusExpression = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.STATUSEXPRESSION, oldValue, newValue));
				OnPropertyChanged(Properties.STATUSEXPRESSION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeStatusExpression() { return false; }
/// <summary>
///             A string that identifies the graphic to show for the trend of the KPI.
///             </summary>
		[DisplayName("Trend Graphic")]
		[Category("Other"),Description(@"A string that identifies the graphic to show for the trend of the KPI."),IntelliSense(@"A string that identifies the graphic to show for the trend of the KPI.")][TypeConverter(typeof(KPITrendGraphicConverter))]
		public string TrendGraphic {
			get {
			    return MetadataObject.TrendGraphic;
			}
			set {
				
				var oldValue = TrendGraphic;
				var newValue = value.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.TRENDGRAPHIC, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.TrendGraphic = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.TRENDGRAPHIC, oldValue, newValue));
				OnPropertyChanged(Properties.TRENDGRAPHIC, oldValue, newValue);
			}
		}
		private bool ShouldSerializeTrendGraphic() { return false; }
/// <summary>
///             A description of the trend value of the KPI.
///             </summary>
		[DisplayName("Trend Description")]
		[Category("Other"),Description(@"A description of the trend value of the KPI."),IntelliSense(@"A description of the trend value of the KPI.")][Editor(typeof(System.ComponentModel.Design.MultilineStringEditor), typeof(System.Drawing.Design.UITypeEditor))]
		public string TrendDescription {
			get {
			    return MetadataObject.TrendDescription;
			}
			set {
				
				var oldValue = TrendDescription;
				var newValue = value.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.TRENDDESCRIPTION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.TrendDescription = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.TRENDDESCRIPTION, oldValue, newValue));
				OnPropertyChanged(Properties.TRENDDESCRIPTION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeTrendDescription() { return false; }
/// <summary>
///             An expression representing the trend of the KPI.
///             </summary>
		[DisplayName("Trend Expression")]
		[Category("Other"),Description(@"An expression representing the trend of the KPI."),IntelliSense(@"An expression representing the trend of the KPI.")][Editor(typeof(System.ComponentModel.Design.MultilineStringEditor), typeof(System.Drawing.Design.UITypeEditor))]
		public string TrendExpression {
			get {
			    return MetadataObject.TrendExpression;
			}
			set {
				
				var oldValue = TrendExpression;
				var newValue = value.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.TRENDEXPRESSION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.TrendExpression = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.TRENDEXPRESSION, oldValue, newValue));
				OnPropertyChanged(Properties.TRENDEXPRESSION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeTrendExpression() { return false; }
/// <summary>
///             A reference to a Measure object that owns this KPI.
///             </summary>
		[DisplayName("Measure")]
		[Category("Other"),Description(@"A reference to a Measure object that owns this KPI."),IntelliSense(@"A reference to a Measure object that owns this KPI.")]
		public Measure Measure {
			get {
				if (MetadataObject.Measure == null) return null;
			    return Handler.WrapperLookup[MetadataObject.Measure] as Measure;
            }
			
		}
		private bool ShouldSerializeMeasure() { return false; }

	
        internal override void RenewMetadataObject()
        {
            Handler.WrapperLookup.Remove(MetadataObject);
            MetadataObject = MetadataObject.Clone() as TOM.KPI;
            Handler.WrapperLookup.Add(MetadataObject, this);
        }




		/// <summary>
		/// CTOR - only called from static factory methods on the class
		/// </summary>
		KPI(TOM.KPI metadataObject) : base(metadataObject)
		{
			
			// Create indexer for annotations:
			Annotations = new AnnotationCollection(this);
			
			// Create indexer for extended properties:
			ExtendedProperties = new ExtendedPropertyCollection(this);
		}



		internal override void Undelete(ITabularObjectCollection collection) {
			base.Undelete(collection);
			Reinit();
			ReapplyReferences();
		}

		public override bool Browsable(string propertyName) {
			switch (propertyName) {
 
				case Properties.EXTENDEDPROPERTIES:
					return Handler.CompatibilityLevel >= 1400;
				
				default:
					return base.Browsable(propertyName);
			}
		}

    }

  
	/// <summary>
///             Represents a level in a hierarchy that provides a logical hierarchical drilldown path for client applications. It is a child of a Hierarchy object. The level is based on the values in a column.
///             </summary>
	[TypeConverter(typeof(DynamicPropertyConverter))]
	public sealed partial class Level: TabularNamedObject
			, IDescriptionObject
			, IAnnotationObject
			, IExtendedPropertyObject
			, ITranslatableObject
			, IClonableObject
	{
	    internal new TOM.Level MetadataObject 
		{ 
			get 
			{ 
				return base.MetadataObject as TOM.Level; 
		    } 
			set 
			{ 
				base.MetadataObject = value; 
			}
		}

        [Browsable(true),NoMultiselect,Category("Translations and Perspectives"),Description("The collection of Annotations on this object."),Editor(typeof(AnnotationCollectionEditor), typeof(UITypeEditor))]
		public AnnotationCollection Annotations { get; private set; }
		public string GetAnnotation(int index) {
			return MetadataObject.Annotations[index].Value;
		}
		[IntelliSense("Returns true if an annotation with the given name exists. Otherwise false.")]
		public bool HasAnnotation(string name) {
		    return MetadataObject.Annotations.ContainsName(name);
		}
		[IntelliSense("Gets the value of the annotation with the given name. Returns null if no such annotation exists.")]
		public string GetAnnotation(string name) {
		    return HasAnnotation(name) ? MetadataObject.Annotations[name].Value : null;
		}
		public void SetAnnotation(int index, string value, bool undoable = true) {
			var name = MetadataObject.Annotations[index].Name;
			SetAnnotation(name, value, undoable);
		}
		public string GetNewAnnotationName() {
			return MetadataObject.Annotations.GetNewName("New Annotation");
		}
		[IntelliSense("Sets the value of the annotation having the given name. If no such annotation exists, it will be created. If value is set to null, the annotation will be removed.")]
		public void SetAnnotation(string name, string value) {
		    SetAnnotation(name, value, true);
		}
		public void SetAnnotation(string name, string value, bool undoable) {
			if(name == null) name = GetNewAnnotationName();

			if(value == null) {
				// Remove annotation if set to null:
				RemoveAnnotation(name, undoable);
				return;
			}

			if(GetAnnotation(name) == value) return;
			bool undoable2 = true;
			bool cancel = false;
			OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + value, ref undoable2, ref cancel);
			if (cancel) return;

			if(MetadataObject.Annotations.Contains(name)) {
				// Change existing annotation:
				var oldValue = GetAnnotation(name);
				MetadataObject.Annotations[name].Value = value;
				if (undoable) Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, oldValue));
				OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, name + ":" + value);
			} else {
				// Add new annotation:
				MetadataObject.Annotations.Add(new TOM.Annotation{ Name = name, Value = value });
				if (undoable) Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, null));
				OnPropertyChanged(Properties.ANNOTATIONS, null, name + ":" + value);
			}

		}
		[IntelliSense("Remove an annotation by the given name.")]
		public void RemoveAnnotation(string name) {
		    RemoveAnnotation(name, true);
		}
		public void RemoveAnnotation(string name, bool undoable) {
			if(MetadataObject.Annotations.Contains(name)) {
				// Get current value:
				bool undoable2 = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + GetAnnotation(name), ref undoable2, ref cancel);
				if (cancel) return;

				var oldValue = MetadataObject.Annotations[name].Value;
				MetadataObject.Annotations.Remove(name);

				// Undo-handling:
				if (undoable) Handler.UndoManager.Add(new UndoAnnotationAction(this, name, null, oldValue));
				OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, null);
			}
		}
		[IntelliSense("Gets the number of annotations on the current object.")]
		public int GetAnnotationsCount() {
			return MetadataObject.Annotations.Count;
		}
		[IntelliSense("Gets a collection of all annotation names on the current object.")]
		public IEnumerable<string> GetAnnotations() {
			return MetadataObject.Annotations.Select(a => a.Name);
		}

		        [DisplayName("Extended Properties"),NoMultiselect,Category("Translations and Perspectives"),Description("The collection of Extended Properties on this object."),Editor(typeof(ExtendedPropertyCollectionEditor), typeof(UITypeEditor))]
		public ExtendedPropertyCollection ExtendedProperties { get; private set; }

		[IntelliSense("Returns true if an ExtendedProperty with the given name exists. Otherwise false.")]
		public bool HasExtendedProperty(string name) {
		    return MetadataObject.ExtendedProperties.ContainsName(name);
		}
		public ExtendedPropertyType GetExtendedPropertyType(int index) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[index].Type;
		}
		public ExtendedPropertyType GetExtendedPropertyType(string name) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[name].Type;
		}
		public string GetExtendedProperty(int index) {
			var ep = MetadataObject.ExtendedProperties[index];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		[IntelliSense("Gets the value of the ExtendedProperty with the given name. Returns null if no such ExtendedProperty exists.")]
		public string GetExtendedProperty(string name) {
		    if(!HasExtendedProperty(name)) return null;
			var ep = MetadataObject.ExtendedProperties[name];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		public void SetExtendedProperty(int index, string value, ExtendedPropertyType type = ExtendedPropertyType.String) {
			var name = MetadataObject.ExtendedProperties[index].Name;
			SetExtendedProperty(name, value, type);
		}
		public string GetNewExtendedPropertyName() {
			return MetadataObject.ExtendedProperties.GetNewName("New ExtendedProperty");
		}
		[IntelliSense("Sets the value of the ExtendedProperty having the given name. If no such ExtendedProperty exists, it will be created. If value is set to null, the ExtendedProperty will be removed.")]
		public void SetExtendedProperty(string name, string value, ExtendedPropertyType type = ExtendedPropertyType.String) {
			if(name == null) name = GetNewExtendedPropertyName();

			if(value == null) {
				// Remove ExtendedProperty if set to null:
				RemoveExtendedProperty(name);
				return;
			}

			if(GetExtendedProperty(name) == value) return;
			bool undoable = true;
			bool cancel = false;
			OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + value, ref undoable, ref cancel);
			if (cancel) return;

			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Change existing ExtendedProperty:
				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				var ep = MetadataObject.ExtendedProperties[name];
				if (ep is TOM.JsonExtendedProperty)
					(ep as TOM.JsonExtendedProperty).Value = value;
				else 
					(ep as TOM.StringExtendedProperty).Value = value;
					
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, name + ":" + value);
			} else {
				// Add new ExtendedProperty:
				if (type == ExtendedPropertyType.Json)
					MetadataObject.ExtendedProperties.Add(new TOM.JsonExtendedProperty{ Name = name, Value = value });
				else
					MetadataObject.ExtendedProperties.Add(new TOM.StringExtendedProperty{ Name = name, Value = value });

				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, null, type));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, null, name + ":" + value);
			}

		}
		[IntelliSense("Remove an ExtendedProperty by the given name.")]
		public void RemoveExtendedProperty(string name) {
			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Get current value:
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + GetExtendedProperty(name), ref undoable, ref cancel);
				if (cancel) return;

				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				MetadataObject.ExtendedProperties.Remove(name);

				// Undo-handling:
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, null, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, null);
			}
		}
		[IntelliSense("Gets the number of ExtendedProperties on the current object.")]
		public int GetExtendedPropertyCount() {
			return MetadataObject.ExtendedProperties.Count;
		}
		[IntelliSense("Gets a collection of all ExtendedProperty names on the current object.")]
		public IEnumerable<string> GetExtendedProperties() {
			return MetadataObject.ExtendedProperties.Select(a => a.Name);
		}

		/// <summary>
///             The position of the level within the hierarchy. The levels in the hierarchy must be properly ordered, starting with 1 and increasing monotonically.
///             </summary>
		[DisplayName("Ordinal")]
		[Category("Other"),Description(@"The position of the level within the hierarchy. The levels in the hierarchy must be properly ordered, starting with 1 and increasing monotonically."),IntelliSense(@"The position of the level within the hierarchy. The levels in the hierarchy must be properly ordered, starting with 1 and increasing monotonically.")][NoMultiselect()]
		public int Ordinal {
			get {
			    return MetadataObject.Ordinal;
			}
			set {
				
				var oldValue = Ordinal;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ORDINAL, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.Ordinal = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.ORDINAL, oldValue, newValue));
				OnPropertyChanged(Properties.ORDINAL, oldValue, newValue);
			}
		}
		private bool ShouldSerializeOrdinal() { return false; }
/// <summary>
///             The description of the level, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio.
///             </summary>
		[DisplayName("Description")]
		[Category("Basic"),Description(@"The description of the level, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio."),IntelliSense(@"The description of the level, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio.")][Editor(typeof(System.ComponentModel.Design.MultilineStringEditor), typeof(System.Drawing.Design.UITypeEditor))]
		public string Description {
			get {
			    return MetadataObject.Description;
			}
			set {
				
				var oldValue = Description;
				var newValue = value.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DESCRIPTION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.Description = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DESCRIPTION, oldValue, newValue));
				OnPropertyChanged(Properties.DESCRIPTION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeDescription() { return false; }
/// <summary>
///             A reference to a Hierarchy object that owns this level.
///             </summary>
		[DisplayName("Hierarchy")]
		[Category("Other"),Description(@"A reference to a Hierarchy object that owns this level."),IntelliSense(@"A reference to a Hierarchy object that owns this level.")][Browsable(false)]
		public Hierarchy Hierarchy {
			get {
				if (MetadataObject.Hierarchy == null) return null;
			    return Handler.WrapperLookup[MetadataObject.Hierarchy] as Hierarchy;
            }
			
		}
		private bool ShouldSerializeHierarchy() { return false; }
/// <summary>
///             A reference to a Column object associated with this Level.
///             </summary>
		[DisplayName("Column")]
		[Category("Other"),Description(@"A reference to a Column object associated with this Level."),IntelliSense(@"A reference to a Column object associated with this Level.")][TypeConverter(typeof(HierarchyColumnConverter)),NoMultiselect()]
		public Column Column {
			get {
				if (MetadataObject.Column == null) return null;
			    return Handler.WrapperLookup[MetadataObject.Column] as Column;
            }
			set {
				
				var oldValue = Column;
				var newValue = value;
				if (oldValue?.MetadataObject == newValue?.MetadataObject) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.COLUMN, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.Column = value == null ? null : Hierarchy.Table.Columns[value.MetadataObject.Name].MetadataObject;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.COLUMN, oldValue, newValue));
				OnPropertyChanged(Properties.COLUMN, oldValue, newValue);
			}
		}
		private bool ShouldSerializeColumn() { return false; }

        /// <summary>
        /// Collection of localized descriptions for this Level.
        /// </summary>
        [Browsable(true),DisplayName("Translated Descriptions"),Description("Shows all translated descriptions of this object."),Category("Translations and Perspectives")]
	    public TranslationIndexer TranslatedDescriptions { private set; get; }
        /// <summary>
        /// Collection of localized names for this Level.
        /// </summary>
        [Browsable(true),DisplayName("Translated Names"),Description("Shows all translated names of this object."),Category("Translations and Perspectives")]
	    public TranslationIndexer TranslatedNames { private set; get; }

		internal static Level CreateFromMetadata(Hierarchy parent, TOM.Level metadataObject) {
			var obj = new Level(metadataObject);
			parent.Levels.Add(obj);
			
			obj.Init();

			return obj;
		}


		/// <summary>
		/// Creates a new Level and adds it to the parent Hierarchy.
		/// Also creates the underlying metadataobject and adds it to the TOM tree.
		/// </summary>
		public static Level CreateNew(Hierarchy parent, string name = null)
		{
			if(TabularModelHandler.Singleton.UsePowerBIGovernance && !PowerBI.PowerBIGovernance.AllowCreate(typeof(Level))) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(Level).GetTypeName()));
			}

			var metadataObject = new TOM.Level();
			metadataObject.Name = parent.Levels.GetNewName(string.IsNullOrWhiteSpace(name) ? "New " + typeof(Level).GetTypeName() : name);

			var obj = new Level(metadataObject);

			parent.Levels.Add(obj);
			
			obj.Init();

			return obj;
		}


		/// <summary>
		/// Creates an exact copy of this Level object.
		/// </summary>
		public Level Clone(string newName = null, bool includeTranslations = true, Hierarchy newParent = null) {
			if(TabularModelHandler.Singleton.UsePowerBIGovernance && !PowerBI.PowerBIGovernance.AllowCreate(typeof(Level))) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(Level).GetTypeName()));
			}

		    Handler.BeginUpdate("Clone Level");

			// Create a clone of the underlying metadataobject:
			var tom = MetadataObject.Clone() as TOM.Level;


			// Assign a new, unique name:
			tom.Name = Parent.Levels.GetNewName(string.IsNullOrEmpty(newName) ? tom.Name + " copy" : newName);
				
			// Create the TOM Wrapper object, representing the metadataobject
			Level obj = CreateFromMetadata(newParent ?? Parent, tom);

			// Copy translations, if applicable:
			if(includeTranslations) {
				obj.CopyTranslationsFrom(this);
			}
            Handler.EndUpdate();

            return obj;
		}

		TabularNamedObject IClonableObject.Clone(string newName, bool includeTranslations, TabularNamedObject newParent) 
		{
			return Clone(newName, includeTranslations);
		}

	
        internal override void RenewMetadataObject()
        {
            Handler.WrapperLookup.Remove(MetadataObject);
            MetadataObject = MetadataObject.Clone() as TOM.Level;
            Handler.WrapperLookup.Add(MetadataObject, this);
        }

		public Hierarchy Parent { 
			get {
				return Handler.WrapperLookup[MetadataObject.Parent] as Hierarchy;
			}
		}



		/// <summary>
		/// CTOR - only called from static factory methods on the class
		/// </summary>
		Level(TOM.Level metadataObject) : base(metadataObject)
		{
			// Create indexers for translations:
			TranslatedNames = new TranslationIndexer(this, TOM.TranslatedProperty.Caption);
			TranslatedDescriptions = new TranslationIndexer(this, TOM.TranslatedProperty.Description);
			
			// Create indexer for annotations:
			Annotations = new AnnotationCollection(this);
			
			// Create indexer for extended properties:
			ExtendedProperties = new ExtendedPropertyCollection(this);
		}



		internal override void Undelete(ITabularObjectCollection collection) {
			base.Undelete(collection);
			Reinit();
			ReapplyReferences();
		}

		public override bool Browsable(string propertyName) {
			switch (propertyName) {
 
				case Properties.EXTENDEDPROPERTIES:
					return Handler.CompatibilityLevel >= 1400;
				case Properties.PARENT:
					return false;
				
				// Hides translation properties in the grid, unless the model actually contains translations:
				case Properties.TRANSLATEDNAMES:
				case Properties.TRANSLATEDDESCRIPTIONS:
					return Model.Cultures.Any();
				
				default:
					return base.Browsable(propertyName);
			}
		}

    }


	/// <summary>
	/// Collection class for Level. Provides convenient properties for setting a property on multiple objects at once.
	/// </summary>
	public sealed partial class LevelCollection: TabularObjectCollection<Level>
	{
		internal Hierarchy Hierarchy { get { return Parent as Hierarchy; } }
		TOM.LevelCollection TOM_Collection;
		internal LevelCollection(string collectionName, TOM.LevelCollection metadataObjectCollection, Hierarchy parent) : base(collectionName, parent)
		{
			TOM_Collection = metadataObjectCollection;
		}
		internal override Type GetItemType() { return typeof(Level); }
        protected override void TOM_Add(TOM.MetadataObject obj) { TOM_Collection.Add(obj as TOM.Level); }
        protected override bool TOM_Contains(TOM.MetadataObject obj) { return TOM_Collection.Contains(obj as TOM.Level); }
        protected override void TOM_Remove(TOM.MetadataObject obj) { TOM_Collection.Remove(obj as TOM.Level); }
        protected override void TOM_Clear() { TOM_Collection.Clear(); }
        protected override bool TOM_ContainsName(string name) { return TOM_Collection.ContainsName(name); }
        protected override TOM.MetadataObject TOM_Get(int index) { return TOM_Collection[index]; }
        protected override TOM.MetadataObject TOM_Get(string name) { return TOM_Collection[name]; }
        internal override string GetNewName(string prefix = null) { return string.IsNullOrEmpty(prefix) ? TOM_Collection.GetNewName() : TOM_Collection.GetNewName(prefix); }
        public override int IndexOf(TOM.MetadataObject obj) { return TOM_Collection.IndexOf(obj as TOM.Level); }
        public override int Count { get { return TOM_Collection.Count; } }
        public override IEnumerator<Level> GetEnumerator() { return TOM_Collection.Select(h => Handler.WrapperLookup[h]).OfType<Level>().GetEnumerator(); }
		internal override void Reinit() {
			var ixOffset = 0;
			for(int i = 0; i < Count; i++) {
				var item = this[i];
				Handler.WrapperLookup.Remove(item.MetadataObject);
				item.MetadataObject = Hierarchy.MetadataObject.Levels[i + ixOffset] as TOM.Level;
				Handler.WrapperLookup.Add(item.MetadataObject, item);
				item.Collection = this;
			}
			TOM_Collection = Hierarchy.MetadataObject.Levels;
			foreach(var item in this) item.Reinit();
		}

		internal override void ReapplyReferences() {
			foreach(var item in this) item.ReapplyReferences();
		}

		/// <summary>
		/// Calling this method will populate the LevelCollection with objects based on the MetadataObjects in the corresponding MetadataObjectCollection.
		/// </summary>
		internal override void CreateChildrenFromMetadata()
		{
			// Construct child objects (they are automatically added to the Handler's WrapperLookup dictionary):
			foreach(var obj in TOM_Collection) {
				if(obj is TOM.Level) Level.CreateFromMetadata(Hierarchy, obj as TOM.Level);
		    }
		}

		/// <summary>
		/// Sets the Description property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the Description property of all objects in the collection at once.")]
		public string Description {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("Description"));
				this.ToList().ForEach(item => { item.Description = value; });
				Handler.UndoManager.EndBatch();
			}
		}

		public override string ToString() {
			return string.Format("({0} {1})", Count, (Count == 1 ? "Level" : "Levels").ToLower());
		}
	}
  
	/// <summary>
///             Represents a value that is calculated based on an expression. It is a child of a Table object.
///             </summary>
	[TypeConverter(typeof(DynamicPropertyConverter))]
	public sealed partial class Measure: TabularNamedObject
			, IFolderObject
			, IHideableObject
			, IErrorMessageObject
			, ITabularTableObject
			, IDescriptionObject
			, IExpressionObject
			, IFormattableObject
			, IAnnotationObject
			, IExtendedPropertyObject
			, ITabularPerspectiveObject
			, ITranslatableObject
			, IClonableObject
	{
	    internal new TOM.Measure MetadataObject 
		{ 
			get 
			{ 
				return base.MetadataObject as TOM.Measure; 
		    } 
			set 
			{ 
				base.MetadataObject = value; 
			}
		}

        [Browsable(true),NoMultiselect,Category("Translations and Perspectives"),Description("The collection of Annotations on this object."),Editor(typeof(AnnotationCollectionEditor), typeof(UITypeEditor))]
		public AnnotationCollection Annotations { get; private set; }
		public string GetAnnotation(int index) {
			return MetadataObject.Annotations[index].Value;
		}
		[IntelliSense("Returns true if an annotation with the given name exists. Otherwise false.")]
		public bool HasAnnotation(string name) {
		    return MetadataObject.Annotations.ContainsName(name);
		}
		[IntelliSense("Gets the value of the annotation with the given name. Returns null if no such annotation exists.")]
		public string GetAnnotation(string name) {
		    return HasAnnotation(name) ? MetadataObject.Annotations[name].Value : null;
		}
		public void SetAnnotation(int index, string value, bool undoable = true) {
			var name = MetadataObject.Annotations[index].Name;
			SetAnnotation(name, value, undoable);
		}
		public string GetNewAnnotationName() {
			return MetadataObject.Annotations.GetNewName("New Annotation");
		}
		[IntelliSense("Sets the value of the annotation having the given name. If no such annotation exists, it will be created. If value is set to null, the annotation will be removed.")]
		public void SetAnnotation(string name, string value) {
		    SetAnnotation(name, value, true);
		}
		public void SetAnnotation(string name, string value, bool undoable) {
			if(name == null) name = GetNewAnnotationName();

			if(value == null) {
				// Remove annotation if set to null:
				RemoveAnnotation(name, undoable);
				return;
			}

			if(GetAnnotation(name) == value) return;
			bool undoable2 = true;
			bool cancel = false;
			OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + value, ref undoable2, ref cancel);
			if (cancel) return;

			if(MetadataObject.Annotations.Contains(name)) {
				// Change existing annotation:
				var oldValue = GetAnnotation(name);
				MetadataObject.Annotations[name].Value = value;
				if (undoable) Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, oldValue));
				OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, name + ":" + value);
			} else {
				// Add new annotation:
				MetadataObject.Annotations.Add(new TOM.Annotation{ Name = name, Value = value });
				if (undoable) Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, null));
				OnPropertyChanged(Properties.ANNOTATIONS, null, name + ":" + value);
			}

		}
		[IntelliSense("Remove an annotation by the given name.")]
		public void RemoveAnnotation(string name) {
		    RemoveAnnotation(name, true);
		}
		public void RemoveAnnotation(string name, bool undoable) {
			if(MetadataObject.Annotations.Contains(name)) {
				// Get current value:
				bool undoable2 = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + GetAnnotation(name), ref undoable2, ref cancel);
				if (cancel) return;

				var oldValue = MetadataObject.Annotations[name].Value;
				MetadataObject.Annotations.Remove(name);

				// Undo-handling:
				if (undoable) Handler.UndoManager.Add(new UndoAnnotationAction(this, name, null, oldValue));
				OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, null);
			}
		}
		[IntelliSense("Gets the number of annotations on the current object.")]
		public int GetAnnotationsCount() {
			return MetadataObject.Annotations.Count;
		}
		[IntelliSense("Gets a collection of all annotation names on the current object.")]
		public IEnumerable<string> GetAnnotations() {
			return MetadataObject.Annotations.Select(a => a.Name);
		}

		        [DisplayName("Extended Properties"),NoMultiselect,Category("Translations and Perspectives"),Description("The collection of Extended Properties on this object."),Editor(typeof(ExtendedPropertyCollectionEditor), typeof(UITypeEditor))]
		public ExtendedPropertyCollection ExtendedProperties { get; private set; }

		[IntelliSense("Returns true if an ExtendedProperty with the given name exists. Otherwise false.")]
		public bool HasExtendedProperty(string name) {
		    return MetadataObject.ExtendedProperties.ContainsName(name);
		}
		public ExtendedPropertyType GetExtendedPropertyType(int index) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[index].Type;
		}
		public ExtendedPropertyType GetExtendedPropertyType(string name) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[name].Type;
		}
		public string GetExtendedProperty(int index) {
			var ep = MetadataObject.ExtendedProperties[index];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		[IntelliSense("Gets the value of the ExtendedProperty with the given name. Returns null if no such ExtendedProperty exists.")]
		public string GetExtendedProperty(string name) {
		    if(!HasExtendedProperty(name)) return null;
			var ep = MetadataObject.ExtendedProperties[name];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		public void SetExtendedProperty(int index, string value, ExtendedPropertyType type = ExtendedPropertyType.String) {
			var name = MetadataObject.ExtendedProperties[index].Name;
			SetExtendedProperty(name, value, type);
		}
		public string GetNewExtendedPropertyName() {
			return MetadataObject.ExtendedProperties.GetNewName("New ExtendedProperty");
		}
		[IntelliSense("Sets the value of the ExtendedProperty having the given name. If no such ExtendedProperty exists, it will be created. If value is set to null, the ExtendedProperty will be removed.")]
		public void SetExtendedProperty(string name, string value, ExtendedPropertyType type = ExtendedPropertyType.String) {
			if(name == null) name = GetNewExtendedPropertyName();

			if(value == null) {
				// Remove ExtendedProperty if set to null:
				RemoveExtendedProperty(name);
				return;
			}

			if(GetExtendedProperty(name) == value) return;
			bool undoable = true;
			bool cancel = false;
			OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + value, ref undoable, ref cancel);
			if (cancel) return;

			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Change existing ExtendedProperty:
				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				var ep = MetadataObject.ExtendedProperties[name];
				if (ep is TOM.JsonExtendedProperty)
					(ep as TOM.JsonExtendedProperty).Value = value;
				else 
					(ep as TOM.StringExtendedProperty).Value = value;
					
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, name + ":" + value);
			} else {
				// Add new ExtendedProperty:
				if (type == ExtendedPropertyType.Json)
					MetadataObject.ExtendedProperties.Add(new TOM.JsonExtendedProperty{ Name = name, Value = value });
				else
					MetadataObject.ExtendedProperties.Add(new TOM.StringExtendedProperty{ Name = name, Value = value });

				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, null, type));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, null, name + ":" + value);
			}

		}
		[IntelliSense("Remove an ExtendedProperty by the given name.")]
		public void RemoveExtendedProperty(string name) {
			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Get current value:
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + GetExtendedProperty(name), ref undoable, ref cancel);
				if (cancel) return;

				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				MetadataObject.ExtendedProperties.Remove(name);

				// Undo-handling:
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, null, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, null);
			}
		}
		[IntelliSense("Gets the number of ExtendedProperties on the current object.")]
		public int GetExtendedPropertyCount() {
			return MetadataObject.ExtendedProperties.Count;
		}
		[IntelliSense("Gets a collection of all ExtendedProperty names on the current object.")]
		public IEnumerable<string> GetExtendedProperties() {
			return MetadataObject.ExtendedProperties.Select(a => a.Name);
		}

		/// <summary>
///             The description of the measure, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio.
///             </summary>
		[DisplayName("Description")]
		[Category("Basic"),Description(@"The description of the measure, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio."),IntelliSense(@"The description of the measure, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio.")][Editor(typeof(System.ComponentModel.Design.MultilineStringEditor), typeof(System.Drawing.Design.UITypeEditor))]
		public string Description {
			get {
			    return MetadataObject.Description;
			}
			set {
				
				var oldValue = Description;
				var newValue = value.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DESCRIPTION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.Description = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DESCRIPTION, oldValue, newValue));
				OnPropertyChanged(Properties.DESCRIPTION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeDescription() { return false; }
/// <summary>
///             Describes the type of data contained in the column. Possible values are as follows. String (2). Int64 (6). Double (8). DateTime (9). Decimal (10). Boolean (11). Binary (17). Unknown (19) A measure in an error state. Variant (20) A measure with varying data type.
///             </summary>
		[DisplayName("Data Type")]
		[Category("Metadata"),Description(@"Describes the type of data contained in the column. Possible values are as follows. String (2). Int64 (6). Double (8). DateTime (9). Decimal (10). Boolean (11). Binary (17). Unknown (19) A measure in an error state. Variant (20) A measure with varying data type."),IntelliSense(@"Describes the type of data contained in the column. Possible values are as follows. String (2). Int64 (6). Double (8). DateTime (9). Decimal (10). Boolean (11). Binary (17). Unknown (19) A measure in an error state. Variant (20) A measure with varying data type.")][TypeConverter(typeof(DataTypeEnumConverter))]
		public DataType DataType {
			get {
			    return (DataType)MetadataObject.DataType;
			}
			
		}
		private bool ShouldSerializeDataType() { return false; }
/// <summary>
///             The DAX expression that is evaluated for the calculated measure.
///             </summary>
		[DisplayName("Expression")]
		[Category("Options"),Description(@"The DAX expression that is evaluated for the calculated measure."),IntelliSense(@"The DAX expression that is evaluated for the calculated measure.")][Editor(typeof(System.ComponentModel.Design.MultilineStringEditor), typeof(System.Drawing.Design.UITypeEditor))]
		public string Expression {
			get {
			    return MetadataObject.Expression;
			}
			set {
				
				var oldValue = Expression;
				var newValue = value.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.EXPRESSION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.Expression = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.EXPRESSION, oldValue, newValue));
				OnPropertyChanged(Properties.EXPRESSION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeExpression() { return false; }
/// <summary>
///             A string that specifies the format of the measure contents. For 
///             </summary>
		[DisplayName("Format String")]
		[Category("Options"),Description(@"A string that specifies the format of the measure contents. For"),IntelliSense(@"A string that specifies the format of the measure contents. For")][TypeConverter(typeof(FormatStringConverter))]
		public string FormatString {
			get {
			    return MetadataObject.FormatString;
			}
			set {
				
				var oldValue = FormatString;
				var newValue = value.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.FORMATSTRING, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.FormatString = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.FORMATSTRING, oldValue, newValue));
				OnPropertyChanged(Properties.FORMATSTRING, oldValue, newValue);
			}
		}
		private bool ShouldSerializeFormatString() { return false; }
/// <summary>
///             A boolean value that indicates whether the measure is treated as hidden by client visualization tools. True if the measure is treated as hidden by client visualization tools; otherwise false.
///             </summary>
		[DisplayName("Hidden")]
		[Category("Basic"),Description(@"A boolean value that indicates whether the measure is treated as hidden by client visualization tools. True if the measure is treated as hidden by client visualization tools; otherwise false."),IntelliSense(@"A boolean value that indicates whether the measure is treated as hidden by client visualization tools. True if the measure is treated as hidden by client visualization tools; otherwise false.")]
		public bool IsHidden {
			get {
			    return MetadataObject.IsHidden;
			}
			set {
				
				var oldValue = IsHidden;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ISHIDDEN, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.IsHidden = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.ISHIDDEN, oldValue, newValue));
				OnPropertyChanged(Properties.ISHIDDEN, oldValue, newValue);
				Handler.UpdateObject(this);
			}
		}
		private bool ShouldSerializeIsHidden() { return false; }
/// <summary>
///             Provides information on the state of the measure. Possible values and their interpretation are as follows. Ready (1) The measure is queryable and has up-to-date data. NoData (3) Not applicable to Measure. CalculationNeeded (4) Not applicable to Measure. SemanticError (5) The measure expression has a semantic error. EvaluationError (6) Not applicable to Measure. DependencyError (7) A dependency associated with this measure is in an error state (SemanticError, EvaluationError, or DependencyError). Incomplete (8) Not applicable to Measure. SyntaxError (9) The measure has a syntax error in its expression.
///             </summary>
		[DisplayName("State")]
		[Category("Metadata"),Description(@"Provides information on the state of the measure. Possible values and their interpretation are as follows. Ready (1) The measure is queryable and has up-to-date data. NoData (3) Not applicable to Measure. CalculationNeeded (4) Not applicable to Measure. SemanticError (5) The measure expression has a semantic error. EvaluationError (6) Not applicable to Measure. DependencyError (7) A dependency associated with this measure is in an error state (SemanticError, EvaluationError, or DependencyError). Incomplete (8) Not applicable to Measure. SyntaxError (9) The measure has a syntax error in its expression."),IntelliSense(@"Provides information on the state of the measure. Possible values and their interpretation are as follows. Ready (1) The measure is queryable and has up-to-date data. NoData (3) Not applicable to Measure. CalculationNeeded (4) Not applicable to Measure. SemanticError (5) The measure expression has a semantic error. EvaluationError (6) Not applicable to Measure. DependencyError (7) A dependency associated with this measure is in an error state (SemanticError, EvaluationError, or DependencyError). Incomplete (8) Not applicable to Measure. SyntaxError (9) The measure has a syntax error in its expression.")]
		public ObjectState State {
			get {
			    return (ObjectState)MetadataObject.State;
			}
			
		}
		private bool ShouldSerializeState() { return false; }
/// <summary>
///             A boolean value that indicates whether the measure is an implicit measure that is automatically created by client tools to aggregate a field. Client applications can hide measures that have this flag set.
///             </summary>
		[DisplayName("Simple Measure")]
		[Category("Other"),Description(@"A boolean value that indicates whether the measure is an implicit measure that is automatically created by client tools to aggregate a field. Client applications can hide measures that have this flag set."),IntelliSense(@"A boolean value that indicates whether the measure is an implicit measure that is automatically created by client tools to aggregate a field. Client applications can hide measures that have this flag set.")][Browsable(false)]
		public bool IsSimpleMeasure {
			get {
			    return MetadataObject.IsSimpleMeasure;
			}
			set {
				
				var oldValue = IsSimpleMeasure;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ISSIMPLEMEASURE, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.IsSimpleMeasure = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.ISSIMPLEMEASURE, oldValue, newValue));
				OnPropertyChanged(Properties.ISSIMPLEMEASURE, oldValue, newValue);
			}
		}
		private bool ShouldSerializeIsSimpleMeasure() { return false; }
/// <summary>
///             The string that explains the error state associated with the current object. It is set by the engine only when the state of the object is one of these three values: SemanticError, DependencyError or EvaluationError.
///             </summary>
		[DisplayName("Error Message")]
		[Category("Metadata"),Description(@"The string that explains the error state associated with the current object. It is set by the engine only when the state of the object is one of these three values: SemanticError, DependencyError or EvaluationError."),IntelliSense(@"The string that explains the error state associated with the current object. It is set by the engine only when the state of the object is one of these three values: SemanticError, DependencyError or EvaluationError.")]
		public string ErrorMessage {
			get {
			    return MetadataObject.ErrorMessage;
			}
			
		}
		private bool ShouldSerializeErrorMessage() { return false; }
/// <summary>
///             Defines the display folder for the Measure, for use by clients.
///             </summary>
		[DisplayName("Display Folder")]
		[Category("Basic"),Description(@"Defines the display folder for the Measure, for use by clients."),IntelliSense(@"Defines the display folder for the Measure, for use by clients.")][Editor(typeof(CustomDialogEditor), typeof(System.Drawing.Design.UITypeEditor))]
		public string DisplayFolder {
			get {
			    return MetadataObject.DisplayFolder;
			}
			set {
				if(value.Contains(@"\\")) throw new Exception("Display Folder names cannot be blank.");
				var oldValue = DisplayFolder;
				var newValue = value.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DISPLAYFOLDER, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.DisplayFolder = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DISPLAYFOLDER, oldValue, newValue));
				OnPropertyChanged(Properties.DISPLAYFOLDER, oldValue, newValue);
				Handler.UpdateFolders(Table);
			}
		}
		private bool ShouldSerializeDisplayFolder() { return false; }
        /// <summary>
        /// Collection of localized Display Folders for this Measure.
        /// </summary>
        [Browsable(true),DisplayName("Translated Display Folders"),Description("Shows all translated Display Folders of this object."),Category("Translations and Perspectives")]
	    public TranslationIndexer TranslatedDisplayFolders { private set; get; }
/// <summary>
///             Specifies the type of data contained in the measure so that you can add custom behaviors based on measure type.
///             </summary><remarks>This property is only supported when the compatibility level of the database is at 1455 or above.</remarks>
		[DisplayName("Data Category")]
		[Category("Metadata"),Description(@"Specifies the type of data contained in the measure so that you can add custom behaviors based on measure type."),IntelliSense(@"Specifies the type of data contained in the measure so that you can add custom behaviors based on measure type.")]
		public string DataCategory {
			get {
			    return MetadataObject.DataCategory;
			}
			set {
				
				var oldValue = DataCategory;
				var newValue = value.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DATACATEGORY, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.DataCategory = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DATACATEGORY, oldValue, newValue));
				OnPropertyChanged(Properties.DATACATEGORY, oldValue, newValue);
			}
		}
		private bool ShouldSerializeDataCategory() { return false; }
		[Browsable(false)]
		public Table Table
		{ 
			get 
			{ 
				TabularObject t = null;
				if(MetadataObject == null || MetadataObject.Table == null) return null;
				if(!Handler.WrapperLookup.TryGetValue(MetadataObject.Table, out t)) {
				    t = Model.Tables[MetadataObject.Table.Name];
				}
				return t as Table;
			} 
		}

        /// <Summary>
		/// Collection of perspectives in which this Measure is visible.
		/// </Summary>
		[Browsable(true),DisplayName("Shown in Perspective"), Description("Provides an easy way to include or exclude this object from the perspectives of the model."), Category("Translations and Perspectives")]
        public PerspectiveMeasureIndexer InPerspective { get; private set; }
		PerspectiveIndexer ITabularPerspectiveObject.InPerspective { get { return this.InPerspective; } }
        /// <summary>
        /// Collection of localized descriptions for this Measure.
        /// </summary>
        [Browsable(true),DisplayName("Translated Descriptions"),Description("Shows all translated descriptions of this object."),Category("Translations and Perspectives")]
	    public TranslationIndexer TranslatedDescriptions { private set; get; }
        /// <summary>
        /// Collection of localized names for this Measure.
        /// </summary>
        [Browsable(true),DisplayName("Translated Names"),Description("Shows all translated names of this object."),Category("Translations and Perspectives")]
	    public TranslationIndexer TranslatedNames { private set; get; }

		internal static Measure CreateFromMetadata(Table parent, TOM.Measure metadataObject) {
			var obj = new Measure(metadataObject);
			parent.Measures.Add(obj);
			
			obj.Init();

			return obj;
		}


		/// <summary>
		/// Creates a new Measure and adds it to the parent Table.
		/// Also creates the underlying metadataobject and adds it to the TOM tree.
		/// </summary>
		public static Measure CreateNew(Table parent, string name = null)
		{
			if(TabularModelHandler.Singleton.UsePowerBIGovernance && !PowerBI.PowerBIGovernance.AllowCreate(typeof(Measure))) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(Measure).GetTypeName()));
			}

			var metadataObject = new TOM.Measure();
			metadataObject.Name = parent.Measures.GetNewName(string.IsNullOrWhiteSpace(name) ? "New " + typeof(Measure).GetTypeName() : name);

			var obj = new Measure(metadataObject);

			parent.Measures.Add(obj);
			
			obj.Init();

			return obj;
		}


		/// <summary>
		/// Creates an exact copy of this Measure object.
		/// </summary>
		public Measure Clone(string newName = null, bool includeTranslations = true, Table newParent = null) {
			if(TabularModelHandler.Singleton.UsePowerBIGovernance && !PowerBI.PowerBIGovernance.AllowCreate(typeof(Measure))) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(Measure).GetTypeName()));
			}

		    Handler.BeginUpdate("Clone Measure");

			// Create a clone of the underlying metadataobject:
			var tom = MetadataObject.Clone() as TOM.Measure;


			// Assign a new, unique name:
			tom.Name = Parent.Measures.GetNewName(string.IsNullOrEmpty(newName) ? tom.Name + " copy" : newName);
				
			// Create the TOM Wrapper object, representing the metadataobject
			Measure obj = CreateFromMetadata(newParent ?? Parent, tom);

			// Copy translations, if applicable:
			if(includeTranslations) {
				obj.CopyTranslationsFrom(this);
			}
				
			// Copy perspectives:
			obj.InPerspective.CopyFrom(InPerspective);

			// TODO: Make sure that dependency trees are properly rebuilt when IDaxDependantObjects are cloned
			// FormulaFixup.BuildDependencyTree(this);
            Handler.EndUpdate();

            return obj;
		}

		TabularNamedObject IClonableObject.Clone(string newName, bool includeTranslations, TabularNamedObject newParent) 
		{
			return Clone(newName, includeTranslations);
		}

	
        internal override void RenewMetadataObject()
        {
            Handler.WrapperLookup.Remove(MetadataObject);
            MetadataObject = MetadataObject.Clone() as TOM.Measure;
            Handler.WrapperLookup.Add(MetadataObject, this);
        }

		public Table Parent { 
			get {
				return Handler.WrapperLookup[MetadataObject.Parent] as Table;
			}
		}



		/// <summary>
		/// CTOR - only called from static factory methods on the class
		/// </summary>
		Measure(TOM.Measure metadataObject) : base(metadataObject)
		{
			// Create indexers for translations:
			TranslatedNames = new TranslationIndexer(this, TOM.TranslatedProperty.Caption);
			TranslatedDescriptions = new TranslationIndexer(this, TOM.TranslatedProperty.Description);
			TranslatedDisplayFolders = new TranslationIndexer(this, TOM.TranslatedProperty.DisplayFolder);

			// Create indexer for perspectives:
			InPerspective = new PerspectiveMeasureIndexer(this);
			
			// Create indexer for annotations:
			Annotations = new AnnotationCollection(this);
			
			// Create indexer for extended properties:
			ExtendedProperties = new ExtendedPropertyCollection(this);
		}



		internal override void Undelete(ITabularObjectCollection collection) {
			base.Undelete(collection);
			Reinit();
			ReapplyReferences();
		}

		public override bool Browsable(string propertyName) {
			switch (propertyName) {
 
				case Properties.EXTENDEDPROPERTIES:
					return Handler.CompatibilityLevel >= 1400;
				case Properties.PARENT:
					return false;
				
				// Hides translation properties in the grid, unless the model actually contains translations:
				case Properties.TRANSLATEDNAMES:
				case Properties.TRANSLATEDDESCRIPTIONS:
				case Properties.TRANSLATEDDISPLAYFOLDERS:
					return Model.Cultures.Any();
				
				// Hides the perspective property in the grid, unless the model actually contains perspectives:
				case Properties.INPERSPECTIVE:
					return Model.Perspectives.Any();
				
				default:
					return base.Browsable(propertyName);
			}
		}

    }


	/// <summary>
	/// Collection class for Measure. Provides convenient properties for setting a property on multiple objects at once.
	/// </summary>
	public sealed partial class MeasureCollection: TabularObjectCollection<Measure>
	{
		internal Table Table { get { return Parent as Table; } }
		TOM.MeasureCollection TOM_Collection;
		internal MeasureCollection(string collectionName, TOM.MeasureCollection metadataObjectCollection, Table parent) : base(collectionName, parent)
		{
			TOM_Collection = metadataObjectCollection;
		}
		internal override Type GetItemType() { return typeof(Measure); }
        protected override void TOM_Add(TOM.MetadataObject obj) { TOM_Collection.Add(obj as TOM.Measure); }
        protected override bool TOM_Contains(TOM.MetadataObject obj) { return TOM_Collection.Contains(obj as TOM.Measure); }
        protected override void TOM_Remove(TOM.MetadataObject obj) { TOM_Collection.Remove(obj as TOM.Measure); }
        protected override void TOM_Clear() { TOM_Collection.Clear(); }
        protected override bool TOM_ContainsName(string name) { return TOM_Collection.ContainsName(name); }
        protected override TOM.MetadataObject TOM_Get(int index) { return TOM_Collection[index]; }
        protected override TOM.MetadataObject TOM_Get(string name) { return TOM_Collection[name]; }
        public override int IndexOf(TOM.MetadataObject obj) { return TOM_Collection.IndexOf(obj as TOM.Measure); }
        public override int Count { get { return TOM_Collection.Count; } }
        public override IEnumerator<Measure> GetEnumerator() { return TOM_Collection.Select(h => Handler.WrapperLookup[h]).OfType<Measure>().GetEnumerator(); }
		internal override void Reinit() {
			var ixOffset = 0;
			for(int i = 0; i < Count; i++) {
				var item = this[i];
				Handler.WrapperLookup.Remove(item.MetadataObject);
				item.MetadataObject = Table.MetadataObject.Measures[i + ixOffset] as TOM.Measure;
				Handler.WrapperLookup.Add(item.MetadataObject, item);
				item.Collection = this;
			}
			TOM_Collection = Table.MetadataObject.Measures;
			foreach(var item in this) item.Reinit();
		}

		internal override void ReapplyReferences() {
			foreach(var item in this) item.ReapplyReferences();
		}

		/// <summary>
		/// Calling this method will populate the MeasureCollection with objects based on the MetadataObjects in the corresponding MetadataObjectCollection.
		/// </summary>
		internal override void CreateChildrenFromMetadata()
		{
			// Construct child objects (they are automatically added to the Handler's WrapperLookup dictionary):
			foreach(var obj in TOM_Collection) {
				if(obj is TOM.Measure) Measure.CreateFromMetadata(Table, obj as TOM.Measure);
		    }
		}

		/// <summary>
		/// Sets the Description property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the Description property of all objects in the collection at once.")]
		public string Description {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("Description"));
				this.ToList().ForEach(item => { item.Description = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the Expression property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the Expression property of all objects in the collection at once.")]
		public string Expression {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("Expression"));
				this.ToList().ForEach(item => { item.Expression = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the FormatString property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the FormatString property of all objects in the collection at once.")]
		public string FormatString {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("FormatString"));
				this.ToList().ForEach(item => { item.FormatString = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the IsHidden property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the IsHidden property of all objects in the collection at once.")]
		public bool IsHidden {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("IsHidden"));
				this.ToList().ForEach(item => { item.IsHidden = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the IsSimpleMeasure property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the IsSimpleMeasure property of all objects in the collection at once.")]
		public bool IsSimpleMeasure {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("IsSimpleMeasure"));
				this.ToList().ForEach(item => { item.IsSimpleMeasure = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the DisplayFolder property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the DisplayFolder property of all objects in the collection at once.")]
		public string DisplayFolder {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("DisplayFolder"));
				this.ToList().ForEach(item => { item.DisplayFolder = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the DataCategory property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the DataCategory property of all objects in the collection at once.")]
		public string DataCategory {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("DataCategory"));
				this.ToList().ForEach(item => { item.DataCategory = value; });
				Handler.UndoManager.EndBatch();
			}
		}

		public override string ToString() {
			return string.Format("({0} {1})", Count, (Count == 1 ? "Measure" : "Measures").ToLower());
		}
	}
  
	/// <summary>
///             A Tabular model created at compatibility level 1200 or above.
///             </summary>
	[TypeConverter(typeof(DynamicPropertyConverter))]
	public sealed partial class Model: TabularNamedObject
			, IDescriptionObject
			, IAnnotationObject
			, IExtendedPropertyObject
			, ITranslatableObject
	{
	    internal new TOM.Model MetadataObject 
		{ 
			get 
			{ 
				return base.MetadataObject as TOM.Model; 
		    } 
			set 
			{ 
				base.MetadataObject = value; 
			}
		}

/// <summary> 
///             Returns the status of local changes made to the model, which haven't been saved to the server.  
///             <para>If the model is not connected, this value is always <b>False</b>.</para></summary>
		[DisplayName("Has Local Changes")]
		[Category("Other"),Description(@"Returns the status of local changes made to the model, which haven't been saved to the server.  
            <para>If the model is not connected, this value is always <b>False</b>.</para>"),IntelliSense(@"Returns the status of local changes made to the model, which haven't been saved to the server.  
            <para>If the model is not connected, this value is always <b>False</b>.</para>")]
		public bool HasLocalChanges {
			get {
			    return MetadataObject.HasLocalChanges;
			}
			
		}
		private bool ShouldSerializeHasLocalChanges() { return false; }
        [Browsable(true),NoMultiselect,Category("Translations and Perspectives"),Description("The collection of Annotations on this object."),Editor(typeof(AnnotationCollectionEditor), typeof(UITypeEditor))]
		public AnnotationCollection Annotations { get; private set; }
		public string GetAnnotation(int index) {
			return MetadataObject.Annotations[index].Value;
		}
		[IntelliSense("Returns true if an annotation with the given name exists. Otherwise false.")]
		public bool HasAnnotation(string name) {
		    return MetadataObject.Annotations.ContainsName(name);
		}
		[IntelliSense("Gets the value of the annotation with the given name. Returns null if no such annotation exists.")]
		public string GetAnnotation(string name) {
		    return HasAnnotation(name) ? MetadataObject.Annotations[name].Value : null;
		}
		public void SetAnnotation(int index, string value, bool undoable = true) {
			var name = MetadataObject.Annotations[index].Name;
			SetAnnotation(name, value, undoable);
		}
		public string GetNewAnnotationName() {
			return MetadataObject.Annotations.GetNewName("New Annotation");
		}
		[IntelliSense("Sets the value of the annotation having the given name. If no such annotation exists, it will be created. If value is set to null, the annotation will be removed.")]
		public void SetAnnotation(string name, string value) {
		    SetAnnotation(name, value, true);
		}
		public void SetAnnotation(string name, string value, bool undoable) {
			if(name == null) name = GetNewAnnotationName();

			if(value == null) {
				// Remove annotation if set to null:
				RemoveAnnotation(name, undoable);
				return;
			}

			if(GetAnnotation(name) == value) return;
			bool undoable2 = true;
			bool cancel = false;
			OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + value, ref undoable2, ref cancel);
			if (cancel) return;

			if(MetadataObject.Annotations.Contains(name)) {
				// Change existing annotation:
				var oldValue = GetAnnotation(name);
				MetadataObject.Annotations[name].Value = value;
				if (undoable) Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, oldValue));
				OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, name + ":" + value);
			} else {
				// Add new annotation:
				MetadataObject.Annotations.Add(new TOM.Annotation{ Name = name, Value = value });
				if (undoable) Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, null));
				OnPropertyChanged(Properties.ANNOTATIONS, null, name + ":" + value);
			}

		}
		[IntelliSense("Remove an annotation by the given name.")]
		public void RemoveAnnotation(string name) {
		    RemoveAnnotation(name, true);
		}
		public void RemoveAnnotation(string name, bool undoable) {
			if(MetadataObject.Annotations.Contains(name)) {
				// Get current value:
				bool undoable2 = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + GetAnnotation(name), ref undoable2, ref cancel);
				if (cancel) return;

				var oldValue = MetadataObject.Annotations[name].Value;
				MetadataObject.Annotations.Remove(name);

				// Undo-handling:
				if (undoable) Handler.UndoManager.Add(new UndoAnnotationAction(this, name, null, oldValue));
				OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, null);
			}
		}
		[IntelliSense("Gets the number of annotations on the current object.")]
		public int GetAnnotationsCount() {
			return MetadataObject.Annotations.Count;
		}
		[IntelliSense("Gets a collection of all annotation names on the current object.")]
		public IEnumerable<string> GetAnnotations() {
			return MetadataObject.Annotations.Select(a => a.Name);
		}

		        [DisplayName("Extended Properties"),NoMultiselect,Category("Translations and Perspectives"),Description("The collection of Extended Properties on this object."),Editor(typeof(ExtendedPropertyCollectionEditor), typeof(UITypeEditor))]
		public ExtendedPropertyCollection ExtendedProperties { get; private set; }

		[IntelliSense("Returns true if an ExtendedProperty with the given name exists. Otherwise false.")]
		public bool HasExtendedProperty(string name) {
		    return MetadataObject.ExtendedProperties.ContainsName(name);
		}
		public ExtendedPropertyType GetExtendedPropertyType(int index) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[index].Type;
		}
		public ExtendedPropertyType GetExtendedPropertyType(string name) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[name].Type;
		}
		public string GetExtendedProperty(int index) {
			var ep = MetadataObject.ExtendedProperties[index];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		[IntelliSense("Gets the value of the ExtendedProperty with the given name. Returns null if no such ExtendedProperty exists.")]
		public string GetExtendedProperty(string name) {
		    if(!HasExtendedProperty(name)) return null;
			var ep = MetadataObject.ExtendedProperties[name];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		public void SetExtendedProperty(int index, string value, ExtendedPropertyType type = ExtendedPropertyType.String) {
			var name = MetadataObject.ExtendedProperties[index].Name;
			SetExtendedProperty(name, value, type);
		}
		public string GetNewExtendedPropertyName() {
			return MetadataObject.ExtendedProperties.GetNewName("New ExtendedProperty");
		}
		[IntelliSense("Sets the value of the ExtendedProperty having the given name. If no such ExtendedProperty exists, it will be created. If value is set to null, the ExtendedProperty will be removed.")]
		public void SetExtendedProperty(string name, string value, ExtendedPropertyType type = ExtendedPropertyType.String) {
			if(name == null) name = GetNewExtendedPropertyName();

			if(value == null) {
				// Remove ExtendedProperty if set to null:
				RemoveExtendedProperty(name);
				return;
			}

			if(GetExtendedProperty(name) == value) return;
			bool undoable = true;
			bool cancel = false;
			OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + value, ref undoable, ref cancel);
			if (cancel) return;

			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Change existing ExtendedProperty:
				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				var ep = MetadataObject.ExtendedProperties[name];
				if (ep is TOM.JsonExtendedProperty)
					(ep as TOM.JsonExtendedProperty).Value = value;
				else 
					(ep as TOM.StringExtendedProperty).Value = value;
					
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, name + ":" + value);
			} else {
				// Add new ExtendedProperty:
				if (type == ExtendedPropertyType.Json)
					MetadataObject.ExtendedProperties.Add(new TOM.JsonExtendedProperty{ Name = name, Value = value });
				else
					MetadataObject.ExtendedProperties.Add(new TOM.StringExtendedProperty{ Name = name, Value = value });

				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, null, type));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, null, name + ":" + value);
			}

		}
		[IntelliSense("Remove an ExtendedProperty by the given name.")]
		public void RemoveExtendedProperty(string name) {
			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Get current value:
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + GetExtendedProperty(name), ref undoable, ref cancel);
				if (cancel) return;

				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				MetadataObject.ExtendedProperties.Remove(name);

				// Undo-handling:
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, null, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, null);
			}
		}
		[IntelliSense("Gets the number of ExtendedProperties on the current object.")]
		public int GetExtendedPropertyCount() {
			return MetadataObject.ExtendedProperties.Count;
		}
		[IntelliSense("Gets a collection of all ExtendedProperty names on the current object.")]
		public IEnumerable<string> GetExtendedProperties() {
			return MetadataObject.ExtendedProperties.Select(a => a.Name);
		}

		/// <summary>
///             The description of the model, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio.
///             </summary>
		[DisplayName("Description")]
		[Category("Basic"),Description(@"The description of the model, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio."),IntelliSense(@"The description of the model, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio.")][Editor(typeof(System.ComponentModel.Design.MultilineStringEditor), typeof(System.Drawing.Design.UITypeEditor))]
		public string Description {
			get {
			    return MetadataObject.Description;
			}
			set {
				
				var oldValue = Description;
				var newValue = value.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DESCRIPTION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.Description = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DESCRIPTION, oldValue, newValue));
				OnPropertyChanged(Properties.DESCRIPTION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeDescription() { return false; }
/// <summary>
///             The location on disk to place the model.
///             </summary>
		[DisplayName("Storage Location")]
		[Category("Other"),Description(@"The location on disk to place the model."),IntelliSense(@"The location on disk to place the model.")]
		public string StorageLocation {
			get {
			    return MetadataObject.StorageLocation;
			}
			set {
				
				var oldValue = StorageLocation;
				var newValue = value.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.STORAGELOCATION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.StorageLocation = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.STORAGELOCATION, oldValue, newValue));
				OnPropertyChanged(Properties.STORAGELOCATION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeStorageLocation() { return false; }
/// <summary>
///             The default method for making data available in the partition.
///             </summary>
		[DisplayName("Default Mode")]
		[Category("Other"),Description(@"The default method for making data available in the partition."),IntelliSense(@"The default method for making data available in the partition.")]
		public ModeType DefaultMode {
			get {
			    return (ModeType)MetadataObject.DefaultMode;
			}
			set {
				
				var oldValue = DefaultMode;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DEFAULTMODE, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.DefaultMode = (TOM.ModeType)newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DEFAULTMODE, oldValue, newValue));
				OnPropertyChanged(Properties.DEFAULTMODE, oldValue, newValue);
			}
		}
		private bool ShouldSerializeDefaultMode() { return false; }
/// <summary>
///             Used by partitions in the model to determine the type of query that retrieves data. A Full dataview retrieves an unfiltered rowset, used for in-memory models and deployed DirectQuery models. A Sample data view is a subset of data used during DirectQuery model design.
///             </summary>
		[DisplayName("Default Data View")]
		[Category("Other"),Description(@"Used by partitions in the model to determine the type of query that retrieves data. A Full dataview retrieves an unfiltered rowset, used for in-memory models and deployed DirectQuery models. A Sample data view is a subset of data used during DirectQuery model design."),IntelliSense(@"Used by partitions in the model to determine the type of query that retrieves data. A Full dataview retrieves an unfiltered rowset, used for in-memory models and deployed DirectQuery models. A Sample data view is a subset of data used during DirectQuery model design.")]
		public DataViewType DefaultDataView {
			get {
			    return (DataViewType)MetadataObject.DefaultDataView;
			}
			set {
				
				var oldValue = DefaultDataView;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DEFAULTDATAVIEW, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.DefaultDataView = (TOM.DataViewType)newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DEFAULTDATAVIEW, oldValue, newValue));
				OnPropertyChanged(Properties.DEFAULTDATAVIEW, oldValue, newValue);
			}
		}
		private bool ShouldSerializeDefaultDataView() { return false; }
/// <summary>
///             The name of the Culture used for formatting. Once it's used by a child object, this value can't be changed.
///             </summary>
		[DisplayName("Culture")]
		[Category("Other"),Description(@"The name of the Culture used for formatting. Once it's used by a child object, this value can't be changed."),IntelliSense(@"The name of the Culture used for formatting. Once it's used by a child object, this value can't be changed.")][TypeConverter(typeof(CultureConverter))]
		public string Culture {
			get {
			    return MetadataObject.Culture;
			}
			set {
				
				var oldValue = Culture;
				var newValue = value.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.CULTURE, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.Culture = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.CULTURE, oldValue, newValue));
				OnPropertyChanged(Properties.CULTURE, oldValue, newValue);
			}
		}
		private bool ShouldSerializeCulture() { return false; }
/// <summary>
///             The collation sequence. Analysis Services uses Windows collations.
///             </summary>
		[DisplayName("Collation")]
		[Category("Other"),Description(@"The collation sequence. Analysis Services uses Windows collations."),IntelliSense(@"The collation sequence. Analysis Services uses Windows collations.")]
		public string Collation {
			get {
			    return MetadataObject.Collation;
			}
			set {
				
				var oldValue = Collation;
				var newValue = value.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.COLLATION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.Collation = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.COLLATION, oldValue, newValue));
				OnPropertyChanged(Properties.COLLATION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeCollation() { return false; }
/// <summary>
///             Determines whether measures can have the same names as any column in the model.
///             </summary><remarks>This property is only supported when the compatibility level of the database is at 1465 or above.</remarks>
		[DisplayName("Force Unique Names")]
		[Category("Other"),Description(@"Determines whether measures can have the same names as any column in the model."),IntelliSense(@"Determines whether measures can have the same names as any column in the model.")]
		public bool ForceUniqueNames {
			get {
			    return MetadataObject.ForceUniqueNames;
			}
			set {
				
				var oldValue = ForceUniqueNames;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.FORCEUNIQUENAMES, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.ForceUniqueNames = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.FORCEUNIQUENAMES, oldValue, newValue));
				OnPropertyChanged(Properties.FORCEUNIQUENAMES, oldValue, newValue);
			}
		}
		private bool ShouldSerializeForceUniqueNames() { return false; }

		[DisplayName("Discourage Implicit Measures")]
		[Category("Other"),Description(@"The DiscourageImplicitMeasures of this Model"),IntelliSense(@"The DiscourageImplicitMeasures of this Model")]
		public bool DiscourageImplicitMeasures {
			get {
			    return MetadataObject.DiscourageImplicitMeasures;
			}
			set {
				
				var oldValue = DiscourageImplicitMeasures;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DISCOURAGEIMPLICITMEASURES, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.DiscourageImplicitMeasures = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DISCOURAGEIMPLICITMEASURES, oldValue, newValue));
				OnPropertyChanged(Properties.DISCOURAGEIMPLICITMEASURES, oldValue, newValue);
			}
		}
		private bool ShouldSerializeDiscourageImplicitMeasures() { return false; }

		[DisplayName("Discourage Report Measures")]
		[Category("Other"),Description(@"The DiscourageReportMeasures of this Model"),IntelliSense(@"The DiscourageReportMeasures of this Model")]
		public bool DiscourageReportMeasures {
			get {
			    return MetadataObject.DiscourageReportMeasures;
			}
			set {
				
				var oldValue = DiscourageReportMeasures;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DISCOURAGEREPORTMEASURES, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.DiscourageReportMeasures = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DISCOURAGEREPORTMEASURES, oldValue, newValue));
				OnPropertyChanged(Properties.DISCOURAGEREPORTMEASURES, oldValue, newValue);
			}
		}
		private bool ShouldSerializeDiscourageReportMeasures() { return false; }
/// <summary>
///             A reference to a default measure.
///             </summary><remarks>This property is only supported when the compatibility level of the database is at 1400 or above.</remarks>
		[DisplayName("Default Measure")]
		[Category("Other"),Description(@"A reference to a default measure."),IntelliSense(@"A reference to a default measure.")]
		public Measure DefaultMeasure {
			get {
				if (MetadataObject.DefaultMeasure == null) return null;
			    return Handler.WrapperLookup[MetadataObject.DefaultMeasure] as Measure;
            }
			set {
				
				var oldValue = DefaultMeasure;
				var newValue = value;
				if (oldValue?.MetadataObject == newValue?.MetadataObject) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DEFAULTMEASURE, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.DefaultMeasure = value?.MetadataObject;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DEFAULTMEASURE, oldValue, newValue));
				OnPropertyChanged(Properties.DEFAULTMEASURE, oldValue, newValue);
			}
		}
		private bool ShouldSerializeDefaultMeasure() { return false; }

        /// <summary>
        /// Collection of localized descriptions for this Model.
        /// </summary>
        [Browsable(true),DisplayName("Translated Descriptions"),Description("Shows all translated descriptions of this object."),Category("Translations and Perspectives")]
	    public TranslationIndexer TranslatedDescriptions { private set; get; }
        /// <summary>
        /// Collection of localized names for this Model.
        /// </summary>
        [Browsable(true),DisplayName("Translated Names"),Description("Shows all translated names of this object."),Category("Translations and Perspectives")]
	    public TranslationIndexer TranslatedNames { private set; get; }

	
        internal override void RenewMetadataObject()
        {
            Handler.WrapperLookup.Remove(MetadataObject);
            MetadataObject = MetadataObject.Clone() as TOM.Model;
            Handler.WrapperLookup.Add(MetadataObject, this);
        }


        internal override ITabularObjectCollection GetCollectionForChild(TabularObject child)
        {
			if (child is Perspective) return Perspectives;
			if (child is Culture) return Cultures;
			if (child is DataSource) return DataSources;
			if (child is ModelRole) return Roles;
			if (child is Table) return Tables;
			if (child is Relationship) return Relationships;
			if (child is NamedExpression) return Expressions;
            return base.GetCollectionForChild(child);
        }

        /// <summary>
        /// The collection of Perspective objects on this Model.
        /// </summary>
		[DisplayName("Perspectives")]
		[Category("Translations and Perspectives"),IntelliSense("The collection of Perspective objects on this Model.")][Editor(typeof(TabularEditor.PropertyGridUI.ClonableObjectCollectionEditor<Perspective>),typeof(UITypeEditor)),TypeConverter(typeof(StringConverter))]
		public PerspectiveCollection Perspectives { get; private set; }
        /// <summary>
        /// The collection of Culture objects on this Model.
        /// </summary>
		[DisplayName("Cultures")]
		[Category("Translations and Perspectives"),IntelliSense("The collection of Culture objects on this Model.")][Editor(typeof(TabularEditor.PropertyGridUI.CultureCollectionEditor),typeof(UITypeEditor)),TypeConverter(typeof(StringConverter))]
		public CultureCollection Cultures { get; private set; }
        /// <summary>
        /// The collection of DataSource objects on this Model.
        /// </summary>
		[DisplayName("Data Sources")]
		[Category("Other"),IntelliSense("The collection of Data Source objects on this Model.")][Browsable(false)]
		public DataSourceCollection DataSources { get; private set; }
        /// <summary>
        /// The collection of ModelRole objects on this Model.
        /// </summary>
		[DisplayName("Roles")]
		[Category("Security"),IntelliSense("The collection of Model Role objects on this Model.")][Editor(typeof(TabularEditor.PropertyGridUI.ClonableObjectCollectionEditor<ModelRole>), typeof(UITypeEditor)), TypeConverter(typeof(StringConverter))]
		public ModelRoleCollection Roles { get; private set; }
        /// <summary>
        /// The collection of Table objects on this Model.
        /// </summary>
		[DisplayName("Tables")]
		[Category("Other"),IntelliSense("The collection of Table objects on this Model.")][Browsable(false)]
		public TableCollection Tables { get; private set; }
        /// <summary>
        /// The collection of Relationship objects on this Model.
        /// </summary>
		[DisplayName("Relationships")]
		[Category("Other"),IntelliSense("The collection of Relationship objects on this Model.")][Browsable(false)]
		public RelationshipCollection Relationships { get; private set; }
        /// <summary>
        /// The collection of NamedExpression objects on this Model.
        /// </summary>
		[DisplayName("Expressions")]
		[Category("Other"),IntelliSense("The collection of Named Expression objects on this Model.")][Editor(typeof(TabularEditor.PropertyGridUI.ClonableObjectCollectionEditor<NamedExpression>), typeof(UITypeEditor)), TypeConverter(typeof(StringConverter))]
		public NamedExpressionCollection Expressions { get; private set; }

		/// <summary>
		/// CTOR - only called from static factory methods on the class
		/// </summary>
		Model(TOM.Model metadataObject) : base(metadataObject)
		{
			// Create indexers for translations:
			TranslatedNames = new TranslationIndexer(this, TOM.TranslatedProperty.Caption);
			TranslatedDescriptions = new TranslationIndexer(this, TOM.TranslatedProperty.Description);
			
			// Create indexer for annotations:
			Annotations = new AnnotationCollection(this);
			
			// Create indexer for extended properties:
			ExtendedProperties = new ExtendedPropertyCollection(this);
			
			// Instantiate child collections:
			Perspectives = new PerspectiveCollection(this.GetObjectPath() + ".Perspectives", MetadataObject.Perspectives, this);
			Cultures = new CultureCollection(this.GetObjectPath() + ".Cultures", MetadataObject.Cultures, this);
			DataSources = new DataSourceCollection(this.GetObjectPath() + ".DataSources", MetadataObject.DataSources, this);
			Roles = new ModelRoleCollection(this.GetObjectPath() + ".Roles", MetadataObject.Roles, this);
			Tables = new TableCollection(this.GetObjectPath() + ".Tables", MetadataObject.Tables, this);
			Relationships = new RelationshipCollection(this.GetObjectPath() + ".Relationships", MetadataObject.Relationships, this);
			Expressions = new NamedExpressionCollection(this.GetObjectPath() + ".Expressions", MetadataObject.Expressions, this);

			// Populate child collections:
			Perspectives.CreateChildrenFromMetadata();
			Cultures.CreateChildrenFromMetadata();
			DataSources.CreateChildrenFromMetadata();
			Roles.CreateChildrenFromMetadata();
			Tables.CreateChildrenFromMetadata();
			Relationships.CreateChildrenFromMetadata();
			Expressions.CreateChildrenFromMetadata();

			// Hook up event handlers on child collections:
			Perspectives.CollectionChanged += Children_CollectionChanged;
			Cultures.CollectionChanged += Children_CollectionChanged;
			DataSources.CollectionChanged += Children_CollectionChanged;
			Roles.CollectionChanged += Children_CollectionChanged;
			Tables.CollectionChanged += Children_CollectionChanged;
			Relationships.CollectionChanged += Children_CollectionChanged;
			Expressions.CollectionChanged += Children_CollectionChanged;
		}


		internal override void Reinit() {
			Perspectives.Reinit();
			Cultures.Reinit();
			DataSources.Reinit();
			Roles.Reinit();
			Tables.Reinit();
			Relationships.Reinit();
			Expressions.Reinit();
		}

		internal override void Undelete(ITabularObjectCollection collection) {
			base.Undelete(collection);
			Reinit();
			ReapplyReferences();
		}

		public override bool Browsable(string propertyName) {
			switch (propertyName) {
 
				case Properties.EXTENDEDPROPERTIES:
					return Handler.CompatibilityLevel >= 1400;
				
				// Hides translation properties in the grid, unless the model actually contains translations:
				case Properties.TRANSLATEDNAMES:
				case Properties.TRANSLATEDDESCRIPTIONS:
					return Model.Cultures.Any();
				
				default:
					return base.Browsable(propertyName);
			}
		}

    }

  
	/// <summary>
///             Defines a set of user principals for whom security rules are applied. It is a child of a Model object.
///             </summary>
	[TypeConverter(typeof(DynamicPropertyConverter))]
	public sealed partial class ModelRole: TabularNamedObject
			, IDescriptionObject
			, IAnnotationObject
			, IExtendedPropertyObject
			, IClonableObject
	{
	    internal new TOM.ModelRole MetadataObject 
		{ 
			get 
			{ 
				return base.MetadataObject as TOM.ModelRole; 
		    } 
			set 
			{ 
				base.MetadataObject = value; 
			}
		}

        [Browsable(true),NoMultiselect,Category("Translations and Perspectives"),Description("The collection of Annotations on this object."),Editor(typeof(AnnotationCollectionEditor), typeof(UITypeEditor))]
		public AnnotationCollection Annotations { get; private set; }
		public string GetAnnotation(int index) {
			return MetadataObject.Annotations[index].Value;
		}
		[IntelliSense("Returns true if an annotation with the given name exists. Otherwise false.")]
		public bool HasAnnotation(string name) {
		    return MetadataObject.Annotations.ContainsName(name);
		}
		[IntelliSense("Gets the value of the annotation with the given name. Returns null if no such annotation exists.")]
		public string GetAnnotation(string name) {
		    return HasAnnotation(name) ? MetadataObject.Annotations[name].Value : null;
		}
		public void SetAnnotation(int index, string value, bool undoable = true) {
			var name = MetadataObject.Annotations[index].Name;
			SetAnnotation(name, value, undoable);
		}
		public string GetNewAnnotationName() {
			return MetadataObject.Annotations.GetNewName("New Annotation");
		}
		[IntelliSense("Sets the value of the annotation having the given name. If no such annotation exists, it will be created. If value is set to null, the annotation will be removed.")]
		public void SetAnnotation(string name, string value) {
		    SetAnnotation(name, value, true);
		}
		public void SetAnnotation(string name, string value, bool undoable) {
			if(name == null) name = GetNewAnnotationName();

			if(value == null) {
				// Remove annotation if set to null:
				RemoveAnnotation(name, undoable);
				return;
			}

			if(GetAnnotation(name) == value) return;
			bool undoable2 = true;
			bool cancel = false;
			OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + value, ref undoable2, ref cancel);
			if (cancel) return;

			if(MetadataObject.Annotations.Contains(name)) {
				// Change existing annotation:
				var oldValue = GetAnnotation(name);
				MetadataObject.Annotations[name].Value = value;
				if (undoable) Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, oldValue));
				OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, name + ":" + value);
			} else {
				// Add new annotation:
				MetadataObject.Annotations.Add(new TOM.Annotation{ Name = name, Value = value });
				if (undoable) Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, null));
				OnPropertyChanged(Properties.ANNOTATIONS, null, name + ":" + value);
			}

		}
		[IntelliSense("Remove an annotation by the given name.")]
		public void RemoveAnnotation(string name) {
		    RemoveAnnotation(name, true);
		}
		public void RemoveAnnotation(string name, bool undoable) {
			if(MetadataObject.Annotations.Contains(name)) {
				// Get current value:
				bool undoable2 = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + GetAnnotation(name), ref undoable2, ref cancel);
				if (cancel) return;

				var oldValue = MetadataObject.Annotations[name].Value;
				MetadataObject.Annotations.Remove(name);

				// Undo-handling:
				if (undoable) Handler.UndoManager.Add(new UndoAnnotationAction(this, name, null, oldValue));
				OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, null);
			}
		}
		[IntelliSense("Gets the number of annotations on the current object.")]
		public int GetAnnotationsCount() {
			return MetadataObject.Annotations.Count;
		}
		[IntelliSense("Gets a collection of all annotation names on the current object.")]
		public IEnumerable<string> GetAnnotations() {
			return MetadataObject.Annotations.Select(a => a.Name);
		}

		        [DisplayName("Extended Properties"),NoMultiselect,Category("Translations and Perspectives"),Description("The collection of Extended Properties on this object."),Editor(typeof(ExtendedPropertyCollectionEditor), typeof(UITypeEditor))]
		public ExtendedPropertyCollection ExtendedProperties { get; private set; }

		[IntelliSense("Returns true if an ExtendedProperty with the given name exists. Otherwise false.")]
		public bool HasExtendedProperty(string name) {
		    return MetadataObject.ExtendedProperties.ContainsName(name);
		}
		public ExtendedPropertyType GetExtendedPropertyType(int index) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[index].Type;
		}
		public ExtendedPropertyType GetExtendedPropertyType(string name) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[name].Type;
		}
		public string GetExtendedProperty(int index) {
			var ep = MetadataObject.ExtendedProperties[index];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		[IntelliSense("Gets the value of the ExtendedProperty with the given name. Returns null if no such ExtendedProperty exists.")]
		public string GetExtendedProperty(string name) {
		    if(!HasExtendedProperty(name)) return null;
			var ep = MetadataObject.ExtendedProperties[name];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		public void SetExtendedProperty(int index, string value, ExtendedPropertyType type = ExtendedPropertyType.String) {
			var name = MetadataObject.ExtendedProperties[index].Name;
			SetExtendedProperty(name, value, type);
		}
		public string GetNewExtendedPropertyName() {
			return MetadataObject.ExtendedProperties.GetNewName("New ExtendedProperty");
		}
		[IntelliSense("Sets the value of the ExtendedProperty having the given name. If no such ExtendedProperty exists, it will be created. If value is set to null, the ExtendedProperty will be removed.")]
		public void SetExtendedProperty(string name, string value, ExtendedPropertyType type = ExtendedPropertyType.String) {
			if(name == null) name = GetNewExtendedPropertyName();

			if(value == null) {
				// Remove ExtendedProperty if set to null:
				RemoveExtendedProperty(name);
				return;
			}

			if(GetExtendedProperty(name) == value) return;
			bool undoable = true;
			bool cancel = false;
			OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + value, ref undoable, ref cancel);
			if (cancel) return;

			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Change existing ExtendedProperty:
				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				var ep = MetadataObject.ExtendedProperties[name];
				if (ep is TOM.JsonExtendedProperty)
					(ep as TOM.JsonExtendedProperty).Value = value;
				else 
					(ep as TOM.StringExtendedProperty).Value = value;
					
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, name + ":" + value);
			} else {
				// Add new ExtendedProperty:
				if (type == ExtendedPropertyType.Json)
					MetadataObject.ExtendedProperties.Add(new TOM.JsonExtendedProperty{ Name = name, Value = value });
				else
					MetadataObject.ExtendedProperties.Add(new TOM.StringExtendedProperty{ Name = name, Value = value });

				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, null, type));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, null, name + ":" + value);
			}

		}
		[IntelliSense("Remove an ExtendedProperty by the given name.")]
		public void RemoveExtendedProperty(string name) {
			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Get current value:
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + GetExtendedProperty(name), ref undoable, ref cancel);
				if (cancel) return;

				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				MetadataObject.ExtendedProperties.Remove(name);

				// Undo-handling:
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, null, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, null);
			}
		}
		[IntelliSense("Gets the number of ExtendedProperties on the current object.")]
		public int GetExtendedPropertyCount() {
			return MetadataObject.ExtendedProperties.Count;
		}
		[IntelliSense("Gets a collection of all ExtendedProperty names on the current object.")]
		public IEnumerable<string> GetExtendedProperties() {
			return MetadataObject.ExtendedProperties.Select(a => a.Name);
		}

		/// <summary>
///             The description of the role, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio.
///             </summary>
		[DisplayName("Description")]
		[Category("Basic"),Description(@"The description of the role, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio."),IntelliSense(@"The description of the role, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio.")][Editor(typeof(System.ComponentModel.Design.MultilineStringEditor), typeof(System.Drawing.Design.UITypeEditor))]
		public string Description {
			get {
			    return MetadataObject.Description;
			}
			set {
				
				var oldValue = Description;
				var newValue = value.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DESCRIPTION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.Description = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DESCRIPTION, oldValue, newValue));
				OnPropertyChanged(Properties.DESCRIPTION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeDescription() { return false; }
/// <summary>
///             The level of access for this role. Possible values are as follows. None (1): The role has no access to the model. Read (2): The role can read metadata and data of the model. ReadRefresh (3): The role has read and refresh permission. Refresh (4): The role can refresh the data and calculations in the model. Administrator (5): The role can administer the model.
///             </summary>
		[DisplayName("Model Permission")]
		[Category("Security"),Description(@"The level of access for this role. Possible values are as follows. None (1): The role has no access to the model. Read (2): The role can read metadata and data of the model. ReadRefresh (3): The role has read and refresh permission. Refresh (4): The role can refresh the data and calculations in the model. Administrator (5): The role can administer the model."),IntelliSense(@"The level of access for this role. Possible values are as follows. None (1): The role has no access to the model. Read (2): The role can read metadata and data of the model. ReadRefresh (3): The role has read and refresh permission. Refresh (4): The role can refresh the data and calculations in the model. Administrator (5): The role can administer the model.")]
		public ModelPermission ModelPermission {
			get {
			    return (ModelPermission)MetadataObject.ModelPermission;
			}
			set {
				
				var oldValue = ModelPermission;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.MODELPERMISSION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.ModelPermission = (TOM.ModelPermission)newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.MODELPERMISSION, oldValue, newValue));
				OnPropertyChanged(Properties.MODELPERMISSION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeModelPermission() { return false; }

		internal static ModelRole CreateFromMetadata(Model parent, TOM.ModelRole metadataObject) {
			var obj = new ModelRole(metadataObject);
			parent.Roles.Add(obj);
			
			obj.Init();

			return obj;
		}


		/// <summary>
		/// Creates a new ModelRole and adds it to the parent Model.
		/// Also creates the underlying metadataobject and adds it to the TOM tree.
		/// </summary>
		public static ModelRole CreateNew(Model parent, string name = null)
		{
			if(TabularModelHandler.Singleton.UsePowerBIGovernance && !PowerBI.PowerBIGovernance.AllowCreate(typeof(ModelRole))) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(ModelRole).GetTypeName()));
			}

			var metadataObject = new TOM.ModelRole();
			metadataObject.Name = parent.Roles.GetNewName(string.IsNullOrWhiteSpace(name) ? "New " + typeof(ModelRole).GetTypeName() : name);

			var obj = new ModelRole(metadataObject);

			parent.Roles.Add(obj);
			
			obj.Init();

			return obj;
		}

		/// <summary>
		/// Creates a new ModelRole and adds it to the current Model.
		/// Also creates the underlying metadataobject and adds it to the TOM tree.
		/// </summary>		
		public static ModelRole CreateNew(string name = null)
		{
			return CreateNew(TabularModelHandler.Singleton.Model, name);
		}


		/// <summary>
		/// Creates an exact copy of this ModelRole object.
		/// </summary>
		public ModelRole Clone(string newName = null) {
			if(TabularModelHandler.Singleton.UsePowerBIGovernance && !PowerBI.PowerBIGovernance.AllowCreate(typeof(ModelRole))) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(ModelRole).GetTypeName()));
			}

		    Handler.BeginUpdate("Clone ModelRole");

			// Create a clone of the underlying metadataobject:
			var tom = MetadataObject.Clone() as TOM.ModelRole;


			// Assign a new, unique name:
			tom.Name = Parent.Roles.GetNewName(string.IsNullOrEmpty(newName) ? tom.Name + " copy" : newName);
				
			// Create the TOM Wrapper object, representing the metadataobject
			ModelRole obj = CreateFromMetadata(Parent, tom);

            Handler.EndUpdate();

            return obj;
		}

		TabularNamedObject IClonableObject.Clone(string newName, bool includeTranslations, TabularNamedObject newParent) 
		{
			if (newParent != null) throw new ArgumentException("This object can not be cloned to another parent. Argument newParent should be left as null.", "newParent");
			return Clone(newName);
		}

	
        internal override void RenewMetadataObject()
        {
            Handler.WrapperLookup.Remove(MetadataObject);
            MetadataObject = MetadataObject.Clone() as TOM.ModelRole;
            Handler.WrapperLookup.Add(MetadataObject, this);
        }

		public Model Parent { 
			get {
				return Handler.WrapperLookup[MetadataObject.Parent] as Model;
			}
		}

        internal override ITabularObjectCollection GetCollectionForChild(TabularObject child)
        {
			if (child is ModelRoleMember) return Members;
            return base.GetCollectionForChild(child);
        }

        /// <summary>
        /// The collection of ModelRoleMember objects on this ModelRole.
        /// </summary>
		[DisplayName("Members")]
		[Category("Security"),IntelliSense("The collection of Model Role Member objects on this ModelRole.")][Browsable(false)]
		public ModelRoleMemberCollection Members { get; private set; }

		/// <summary>
		/// CTOR - only called from static factory methods on the class
		/// </summary>
		ModelRole(TOM.ModelRole metadataObject) : base(metadataObject)
		{
			
			// Create indexer for annotations:
			Annotations = new AnnotationCollection(this);
			
			// Create indexer for extended properties:
			ExtendedProperties = new ExtendedPropertyCollection(this);
			
			// Instantiate child collections:
			Members = new ModelRoleMemberCollection(this.GetObjectPath() + ".Members", MetadataObject.Members, this);

			// Populate child collections:
			Members.CreateChildrenFromMetadata();

			// Hook up event handlers on child collections:
			Members.CollectionChanged += Children_CollectionChanged;
		}


		internal override void Reinit() {
			Members.Reinit();
		}

		internal override void Undelete(ITabularObjectCollection collection) {
			base.Undelete(collection);
			Reinit();
			ReapplyReferences();
		}

		public override bool Browsable(string propertyName) {
			switch (propertyName) {
 
				case Properties.EXTENDEDPROPERTIES:
					return Handler.CompatibilityLevel >= 1400;
				case Properties.PARENT:
					return false;
				
				default:
					return base.Browsable(propertyName);
			}
		}

    }


	/// <summary>
	/// Collection class for ModelRole. Provides convenient properties for setting a property on multiple objects at once.
	/// </summary>
	public sealed partial class ModelRoleCollection: TabularObjectCollection<ModelRole>
	{
		internal Model Model { get { return Parent as Model; } }
		TOM.ModelRoleCollection TOM_Collection;
		internal ModelRoleCollection(string collectionName, TOM.ModelRoleCollection metadataObjectCollection, Model parent) : base(collectionName, parent)
		{
			TOM_Collection = metadataObjectCollection;
		}
		internal override Type GetItemType() { return typeof(ModelRole); }
        protected override void TOM_Add(TOM.MetadataObject obj) { TOM_Collection.Add(obj as TOM.ModelRole); }
        protected override bool TOM_Contains(TOM.MetadataObject obj) { return TOM_Collection.Contains(obj as TOM.ModelRole); }
        protected override void TOM_Remove(TOM.MetadataObject obj) { TOM_Collection.Remove(obj as TOM.ModelRole); }
        protected override void TOM_Clear() { TOM_Collection.Clear(); }
        protected override bool TOM_ContainsName(string name) { return TOM_Collection.ContainsName(name); }
        protected override TOM.MetadataObject TOM_Get(int index) { return TOM_Collection[index]; }
        protected override TOM.MetadataObject TOM_Get(string name) { return TOM_Collection[name]; }
        internal override string GetNewName(string prefix = null) { return string.IsNullOrEmpty(prefix) ? TOM_Collection.GetNewName() : TOM_Collection.GetNewName(prefix); }
        public override int IndexOf(TOM.MetadataObject obj) { return TOM_Collection.IndexOf(obj as TOM.ModelRole); }
        public override int Count { get { return TOM_Collection.Count; } }
        public override IEnumerator<ModelRole> GetEnumerator() { return TOM_Collection.Select(h => Handler.WrapperLookup[h]).OfType<ModelRole>().GetEnumerator(); }
		internal override void Reinit() {
			var ixOffset = 0;
			for(int i = 0; i < Count; i++) {
				var item = this[i];
				Handler.WrapperLookup.Remove(item.MetadataObject);
				item.MetadataObject = Model.MetadataObject.Roles[i + ixOffset] as TOM.ModelRole;
				Handler.WrapperLookup.Add(item.MetadataObject, item);
				item.Collection = this;
			}
			TOM_Collection = Model.MetadataObject.Roles;
			foreach(var item in this) item.Reinit();
		}

		internal override void ReapplyReferences() {
			foreach(var item in this) item.ReapplyReferences();
		}

		/// <summary>
		/// Calling this method will populate the ModelRoleCollection with objects based on the MetadataObjects in the corresponding MetadataObjectCollection.
		/// </summary>
		internal override void CreateChildrenFromMetadata()
		{
			// Construct child objects (they are automatically added to the Handler's WrapperLookup dictionary):
			foreach(var obj in TOM_Collection) {
				if(obj is TOM.ModelRole) ModelRole.CreateFromMetadata(Model, obj as TOM.ModelRole);
		    }
		}

		/// <summary>
		/// Sets the Description property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the Description property of all objects in the collection at once.")]
		public string Description {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("Description"));
				this.ToList().ForEach(item => { item.Description = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the ModelPermission property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the ModelPermission property of all objects in the collection at once.")]
		public ModelPermission ModelPermission {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("ModelPermission"));
				this.ToList().ForEach(item => { item.ModelPermission = value; });
				Handler.UndoManager.EndBatch();
			}
		}

		public override string ToString() {
			return string.Format("({0} {1})", Count, (Count == 1 ? "ModelRole" : "Roles").ToLower());
		}
	}
  
	/// <summary>
///             Defines a user principal that belongs to the Role. It is a child of a Role object.
///             </summary>
	[TypeConverter(typeof(DynamicPropertyConverter))]
	public abstract partial class ModelRoleMember: TabularNamedObject
			, IAnnotationObject
			, IExtendedPropertyObject
	{
	    internal new TOM.ModelRoleMember MetadataObject 
		{ 
			get 
			{ 
				return base.MetadataObject as TOM.ModelRoleMember; 
		    } 
			set 
			{ 
				base.MetadataObject = value; 
			}
		}

        [Browsable(true),NoMultiselect,Category("Translations and Perspectives"),Description("The collection of Annotations on this object."),Editor(typeof(AnnotationCollectionEditor), typeof(UITypeEditor))]
		public AnnotationCollection Annotations { get; private set; }
		public string GetAnnotation(int index) {
			return MetadataObject.Annotations[index].Value;
		}
		[IntelliSense("Returns true if an annotation with the given name exists. Otherwise false.")]
		public bool HasAnnotation(string name) {
		    return MetadataObject.Annotations.ContainsName(name);
		}
		[IntelliSense("Gets the value of the annotation with the given name. Returns null if no such annotation exists.")]
		public string GetAnnotation(string name) {
		    return HasAnnotation(name) ? MetadataObject.Annotations[name].Value : null;
		}
		public void SetAnnotation(int index, string value, bool undoable = true) {
			var name = MetadataObject.Annotations[index].Name;
			SetAnnotation(name, value, undoable);
		}
		public string GetNewAnnotationName() {
			return MetadataObject.Annotations.GetNewName("New Annotation");
		}
		[IntelliSense("Sets the value of the annotation having the given name. If no such annotation exists, it will be created. If value is set to null, the annotation will be removed.")]
		public void SetAnnotation(string name, string value) {
		    SetAnnotation(name, value, true);
		}
		public void SetAnnotation(string name, string value, bool undoable) {
			if(name == null) name = GetNewAnnotationName();

			if(value == null) {
				// Remove annotation if set to null:
				RemoveAnnotation(name, undoable);
				return;
			}

			if(GetAnnotation(name) == value) return;
			bool undoable2 = true;
			bool cancel = false;
			OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + value, ref undoable2, ref cancel);
			if (cancel) return;

			if(MetadataObject.Annotations.Contains(name)) {
				// Change existing annotation:
				var oldValue = GetAnnotation(name);
				MetadataObject.Annotations[name].Value = value;
				if (undoable) Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, oldValue));
				OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, name + ":" + value);
			} else {
				// Add new annotation:
				MetadataObject.Annotations.Add(new TOM.Annotation{ Name = name, Value = value });
				if (undoable) Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, null));
				OnPropertyChanged(Properties.ANNOTATIONS, null, name + ":" + value);
			}

		}
		[IntelliSense("Remove an annotation by the given name.")]
		public void RemoveAnnotation(string name) {
		    RemoveAnnotation(name, true);
		}
		public void RemoveAnnotation(string name, bool undoable) {
			if(MetadataObject.Annotations.Contains(name)) {
				// Get current value:
				bool undoable2 = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + GetAnnotation(name), ref undoable2, ref cancel);
				if (cancel) return;

				var oldValue = MetadataObject.Annotations[name].Value;
				MetadataObject.Annotations.Remove(name);

				// Undo-handling:
				if (undoable) Handler.UndoManager.Add(new UndoAnnotationAction(this, name, null, oldValue));
				OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, null);
			}
		}
		[IntelliSense("Gets the number of annotations on the current object.")]
		public int GetAnnotationsCount() {
			return MetadataObject.Annotations.Count;
		}
		[IntelliSense("Gets a collection of all annotation names on the current object.")]
		public IEnumerable<string> GetAnnotations() {
			return MetadataObject.Annotations.Select(a => a.Name);
		}

		        [DisplayName("Extended Properties"),NoMultiselect,Category("Translations and Perspectives"),Description("The collection of Extended Properties on this object."),Editor(typeof(ExtendedPropertyCollectionEditor), typeof(UITypeEditor))]
		public ExtendedPropertyCollection ExtendedProperties { get; private set; }

		[IntelliSense("Returns true if an ExtendedProperty with the given name exists. Otherwise false.")]
		public bool HasExtendedProperty(string name) {
		    return MetadataObject.ExtendedProperties.ContainsName(name);
		}
		public ExtendedPropertyType GetExtendedPropertyType(int index) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[index].Type;
		}
		public ExtendedPropertyType GetExtendedPropertyType(string name) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[name].Type;
		}
		public string GetExtendedProperty(int index) {
			var ep = MetadataObject.ExtendedProperties[index];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		[IntelliSense("Gets the value of the ExtendedProperty with the given name. Returns null if no such ExtendedProperty exists.")]
		public string GetExtendedProperty(string name) {
		    if(!HasExtendedProperty(name)) return null;
			var ep = MetadataObject.ExtendedProperties[name];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		public void SetExtendedProperty(int index, string value, ExtendedPropertyType type = ExtendedPropertyType.String) {
			var name = MetadataObject.ExtendedProperties[index].Name;
			SetExtendedProperty(name, value, type);
		}
		public string GetNewExtendedPropertyName() {
			return MetadataObject.ExtendedProperties.GetNewName("New ExtendedProperty");
		}
		[IntelliSense("Sets the value of the ExtendedProperty having the given name. If no such ExtendedProperty exists, it will be created. If value is set to null, the ExtendedProperty will be removed.")]
		public void SetExtendedProperty(string name, string value, ExtendedPropertyType type = ExtendedPropertyType.String) {
			if(name == null) name = GetNewExtendedPropertyName();

			if(value == null) {
				// Remove ExtendedProperty if set to null:
				RemoveExtendedProperty(name);
				return;
			}

			if(GetExtendedProperty(name) == value) return;
			bool undoable = true;
			bool cancel = false;
			OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + value, ref undoable, ref cancel);
			if (cancel) return;

			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Change existing ExtendedProperty:
				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				var ep = MetadataObject.ExtendedProperties[name];
				if (ep is TOM.JsonExtendedProperty)
					(ep as TOM.JsonExtendedProperty).Value = value;
				else 
					(ep as TOM.StringExtendedProperty).Value = value;
					
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, name + ":" + value);
			} else {
				// Add new ExtendedProperty:
				if (type == ExtendedPropertyType.Json)
					MetadataObject.ExtendedProperties.Add(new TOM.JsonExtendedProperty{ Name = name, Value = value });
				else
					MetadataObject.ExtendedProperties.Add(new TOM.StringExtendedProperty{ Name = name, Value = value });

				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, null, type));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, null, name + ":" + value);
			}

		}
		[IntelliSense("Remove an ExtendedProperty by the given name.")]
		public void RemoveExtendedProperty(string name) {
			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Get current value:
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + GetExtendedProperty(name), ref undoable, ref cancel);
				if (cancel) return;

				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				MetadataObject.ExtendedProperties.Remove(name);

				// Undo-handling:
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, null, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, null);
			}
		}
		[IntelliSense("Gets the number of ExtendedProperties on the current object.")]
		public int GetExtendedPropertyCount() {
			return MetadataObject.ExtendedProperties.Count;
		}
		[IntelliSense("Gets a collection of all ExtendedProperty names on the current object.")]
		public IEnumerable<string> GetExtendedProperties() {
			return MetadataObject.ExtendedProperties.Select(a => a.Name);
		}

		/// <summary>
///             The security name that identifies the user or group of the member.
///             </summary>
		[DisplayName("Member Name")]
		[Category("Other"),Description(@"The security name that identifies the user or group of the member."),IntelliSense(@"The security name that identifies the user or group of the member.")]
		public string MemberName {
			get {
			    return MetadataObject.MemberName;
			}
			set {
				
				var oldValue = MemberName;
				var newValue = value.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.MEMBERNAME, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.MemberName = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.MEMBERNAME, oldValue, newValue));
				OnPropertyChanged(Properties.MEMBERNAME, oldValue, newValue);
			}
		}
		private bool ShouldSerializeMemberName() { return false; }
/// <summary>
///             A reference to a Member object associated with this RoleMembership.
///             </summary>
		[DisplayName("Member ID")]
		[Category("Other"),Description(@"A reference to a Member object associated with this RoleMembership."),IntelliSense(@"A reference to a Member object associated with this RoleMembership.")]
		public string MemberID {
			get {
			    return MetadataObject.MemberID;
			}
			set {
				
				var oldValue = MemberID;
				var newValue = value.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.MEMBERID, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.MemberID = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.MEMBERID, oldValue, newValue));
				OnPropertyChanged(Properties.MEMBERID, oldValue, newValue);
			}
		}
		private bool ShouldSerializeMemberID() { return false; }
/// <summary>
///             A reference to a Role object that owns this RoleMembeship.
///             </summary>
		[DisplayName("Role")]
		[Category("Other"),Description(@"A reference to a Role object that owns this RoleMembeship."),IntelliSense(@"A reference to a Role object that owns this RoleMembeship.")]
		public ModelRole Role {
			get {
				if (MetadataObject.Role == null) return null;
			    return Handler.WrapperLookup[MetadataObject.Role] as ModelRole;
            }
			
		}
		private bool ShouldSerializeRole() { return false; }

	
        internal override void RenewMetadataObject()
        {
            Handler.WrapperLookup.Remove(MetadataObject);
            MetadataObject = MetadataObject.Clone() as TOM.ModelRoleMember;
            Handler.WrapperLookup.Add(MetadataObject, this);
        }

		public ModelRole Parent { 
			get {
				return Handler.WrapperLookup[MetadataObject.Parent] as ModelRole;
			}
		}



		/// <summary>
		/// CTOR - only called from static factory methods on the class
		/// </summary>
		protected ModelRoleMember(TOM.ModelRoleMember metadataObject) : base(metadataObject)
		{
			
			// Create indexer for annotations:
			Annotations = new AnnotationCollection(this);
			
			// Create indexer for extended properties:
			ExtendedProperties = new ExtendedPropertyCollection(this);
		}



		internal override void Undelete(ITabularObjectCollection collection) {
			base.Undelete(collection);
			Reinit();
			ReapplyReferences();
		}

		public override bool Browsable(string propertyName) {
			switch (propertyName) {
 
				case Properties.EXTENDEDPROPERTIES:
					return Handler.CompatibilityLevel >= 1400;
				case Properties.PARENT:
					return false;
				
				default:
					return base.Browsable(propertyName);
			}
		}

    }


	/// <summary>
	/// Collection class for ModelRoleMember. Provides convenient properties for setting a property on multiple objects at once.
	/// </summary>
	public sealed partial class ModelRoleMemberCollection: TabularObjectCollection<ModelRoleMember>
	{
		internal ModelRole ModelRole { get { return Parent as ModelRole; } }
		TOM.ModelRoleMemberCollection TOM_Collection;
		internal ModelRoleMemberCollection(string collectionName, TOM.ModelRoleMemberCollection metadataObjectCollection, ModelRole parent) : base(collectionName, parent)
		{
			TOM_Collection = metadataObjectCollection;
		}
		internal override Type GetItemType() { return typeof(ModelRoleMember); }
        protected override void TOM_Add(TOM.MetadataObject obj) { TOM_Collection.Add(obj as TOM.ModelRoleMember); }
        protected override bool TOM_Contains(TOM.MetadataObject obj) { return TOM_Collection.Contains(obj as TOM.ModelRoleMember); }
        protected override void TOM_Remove(TOM.MetadataObject obj) { TOM_Collection.Remove(obj as TOM.ModelRoleMember); }
        protected override void TOM_Clear() { TOM_Collection.Clear(); }
        protected override bool TOM_ContainsName(string name) { return TOM_Collection.ContainsName(name); }
        protected override TOM.MetadataObject TOM_Get(int index) { return TOM_Collection[index]; }
        protected override TOM.MetadataObject TOM_Get(string name) { return TOM_Collection[name]; }
        internal override string GetNewName(string prefix = null) { return string.IsNullOrEmpty(prefix) ? TOM_Collection.GetNewName() : TOM_Collection.GetNewName(prefix); }
        public override int IndexOf(TOM.MetadataObject obj) { return TOM_Collection.IndexOf(obj as TOM.ModelRoleMember); }
        public override int Count { get { return TOM_Collection.Count; } }
        public override IEnumerator<ModelRoleMember> GetEnumerator() { return TOM_Collection.Select(h => Handler.WrapperLookup[h]).OfType<ModelRoleMember>().GetEnumerator(); }
		internal override void Reinit() {
			var ixOffset = 0;
			for(int i = 0; i < Count; i++) {
				var item = this[i];
				Handler.WrapperLookup.Remove(item.MetadataObject);
				item.MetadataObject = ModelRole.MetadataObject.Members[i + ixOffset] as TOM.ModelRoleMember;
				Handler.WrapperLookup.Add(item.MetadataObject, item);
				item.Collection = this;
			}
			TOM_Collection = ModelRole.MetadataObject.Members;
			foreach(var item in this) item.Reinit();
		}

		internal override void ReapplyReferences() {
			foreach(var item in this) item.ReapplyReferences();
		}

		/// <summary>
		/// Calling this method will populate the ModelRoleMemberCollection with objects based on the MetadataObjects in the corresponding MetadataObjectCollection.
		/// </summary>
		internal override void CreateChildrenFromMetadata()
		{
			// Construct child objects (they are automatically added to the Handler's WrapperLookup dictionary):
			foreach(var obj in TOM_Collection) {
				if(obj is TOM.ExternalModelRoleMember) ExternalModelRoleMember.CreateFromMetadata(ModelRole, obj as TOM.ExternalModelRoleMember);
				if(obj is TOM.WindowsModelRoleMember) WindowsModelRoleMember.CreateFromMetadata(ModelRole, obj as TOM.WindowsModelRoleMember);
		    }
		}

		/// <summary>
		/// Sets the MemberName property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the MemberName property of all objects in the collection at once.")]
		public string MemberName {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("MemberName"));
				this.ToList().ForEach(item => { item.MemberName = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the MemberID property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the MemberID property of all objects in the collection at once.")]
		public string MemberID {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("MemberID"));
				this.ToList().ForEach(item => { item.MemberID = value; });
				Handler.UndoManager.EndBatch();
			}
		}

		public override string ToString() {
			return string.Format("({0} {1})", Count, (Count == 1 ? "ModelRoleMember" : "Members").ToLower());
		}
	}
  
	/// <summary>
///             Represents a partition in a table. Partitions define the query against external data sources that return the rowsets of a <see cref="T:TabularEditor.TOMWrapper.Table" />.
///             </summary>
	[TypeConverter(typeof(DynamicPropertyConverter))]
	public partial class Partition: TabularNamedObject
			, IErrorMessageObject
			, ITabularTableObject
			, IDescriptionObject
			, IAnnotationObject
			, IExtendedPropertyObject
			, IClonableObject
	{
	    internal new TOM.Partition MetadataObject 
		{ 
			get 
			{ 
				return base.MetadataObject as TOM.Partition; 
		    } 
			set 
			{ 
				base.MetadataObject = value; 
			}
		}

/// <summary>
///             The type of source used by the Partition. This is either a query against a DataSource, or for calculated tables, an expression.
///             </summary>
		[DisplayName("Source Type")]
		[Category("Other"),Description(@"The type of source used by the Partition. This is either a query against a DataSource, or for calculated tables, an expression."),IntelliSense(@"The type of source used by the Partition. This is either a query against a DataSource, or for calculated tables, an expression.")]
		public PartitionSourceType SourceType {
			get {
			    return (PartitionSourceType)MetadataObject.SourceType;
			}
			
		}
		private bool ShouldSerializeSourceType() { return false; }
        [Browsable(true),NoMultiselect,Category("Translations and Perspectives"),Description("The collection of Annotations on this object."),Editor(typeof(AnnotationCollectionEditor), typeof(UITypeEditor))]
		public AnnotationCollection Annotations { get; private set; }
		public string GetAnnotation(int index) {
			return MetadataObject.Annotations[index].Value;
		}
		[IntelliSense("Returns true if an annotation with the given name exists. Otherwise false.")]
		public bool HasAnnotation(string name) {
		    return MetadataObject.Annotations.ContainsName(name);
		}
		[IntelliSense("Gets the value of the annotation with the given name. Returns null if no such annotation exists.")]
		public string GetAnnotation(string name) {
		    return HasAnnotation(name) ? MetadataObject.Annotations[name].Value : null;
		}
		public void SetAnnotation(int index, string value, bool undoable = true) {
			var name = MetadataObject.Annotations[index].Name;
			SetAnnotation(name, value, undoable);
		}
		public string GetNewAnnotationName() {
			return MetadataObject.Annotations.GetNewName("New Annotation");
		}
		[IntelliSense("Sets the value of the annotation having the given name. If no such annotation exists, it will be created. If value is set to null, the annotation will be removed.")]
		public void SetAnnotation(string name, string value) {
		    SetAnnotation(name, value, true);
		}
		public void SetAnnotation(string name, string value, bool undoable) {
			if(name == null) name = GetNewAnnotationName();

			if(value == null) {
				// Remove annotation if set to null:
				RemoveAnnotation(name, undoable);
				return;
			}

			if(GetAnnotation(name) == value) return;
			bool undoable2 = true;
			bool cancel = false;
			OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + value, ref undoable2, ref cancel);
			if (cancel) return;

			if(MetadataObject.Annotations.Contains(name)) {
				// Change existing annotation:
				var oldValue = GetAnnotation(name);
				MetadataObject.Annotations[name].Value = value;
				if (undoable) Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, oldValue));
				OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, name + ":" + value);
			} else {
				// Add new annotation:
				MetadataObject.Annotations.Add(new TOM.Annotation{ Name = name, Value = value });
				if (undoable) Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, null));
				OnPropertyChanged(Properties.ANNOTATIONS, null, name + ":" + value);
			}

		}
		[IntelliSense("Remove an annotation by the given name.")]
		public void RemoveAnnotation(string name) {
		    RemoveAnnotation(name, true);
		}
		public void RemoveAnnotation(string name, bool undoable) {
			if(MetadataObject.Annotations.Contains(name)) {
				// Get current value:
				bool undoable2 = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + GetAnnotation(name), ref undoable2, ref cancel);
				if (cancel) return;

				var oldValue = MetadataObject.Annotations[name].Value;
				MetadataObject.Annotations.Remove(name);

				// Undo-handling:
				if (undoable) Handler.UndoManager.Add(new UndoAnnotationAction(this, name, null, oldValue));
				OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, null);
			}
		}
		[IntelliSense("Gets the number of annotations on the current object.")]
		public int GetAnnotationsCount() {
			return MetadataObject.Annotations.Count;
		}
		[IntelliSense("Gets a collection of all annotation names on the current object.")]
		public IEnumerable<string> GetAnnotations() {
			return MetadataObject.Annotations.Select(a => a.Name);
		}

		        [DisplayName("Extended Properties"),NoMultiselect,Category("Translations and Perspectives"),Description("The collection of Extended Properties on this object."),Editor(typeof(ExtendedPropertyCollectionEditor), typeof(UITypeEditor))]
		public ExtendedPropertyCollection ExtendedProperties { get; private set; }

		[IntelliSense("Returns true if an ExtendedProperty with the given name exists. Otherwise false.")]
		public bool HasExtendedProperty(string name) {
		    return MetadataObject.ExtendedProperties.ContainsName(name);
		}
		public ExtendedPropertyType GetExtendedPropertyType(int index) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[index].Type;
		}
		public ExtendedPropertyType GetExtendedPropertyType(string name) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[name].Type;
		}
		public string GetExtendedProperty(int index) {
			var ep = MetadataObject.ExtendedProperties[index];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		[IntelliSense("Gets the value of the ExtendedProperty with the given name. Returns null if no such ExtendedProperty exists.")]
		public string GetExtendedProperty(string name) {
		    if(!HasExtendedProperty(name)) return null;
			var ep = MetadataObject.ExtendedProperties[name];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		public void SetExtendedProperty(int index, string value, ExtendedPropertyType type = ExtendedPropertyType.String) {
			var name = MetadataObject.ExtendedProperties[index].Name;
			SetExtendedProperty(name, value, type);
		}
		public string GetNewExtendedPropertyName() {
			return MetadataObject.ExtendedProperties.GetNewName("New ExtendedProperty");
		}
		[IntelliSense("Sets the value of the ExtendedProperty having the given name. If no such ExtendedProperty exists, it will be created. If value is set to null, the ExtendedProperty will be removed.")]
		public void SetExtendedProperty(string name, string value, ExtendedPropertyType type = ExtendedPropertyType.String) {
			if(name == null) name = GetNewExtendedPropertyName();

			if(value == null) {
				// Remove ExtendedProperty if set to null:
				RemoveExtendedProperty(name);
				return;
			}

			if(GetExtendedProperty(name) == value) return;
			bool undoable = true;
			bool cancel = false;
			OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + value, ref undoable, ref cancel);
			if (cancel) return;

			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Change existing ExtendedProperty:
				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				var ep = MetadataObject.ExtendedProperties[name];
				if (ep is TOM.JsonExtendedProperty)
					(ep as TOM.JsonExtendedProperty).Value = value;
				else 
					(ep as TOM.StringExtendedProperty).Value = value;
					
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, name + ":" + value);
			} else {
				// Add new ExtendedProperty:
				if (type == ExtendedPropertyType.Json)
					MetadataObject.ExtendedProperties.Add(new TOM.JsonExtendedProperty{ Name = name, Value = value });
				else
					MetadataObject.ExtendedProperties.Add(new TOM.StringExtendedProperty{ Name = name, Value = value });

				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, null, type));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, null, name + ":" + value);
			}

		}
		[IntelliSense("Remove an ExtendedProperty by the given name.")]
		public void RemoveExtendedProperty(string name) {
			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Get current value:
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + GetExtendedProperty(name), ref undoable, ref cancel);
				if (cancel) return;

				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				MetadataObject.ExtendedProperties.Remove(name);

				// Undo-handling:
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, null, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, null);
			}
		}
		[IntelliSense("Gets the number of ExtendedProperties on the current object.")]
		public int GetExtendedPropertyCount() {
			return MetadataObject.ExtendedProperties.Count;
		}
		[IntelliSense("Gets a collection of all ExtendedProperty names on the current object.")]
		public IEnumerable<string> GetExtendedProperties() {
			return MetadataObject.ExtendedProperties.Select(a => a.Name);
		}

		/// <summary>
///             The description of the partition, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio.
///             </summary>
		[DisplayName("Description")]
		[Category("Basic"),Description(@"The description of the partition, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio."),IntelliSense(@"The description of the partition, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio.")][Editor(typeof(System.ComponentModel.Design.MultilineStringEditor), typeof(System.Drawing.Design.UITypeEditor))]
		public string Description {
			get {
			    return MetadataObject.Description;
			}
			set {
				
				var oldValue = Description;
				var newValue = value.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DESCRIPTION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.Description = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DESCRIPTION, oldValue, newValue));
				OnPropertyChanged(Properties.DESCRIPTION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeDescription() { return false; }
/// <summary>
///             Provides information on the state of the partition. Possible values are as follows. Ready (1): The partition is queryable and has up-to-date data. NoData (3): The partition is queryable but has no data. This state applies only to partitions with a type other than Calculated. CalculationNeeded (4): The partition is not queryable and needs to be refreshed (that is, recalculated) to become functional. This state applies only to partitions of the type Calculated. SemanticError (5): The partition is in an error state because of an invalid expression and is not queryable. This state applies only to partitions of the type Calculated. EvaluationError (6): The partition is in an error state because of an error during expression evaluation. The partition is not queryable. This state applies only to partitions of the type Calculated. DependencyError (7): The partition is in an error state because some of its calculation dependencies are in an error state. The partition is not queryable. This state applies only to partitions of the type Calculated. Incomplete (8): Some parts of the partition have no data, and the partition needs to be refreshed to bring the data in. The partition is queryable. This state applies only to partitions of a type other than Calculated. SyntaxError (9): The partition is in an error state because of a syntax error in its expression. The partition is not queryable. This state applies only to partitions of the type Calculated.
///             </summary>
		[DisplayName("State")]
		[Category("Metadata"),Description(@"Provides information on the state of the partition. Possible values are as follows. Ready (1): The partition is queryable and has up-to-date data. NoData (3): The partition is queryable but has no data. This state applies only to partitions with a type other than Calculated. CalculationNeeded (4): The partition is not queryable and needs to be refreshed (that is, recalculated) to become functional. This state applies only to partitions of the type Calculated. SemanticError (5): The partition is in an error state because of an invalid expression and is not queryable. This state applies only to partitions of the type Calculated. EvaluationError (6): The partition is in an error state because of an error during expression evaluation. The partition is not queryable. This state applies only to partitions of the type Calculated. DependencyError (7): The partition is in an error state because some of its calculation dependencies are in an error state. The partition is not queryable. This state applies only to partitions of the type Calculated. Incomplete (8): Some parts of the partition have no data, and the partition needs to be refreshed to bring the data in. The partition is queryable. This state applies only to partitions of a type other than Calculated. SyntaxError (9): The partition is in an error state because of a syntax error in its expression. The partition is not queryable. This state applies only to partitions of the type Calculated."),IntelliSense(@"Provides information on the state of the partition. Possible values are as follows. Ready (1): The partition is queryable and has up-to-date data. NoData (3): The partition is queryable but has no data. This state applies only to partitions with a type other than Calculated. CalculationNeeded (4): The partition is not queryable and needs to be refreshed (that is, recalculated) to become functional. This state applies only to partitions of the type Calculated. SemanticError (5): The partition is in an error state because of an invalid expression and is not queryable. This state applies only to partitions of the type Calculated. EvaluationError (6): The partition is in an error state because of an error during expression evaluation. The partition is not queryable. This state applies only to partitions of the type Calculated. DependencyError (7): The partition is in an error state because some of its calculation dependencies are in an error state. The partition is not queryable. This state applies only to partitions of the type Calculated. Incomplete (8): Some parts of the partition have no data, and the partition needs to be refreshed to bring the data in. The partition is queryable. This state applies only to partitions of a type other than Calculated. SyntaxError (9): The partition is in an error state because of a syntax error in its expression. The partition is not queryable. This state applies only to partitions of the type Calculated.")]
		public ObjectState State {
			get {
			    return (ObjectState)MetadataObject.State;
			}
			
		}
		private bool ShouldSerializeState() { return false; }
/// <summary>
///             Defines the method for making data available in the partition. Possible values are as follows. Import (0) Data will be imported from a data source. DirectQuery (1) Data will be queried dynamically from a data source. Default (2): Only partitions can use this value. When set, the partition will inherit the DefaultMode of the Model. Push (3): Data will be pushed into the partition. The Mode of a Partition can be set to Default (2), in which case it will inherit its Mode from the DefaultMode of the Model
///             </summary>
		[DisplayName("Mode")]
		[Category("Other"),Description(@"Defines the method for making data available in the partition. Possible values are as follows. Import (0) Data will be imported from a data source. DirectQuery (1) Data will be queried dynamically from a data source. Default (2): Only partitions can use this value. When set, the partition will inherit the DefaultMode of the Model. Push (3): Data will be pushed into the partition. The Mode of a Partition can be set to Default (2), in which case it will inherit its Mode from the DefaultMode of the Model"),IntelliSense(@"Defines the method for making data available in the partition. Possible values are as follows. Import (0) Data will be imported from a data source. DirectQuery (1) Data will be queried dynamically from a data source. Default (2): Only partitions can use this value. When set, the partition will inherit the DefaultMode of the Model. Push (3): Data will be pushed into the partition. The Mode of a Partition can be set to Default (2), in which case it will inherit its Mode from the DefaultMode of the Model")]
		public ModeType Mode {
			get {
			    return (ModeType)MetadataObject.Mode;
			}
			set {
				
				var oldValue = Mode;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.MODE, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.Mode = (TOM.ModeType)newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.MODE, oldValue, newValue));
				OnPropertyChanged(Properties.MODE, oldValue, newValue);
			}
		}
		private bool ShouldSerializeMode() { return false; }
/// <summary>
///             Determines which partitions should be selected to run queries against the model. The possible values are as follows. Full (0) - Partitions with DataView set to Default or Full are selected. Sample (1): Partitions with DataView set to Default or Sample are selected. SampleAndFull (2): All partitions are selected. Default (3) - Inherits from the default DataView of the Model object.
///             </summary>
		[DisplayName("Data View")]
		[Category("Other"),Description(@"Determines which partitions should be selected to run queries against the model. The possible values are as follows. Full (0) - Partitions with DataView set to Default or Full are selected. Sample (1): Partitions with DataView set to Default or Sample are selected. SampleAndFull (2): All partitions are selected. Default (3) - Inherits from the default DataView of the Model object."),IntelliSense(@"Determines which partitions should be selected to run queries against the model. The possible values are as follows. Full (0) - Partitions with DataView set to Default or Full are selected. Sample (1): Partitions with DataView set to Default or Sample are selected. SampleAndFull (2): All partitions are selected. Default (3) - Inherits from the default DataView of the Model object.")]
		public DataViewType DataView {
			get {
			    return (DataViewType)MetadataObject.DataView;
			}
			set {
				
				var oldValue = DataView;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DATAVIEW, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.DataView = (TOM.DataViewType)newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DATAVIEW, oldValue, newValue));
				OnPropertyChanged(Properties.DATAVIEW, oldValue, newValue);
			}
		}
		private bool ShouldSerializeDataView() { return false; }
/// <summary>
///             The string that explains the error state associated with the current object. It is set by the engine only when the state of the object is one of these three values: SemanticError, DependencyError, or EvaluationError.This element applies only to partitions of the type Calculated.
///             </summary>
		[DisplayName("Error Message")]
		[Category("Metadata"),Description(@"The string that explains the error state associated with the current object. It is set by the engine only when the state of the object is one of these three values: SemanticError, DependencyError, or EvaluationError.This element applies only to partitions of the type Calculated."),IntelliSense(@"The string that explains the error state associated with the current object. It is set by the engine only when the state of the object is one of these three values: SemanticError, DependencyError, or EvaluationError.This element applies only to partitions of the type Calculated.")]
		public string ErrorMessage {
			get {
			    return MetadataObject.ErrorMessage;
			}
			
		}
		private bool ShouldSerializeErrorMessage() { return false; }
		[Browsable(false)]
		public Table Table
		{ 
			get 
			{ 
				TabularObject t = null;
				if(MetadataObject == null || MetadataObject.Table == null) return null;
				if(!Handler.WrapperLookup.TryGetValue(MetadataObject.Table, out t)) {
				    t = Model.Tables[MetadataObject.Table.Name];
				}
				return t as Table;
			} 
		}

		internal static Partition CreateFromMetadata(Table parent, TOM.Partition metadataObject) {
			var obj = new Partition(metadataObject);
			parent.Partitions.Add(obj);
			
			obj.Init();

			return obj;
		}


		/// <summary>
		/// Creates a new Partition and adds it to the parent Table.
		/// Also creates the underlying metadataobject and adds it to the TOM tree.
		/// </summary>
		public static Partition CreateNew(Table parent, string name = null)
		{
			if(TabularModelHandler.Singleton.UsePowerBIGovernance && !PowerBI.PowerBIGovernance.AllowCreate(typeof(Partition))) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(Partition).GetTypeName()));
			}

			var metadataObject = new TOM.Partition();
			metadataObject.Name = parent.Partitions.GetNewName(string.IsNullOrWhiteSpace(name) ? "New " + typeof(Partition).GetTypeName() : name);

			var obj = new Partition(metadataObject);

			parent.Partitions.Add(obj);
			
			obj.Init();

			return obj;
		}


		/// <summary>
		/// Creates an exact copy of this Partition object.
		/// </summary>
		public Partition Clone(string newName = null, Table newParent = null) {
			if(TabularModelHandler.Singleton.UsePowerBIGovernance && !PowerBI.PowerBIGovernance.AllowCreate(typeof(Partition))) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(Partition).GetTypeName()));
			}

		    Handler.BeginUpdate("Clone Partition");

			// Create a clone of the underlying metadataobject:
			var tom = MetadataObject.Clone() as TOM.Partition;


			// Assign a new, unique name:
			tom.Name = Parent.Partitions.GetNewName(string.IsNullOrEmpty(newName) ? tom.Name + " copy" : newName);
				
			// Create the TOM Wrapper object, representing the metadataobject
			Partition obj = CreateFromMetadata(newParent ?? Parent, tom);

            Handler.EndUpdate();

            return obj;
		}

		TabularNamedObject IClonableObject.Clone(string newName, bool includeTranslations, TabularNamedObject newParent) 
		{
			return Clone(newName);
		}

	
        internal override void RenewMetadataObject()
        {
            Handler.WrapperLookup.Remove(MetadataObject);
            MetadataObject = MetadataObject.Clone() as TOM.Partition;
            Handler.WrapperLookup.Add(MetadataObject, this);
        }

		public Table Parent { 
			get {
				return Handler.WrapperLookup[MetadataObject.Parent] as Table;
			}
		}



		/// <summary>
		/// CTOR - only called from static factory methods on the class
		/// </summary>
		protected Partition(TOM.Partition metadataObject) : base(metadataObject)
		{
			
			// Create indexer for annotations:
			Annotations = new AnnotationCollection(this);
			
			// Create indexer for extended properties:
			ExtendedProperties = new ExtendedPropertyCollection(this);
		}



		internal override void Undelete(ITabularObjectCollection collection) {
			base.Undelete(collection);
			Reinit();
			ReapplyReferences();
		}

		public override bool Browsable(string propertyName) {
			switch (propertyName) {
 
				case Properties.EXTENDEDPROPERTIES:
					return Handler.CompatibilityLevel >= 1400;
				case Properties.PARENT:
					return false;
				
				default:
					return base.Browsable(propertyName);
			}
		}

    }


	/// <summary>
	/// Collection class for Partition. Provides convenient properties for setting a property on multiple objects at once.
	/// </summary>
	public sealed partial class PartitionCollection: TabularObjectCollection<Partition>
	{
		internal Table Table { get { return Parent as Table; } }
		TOM.PartitionCollection TOM_Collection;
		internal PartitionCollection(string collectionName, TOM.PartitionCollection metadataObjectCollection, Table parent) : base(collectionName, parent)
		{
			TOM_Collection = metadataObjectCollection;
		}
		internal override Type GetItemType() { return typeof(Partition); }
        protected override void TOM_Add(TOM.MetadataObject obj) { TOM_Collection.Add(obj as TOM.Partition); }
        protected override bool TOM_Contains(TOM.MetadataObject obj) { return TOM_Collection.Contains(obj as TOM.Partition); }
        protected override void TOM_Remove(TOM.MetadataObject obj) { TOM_Collection.Remove(obj as TOM.Partition); }
        protected override void TOM_Clear() { TOM_Collection.Clear(); }
        protected override bool TOM_ContainsName(string name) { return TOM_Collection.ContainsName(name); }
        protected override TOM.MetadataObject TOM_Get(int index) { return TOM_Collection[index]; }
        protected override TOM.MetadataObject TOM_Get(string name) { return TOM_Collection[name]; }
        internal override string GetNewName(string prefix = null) { return string.IsNullOrEmpty(prefix) ? TOM_Collection.GetNewName() : TOM_Collection.GetNewName(prefix); }
        public override int IndexOf(TOM.MetadataObject obj) { return TOM_Collection.IndexOf(obj as TOM.Partition); }
        public override int Count { get { return TOM_Collection.Count; } }
        public override IEnumerator<Partition> GetEnumerator() { return TOM_Collection.Select(h => Handler.WrapperLookup[h]).OfType<Partition>().GetEnumerator(); }
		internal override void Reinit() {
			var ixOffset = 0;
			for(int i = 0; i < Count; i++) {
				var item = this[i];
				Handler.WrapperLookup.Remove(item.MetadataObject);
				item.MetadataObject = Table.MetadataObject.Partitions[i + ixOffset] as TOM.Partition;
				Handler.WrapperLookup.Add(item.MetadataObject, item);
				item.Collection = this;
			}
			TOM_Collection = Table.MetadataObject.Partitions;
			foreach(var item in this) item.Reinit();
		}

		internal override void ReapplyReferences() {
			foreach(var item in this) item.ReapplyReferences();
		}

		/// <summary>
		/// Calling this method will populate the PartitionCollection with objects based on the MetadataObjects in the corresponding MetadataObjectCollection.
		/// </summary>
		internal override void CreateChildrenFromMetadata()
		{
			// Construct child objects (they are automatically added to the Handler's WrapperLookup dictionary):
			foreach(var obj in TOM_Collection) {
				if(obj.SourceType == TOM.PartitionSourceType.M) MPartition.CreateFromMetadata(Table, obj);
				else Partition.CreateFromMetadata(Table, obj);
		    }
		}

		/// <summary>
		/// Sets the Description property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the Description property of all objects in the collection at once.")]
		public string Description {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("Description"));
				this.ToList().ForEach(item => { item.Description = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the Mode property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the Mode property of all objects in the collection at once.")]
		public ModeType Mode {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("Mode"));
				this.ToList().ForEach(item => { item.Mode = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the DataView property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the DataView property of all objects in the collection at once.")]
		public DataViewType DataView {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("DataView"));
				this.ToList().ForEach(item => { item.DataView = value; });
				Handler.UndoManager.EndBatch();
			}
		}

		public override string ToString() {
			return string.Format("({0} {1})", Count, (Count == 1 ? "Partition" : "Partitions").ToLower());
		}
	}
  
	/// <summary>
///             Defines a logical view over the Model and is a child of a Model object. It allows hiding Tables, Columns, Measures, and Hierarchies so that end users can look at a smaller subset of the large data model. 
///             </summary>
	[TypeConverter(typeof(DynamicPropertyConverter))]
	public sealed partial class Perspective: TabularNamedObject
			, IDescriptionObject
			, IAnnotationObject
			, IExtendedPropertyObject
			, ITranslatableObject
			, IClonableObject
	{
	    internal new TOM.Perspective MetadataObject 
		{ 
			get 
			{ 
				return base.MetadataObject as TOM.Perspective; 
		    } 
			set 
			{ 
				base.MetadataObject = value; 
			}
		}

        [Browsable(true),NoMultiselect,Category("Translations and Perspectives"),Description("The collection of Annotations on this object."),Editor(typeof(AnnotationCollectionEditor), typeof(UITypeEditor))]
		public AnnotationCollection Annotations { get; private set; }
		public string GetAnnotation(int index) {
			return MetadataObject.Annotations[index].Value;
		}
		[IntelliSense("Returns true if an annotation with the given name exists. Otherwise false.")]
		public bool HasAnnotation(string name) {
		    return MetadataObject.Annotations.ContainsName(name);
		}
		[IntelliSense("Gets the value of the annotation with the given name. Returns null if no such annotation exists.")]
		public string GetAnnotation(string name) {
		    return HasAnnotation(name) ? MetadataObject.Annotations[name].Value : null;
		}
		public void SetAnnotation(int index, string value, bool undoable = true) {
			var name = MetadataObject.Annotations[index].Name;
			SetAnnotation(name, value, undoable);
		}
		public string GetNewAnnotationName() {
			return MetadataObject.Annotations.GetNewName("New Annotation");
		}
		[IntelliSense("Sets the value of the annotation having the given name. If no such annotation exists, it will be created. If value is set to null, the annotation will be removed.")]
		public void SetAnnotation(string name, string value) {
		    SetAnnotation(name, value, true);
		}
		public void SetAnnotation(string name, string value, bool undoable) {
			if(name == null) name = GetNewAnnotationName();

			if(value == null) {
				// Remove annotation if set to null:
				RemoveAnnotation(name, undoable);
				return;
			}

			if(GetAnnotation(name) == value) return;
			bool undoable2 = true;
			bool cancel = false;
			OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + value, ref undoable2, ref cancel);
			if (cancel) return;

			if(MetadataObject.Annotations.Contains(name)) {
				// Change existing annotation:
				var oldValue = GetAnnotation(name);
				MetadataObject.Annotations[name].Value = value;
				if (undoable) Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, oldValue));
				OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, name + ":" + value);
			} else {
				// Add new annotation:
				MetadataObject.Annotations.Add(new TOM.Annotation{ Name = name, Value = value });
				if (undoable) Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, null));
				OnPropertyChanged(Properties.ANNOTATIONS, null, name + ":" + value);
			}

		}
		[IntelliSense("Remove an annotation by the given name.")]
		public void RemoveAnnotation(string name) {
		    RemoveAnnotation(name, true);
		}
		public void RemoveAnnotation(string name, bool undoable) {
			if(MetadataObject.Annotations.Contains(name)) {
				// Get current value:
				bool undoable2 = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + GetAnnotation(name), ref undoable2, ref cancel);
				if (cancel) return;

				var oldValue = MetadataObject.Annotations[name].Value;
				MetadataObject.Annotations.Remove(name);

				// Undo-handling:
				if (undoable) Handler.UndoManager.Add(new UndoAnnotationAction(this, name, null, oldValue));
				OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, null);
			}
		}
		[IntelliSense("Gets the number of annotations on the current object.")]
		public int GetAnnotationsCount() {
			return MetadataObject.Annotations.Count;
		}
		[IntelliSense("Gets a collection of all annotation names on the current object.")]
		public IEnumerable<string> GetAnnotations() {
			return MetadataObject.Annotations.Select(a => a.Name);
		}

		        [DisplayName("Extended Properties"),NoMultiselect,Category("Translations and Perspectives"),Description("The collection of Extended Properties on this object."),Editor(typeof(ExtendedPropertyCollectionEditor), typeof(UITypeEditor))]
		public ExtendedPropertyCollection ExtendedProperties { get; private set; }

		[IntelliSense("Returns true if an ExtendedProperty with the given name exists. Otherwise false.")]
		public bool HasExtendedProperty(string name) {
		    return MetadataObject.ExtendedProperties.ContainsName(name);
		}
		public ExtendedPropertyType GetExtendedPropertyType(int index) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[index].Type;
		}
		public ExtendedPropertyType GetExtendedPropertyType(string name) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[name].Type;
		}
		public string GetExtendedProperty(int index) {
			var ep = MetadataObject.ExtendedProperties[index];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		[IntelliSense("Gets the value of the ExtendedProperty with the given name. Returns null if no such ExtendedProperty exists.")]
		public string GetExtendedProperty(string name) {
		    if(!HasExtendedProperty(name)) return null;
			var ep = MetadataObject.ExtendedProperties[name];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		public void SetExtendedProperty(int index, string value, ExtendedPropertyType type = ExtendedPropertyType.String) {
			var name = MetadataObject.ExtendedProperties[index].Name;
			SetExtendedProperty(name, value, type);
		}
		public string GetNewExtendedPropertyName() {
			return MetadataObject.ExtendedProperties.GetNewName("New ExtendedProperty");
		}
		[IntelliSense("Sets the value of the ExtendedProperty having the given name. If no such ExtendedProperty exists, it will be created. If value is set to null, the ExtendedProperty will be removed.")]
		public void SetExtendedProperty(string name, string value, ExtendedPropertyType type = ExtendedPropertyType.String) {
			if(name == null) name = GetNewExtendedPropertyName();

			if(value == null) {
				// Remove ExtendedProperty if set to null:
				RemoveExtendedProperty(name);
				return;
			}

			if(GetExtendedProperty(name) == value) return;
			bool undoable = true;
			bool cancel = false;
			OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + value, ref undoable, ref cancel);
			if (cancel) return;

			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Change existing ExtendedProperty:
				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				var ep = MetadataObject.ExtendedProperties[name];
				if (ep is TOM.JsonExtendedProperty)
					(ep as TOM.JsonExtendedProperty).Value = value;
				else 
					(ep as TOM.StringExtendedProperty).Value = value;
					
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, name + ":" + value);
			} else {
				// Add new ExtendedProperty:
				if (type == ExtendedPropertyType.Json)
					MetadataObject.ExtendedProperties.Add(new TOM.JsonExtendedProperty{ Name = name, Value = value });
				else
					MetadataObject.ExtendedProperties.Add(new TOM.StringExtendedProperty{ Name = name, Value = value });

				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, null, type));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, null, name + ":" + value);
			}

		}
		[IntelliSense("Remove an ExtendedProperty by the given name.")]
		public void RemoveExtendedProperty(string name) {
			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Get current value:
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + GetExtendedProperty(name), ref undoable, ref cancel);
				if (cancel) return;

				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				MetadataObject.ExtendedProperties.Remove(name);

				// Undo-handling:
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, null, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, null);
			}
		}
		[IntelliSense("Gets the number of ExtendedProperties on the current object.")]
		public int GetExtendedPropertyCount() {
			return MetadataObject.ExtendedProperties.Count;
		}
		[IntelliSense("Gets a collection of all ExtendedProperty names on the current object.")]
		public IEnumerable<string> GetExtendedProperties() {
			return MetadataObject.ExtendedProperties.Select(a => a.Name);
		}

		/// <summary>
///             The description of the perspective, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio.
///             </summary>
		[DisplayName("Description")]
		[Category("Basic"),Description(@"The description of the perspective, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio."),IntelliSense(@"The description of the perspective, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio.")][Editor(typeof(System.ComponentModel.Design.MultilineStringEditor), typeof(System.Drawing.Design.UITypeEditor))]
		public string Description {
			get {
			    return MetadataObject.Description;
			}
			set {
				
				var oldValue = Description;
				var newValue = value.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DESCRIPTION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.Description = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DESCRIPTION, oldValue, newValue));
				OnPropertyChanged(Properties.DESCRIPTION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeDescription() { return false; }

        /// <summary>
        /// Collection of localized descriptions for this Perspective.
        /// </summary>
        [Browsable(true),DisplayName("Translated Descriptions"),Description("Shows all translated descriptions of this object."),Category("Translations and Perspectives")]
	    public TranslationIndexer TranslatedDescriptions { private set; get; }
        /// <summary>
        /// Collection of localized names for this Perspective.
        /// </summary>
        [Browsable(true),DisplayName("Translated Names"),Description("Shows all translated names of this object."),Category("Translations and Perspectives")]
	    public TranslationIndexer TranslatedNames { private set; get; }

		internal static Perspective CreateFromMetadata(Model parent, TOM.Perspective metadataObject) {
			var obj = new Perspective(metadataObject);
			parent.Perspectives.Add(obj);
			
			obj.Init();

			return obj;
		}


		/// <summary>
		/// Creates a new Perspective and adds it to the parent Model.
		/// Also creates the underlying metadataobject and adds it to the TOM tree.
		/// </summary>
		public static Perspective CreateNew(Model parent, string name = null)
		{
			if(TabularModelHandler.Singleton.UsePowerBIGovernance && !PowerBI.PowerBIGovernance.AllowCreate(typeof(Perspective))) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(Perspective).GetTypeName()));
			}

			var metadataObject = new TOM.Perspective();
			metadataObject.Name = parent.Perspectives.GetNewName(string.IsNullOrWhiteSpace(name) ? "New " + typeof(Perspective).GetTypeName() : name);

			var obj = new Perspective(metadataObject);

			parent.Perspectives.Add(obj);
			
			obj.Init();

			return obj;
		}

		/// <summary>
		/// Creates a new Perspective and adds it to the current Model.
		/// Also creates the underlying metadataobject and adds it to the TOM tree.
		/// </summary>		
		public static Perspective CreateNew(string name = null)
		{
			return CreateNew(TabularModelHandler.Singleton.Model, name);
		}


		/// <summary>
		/// Creates an exact copy of this Perspective object.
		/// </summary>
		public Perspective Clone(string newName = null, bool includeTranslations = true) {
			if(TabularModelHandler.Singleton.UsePowerBIGovernance && !PowerBI.PowerBIGovernance.AllowCreate(typeof(Perspective))) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(Perspective).GetTypeName()));
			}

		    Handler.BeginUpdate("Clone Perspective");

			// Create a clone of the underlying metadataobject:
			var tom = MetadataObject.Clone() as TOM.Perspective;


			// Assign a new, unique name:
			tom.Name = Parent.Perspectives.GetNewName(string.IsNullOrEmpty(newName) ? tom.Name + " copy" : newName);
				
			// Create the TOM Wrapper object, representing the metadataobject
			Perspective obj = CreateFromMetadata(Parent, tom);

			// Copy translations, if applicable:
			if(includeTranslations) {
				obj.CopyTranslationsFrom(this);
			}
            Handler.EndUpdate();

            return obj;
		}

		TabularNamedObject IClonableObject.Clone(string newName, bool includeTranslations, TabularNamedObject newParent) 
		{
			if (newParent != null) throw new ArgumentException("This object can not be cloned to another parent. Argument newParent should be left as null.", "newParent");
			return Clone(newName, includeTranslations);
		}

	
        internal override void RenewMetadataObject()
        {
            Handler.WrapperLookup.Remove(MetadataObject);
            MetadataObject = MetadataObject.Clone() as TOM.Perspective;
            Handler.WrapperLookup.Add(MetadataObject, this);
        }

		public Model Parent { 
			get {
				return Handler.WrapperLookup[MetadataObject.Parent] as Model;
			}
		}



		/// <summary>
		/// CTOR - only called from static factory methods on the class
		/// </summary>
		Perspective(TOM.Perspective metadataObject) : base(metadataObject)
		{
			// Create indexers for translations:
			TranslatedNames = new TranslationIndexer(this, TOM.TranslatedProperty.Caption);
			TranslatedDescriptions = new TranslationIndexer(this, TOM.TranslatedProperty.Description);
			
			// Create indexer for annotations:
			Annotations = new AnnotationCollection(this);
			
			// Create indexer for extended properties:
			ExtendedProperties = new ExtendedPropertyCollection(this);
		}



		internal override void Undelete(ITabularObjectCollection collection) {
			base.Undelete(collection);
			Reinit();
			ReapplyReferences();
		}

		public override bool Browsable(string propertyName) {
			switch (propertyName) {
 
				case Properties.EXTENDEDPROPERTIES:
					return Handler.CompatibilityLevel >= 1400;
				case Properties.PARENT:
					return false;
				
				// Hides translation properties in the grid, unless the model actually contains translations:
				case Properties.TRANSLATEDNAMES:
				case Properties.TRANSLATEDDESCRIPTIONS:
					return Model.Cultures.Any();
				
				default:
					return base.Browsable(propertyName);
			}
		}

    }


	/// <summary>
	/// Collection class for Perspective. Provides convenient properties for setting a property on multiple objects at once.
	/// </summary>
	public sealed partial class PerspectiveCollection: TabularObjectCollection<Perspective>
	{
		internal Model Model { get { return Parent as Model; } }
		TOM.PerspectiveCollection TOM_Collection;
		internal PerspectiveCollection(string collectionName, TOM.PerspectiveCollection metadataObjectCollection, Model parent) : base(collectionName, parent)
		{
			TOM_Collection = metadataObjectCollection;
		}
		internal override Type GetItemType() { return typeof(Perspective); }
        protected override void TOM_Add(TOM.MetadataObject obj) { TOM_Collection.Add(obj as TOM.Perspective); }
        protected override bool TOM_Contains(TOM.MetadataObject obj) { return TOM_Collection.Contains(obj as TOM.Perspective); }
        protected override void TOM_Remove(TOM.MetadataObject obj) { TOM_Collection.Remove(obj as TOM.Perspective); }
        protected override void TOM_Clear() { TOM_Collection.Clear(); }
        protected override bool TOM_ContainsName(string name) { return TOM_Collection.ContainsName(name); }
        protected override TOM.MetadataObject TOM_Get(int index) { return TOM_Collection[index]; }
        protected override TOM.MetadataObject TOM_Get(string name) { return TOM_Collection[name]; }
        internal override string GetNewName(string prefix = null) { return string.IsNullOrEmpty(prefix) ? TOM_Collection.GetNewName() : TOM_Collection.GetNewName(prefix); }
        public override int IndexOf(TOM.MetadataObject obj) { return TOM_Collection.IndexOf(obj as TOM.Perspective); }
        public override int Count { get { return TOM_Collection.Count; } }
        public override IEnumerator<Perspective> GetEnumerator() { return TOM_Collection.Select(h => Handler.WrapperLookup[h]).OfType<Perspective>().GetEnumerator(); }
		internal override void Reinit() {
			var ixOffset = 0;
			for(int i = 0; i < Count; i++) {
				var item = this[i];
				Handler.WrapperLookup.Remove(item.MetadataObject);
				item.MetadataObject = Model.MetadataObject.Perspectives[i + ixOffset] as TOM.Perspective;
				Handler.WrapperLookup.Add(item.MetadataObject, item);
				item.Collection = this;
			}
			TOM_Collection = Model.MetadataObject.Perspectives;
			foreach(var item in this) item.Reinit();
		}

		internal override void ReapplyReferences() {
			foreach(var item in this) item.ReapplyReferences();
		}

		/// <summary>
		/// Calling this method will populate the PerspectiveCollection with objects based on the MetadataObjects in the corresponding MetadataObjectCollection.
		/// </summary>
		internal override void CreateChildrenFromMetadata()
		{
			// Construct child objects (they are automatically added to the Handler's WrapperLookup dictionary):
			foreach(var obj in TOM_Collection) {
				if(obj is TOM.Perspective) Perspective.CreateFromMetadata(Model, obj as TOM.Perspective);
		    }
		}

		/// <summary>
		/// Sets the Description property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the Description property of all objects in the collection at once.")]
		public string Description {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("Description"));
				this.ToList().ForEach(item => { item.Description = value; });
				Handler.UndoManager.EndBatch();
			}
		}

		public override string ToString() {
			return string.Format("({0} {1})", Count, (Count == 1 ? "Perspective" : "Perspectives").ToLower());
		}
	}
  
	/// <summary>
///             Represents a data source that uses a connection string for the connection.
///             </summary>
	[TypeConverter(typeof(DynamicPropertyConverter))]
	public sealed partial class ProviderDataSource: DataSource
			, IClonableObject
	{
	    internal new TOM.ProviderDataSource MetadataObject 
		{ 
			get 
			{ 
				return base.MetadataObject as TOM.ProviderDataSource; 
		    } 
			set 
			{ 
				base.MetadataObject = value; 
			}
		}

/// <summary>
///             A string used to open the connection to the data source.
///             </summary>
		[DisplayName("Connection String")]
		[Category("Connection Details"),Description(@"A string used to open the connection to the data source."),IntelliSense(@"A string used to open the connection to the data source.")][Editor(typeof(CustomDialogEditor), typeof(System.Drawing.Design.UITypeEditor))]
		public string ConnectionString {
			get {
			    return MetadataObject.ConnectionString;
			}
			set {
				
				var oldValue = ConnectionString;
				var newValue = value.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.CONNECTIONSTRING, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.ConnectionString = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.CONNECTIONSTRING, oldValue, newValue));
				OnPropertyChanged(Properties.CONNECTIONSTRING, oldValue, newValue);
			}
		}
		private bool ShouldSerializeConnectionString() { return false; }
/// <summary>
///             Determines how credentials are obtained for an impersonated connection to a data source during data import or refresh.
///             </summary>
		[DisplayName("Impersonation Mode")]
		[Category("Connection Details"),Description(@"Determines how credentials are obtained for an impersonated connection to a data source during data import or refresh."),IntelliSense(@"Determines how credentials are obtained for an impersonated connection to a data source during data import or refresh.")]
		public ImpersonationMode ImpersonationMode {
			get {
			    return (ImpersonationMode)MetadataObject.ImpersonationMode;
			}
			set {
				
				var oldValue = ImpersonationMode;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.IMPERSONATIONMODE, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.ImpersonationMode = (TOM.ImpersonationMode)newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.IMPERSONATIONMODE, oldValue, newValue));
				OnPropertyChanged(Properties.IMPERSONATIONMODE, oldValue, newValue);
			}
		}
		private bool ShouldSerializeImpersonationMode() { return false; }
/// <summary>
///             The user account used for impersonation.
///             </summary>
		[DisplayName("Account")]
		[Category("Connection Details"),Description(@"The user account used for impersonation."),IntelliSense(@"The user account used for impersonation.")]
		public string Account {
			get {
			    return MetadataObject.Account;
			}
			set {
				
				var oldValue = Account;
				var newValue = value.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ACCOUNT, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.Account = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.ACCOUNT, oldValue, newValue));
				OnPropertyChanged(Properties.ACCOUNT, oldValue, newValue);
			}
		}
		private bool ShouldSerializeAccount() { return false; }
/// <summary>
///             The account password.
///             </summary>
		[DisplayName("Password")]
		[Category("Connection Details"),Description(@"The account password."),IntelliSense(@"The account password.")][PasswordPropertyText(true)]
		public string Password {
			get {
			    return MetadataObject.Password;
			}
			set {
				
				var oldValue = Password;
				var newValue = value.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.PASSWORD, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.Password = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.PASSWORD, oldValue, newValue));
				OnPropertyChanged(Properties.PASSWORD, oldValue, newValue);
			}
		}
		private bool ShouldSerializePassword() { return false; }
/// <summary>
///             Specifies the locking behavior of the SQL statements when executing commands against the data source. Valid values include ReadCommitted (default) which only reads from committed transactions, or Snapshot which can read any statement in a transaction that is transactionally consistent.
///             </summary>
		[DisplayName("Isolation")]
		[Category("Connection Details"),Description(@"Specifies the locking behavior of the SQL statements when executing commands against the data source. Valid values include ReadCommitted (default) which only reads from committed transactions, or Snapshot which can read any statement in a transaction that is transactionally consistent."),IntelliSense(@"Specifies the locking behavior of the SQL statements when executing commands against the data source. Valid values include ReadCommitted (default) which only reads from committed transactions, or Snapshot which can read any statement in a transaction that is transactionally consistent.")]
		public DatasourceIsolation Isolation {
			get {
			    return (DatasourceIsolation)MetadataObject.Isolation;
			}
			set {
				
				var oldValue = Isolation;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ISOLATION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.Isolation = (TOM.DatasourceIsolation)newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.ISOLATION, oldValue, newValue));
				OnPropertyChanged(Properties.ISOLATION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeIsolation() { return false; }
/// <summary>
///             The timeout in seconds for commands executed against the data source.
///             </summary>
		[DisplayName("Timeout")]
		[Category("Connection Details"),Description(@"The timeout in seconds for commands executed against the data source."),IntelliSense(@"The timeout in seconds for commands executed against the data source.")]
		public int Timeout {
			get {
			    return MetadataObject.Timeout;
			}
			set {
				
				var oldValue = Timeout;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.TIMEOUT, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.Timeout = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.TIMEOUT, oldValue, newValue));
				OnPropertyChanged(Properties.TIMEOUT, oldValue, newValue);
			}
		}
		private bool ShouldSerializeTimeout() { return false; }
/// <summary>
///             An optional string that identifies the name of the managed data provider for the data source.
///             </summary>
		[DisplayName("Provider")]
		[Category("Connection Details"),Description(@"An optional string that identifies the name of the managed data provider for the data source."),IntelliSense(@"An optional string that identifies the name of the managed data provider for the data source.")]
		public string Provider {
			get {
			    return MetadataObject.Provider;
			}
			set {
				
				var oldValue = Provider;
				var newValue = value.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.PROVIDER, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.Provider = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.PROVIDER, oldValue, newValue));
				OnPropertyChanged(Properties.PROVIDER, oldValue, newValue);
			}
		}
		private bool ShouldSerializeProvider() { return false; }

		internal static ProviderDataSource CreateFromMetadata(Model parent, TOM.ProviderDataSource metadataObject) {
			var obj = new ProviderDataSource(metadataObject);
			parent.DataSources.Add(obj);
			
			obj.Init();

			return obj;
		}


		/// <summary>
		/// Creates a new ProviderDataSource and adds it to the parent Model.
		/// Also creates the underlying metadataobject and adds it to the TOM tree.
		/// </summary>
		public static ProviderDataSource CreateNew(Model parent, string name = null)
		{
			if(TabularModelHandler.Singleton.UsePowerBIGovernance && !PowerBI.PowerBIGovernance.AllowCreate(typeof(ProviderDataSource))) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(ProviderDataSource).GetTypeName()));
			}

			var metadataObject = new TOM.ProviderDataSource();
			metadataObject.Name = parent.DataSources.GetNewName(string.IsNullOrWhiteSpace(name) ? "New " + typeof(ProviderDataSource).GetTypeName() : name);

			var obj = new ProviderDataSource(metadataObject);

			parent.DataSources.Add(obj);
			
			obj.Init();

			return obj;
		}

		/// <summary>
		/// Creates a new ProviderDataSource and adds it to the current Model.
		/// Also creates the underlying metadataobject and adds it to the TOM tree.
		/// </summary>		
		public static ProviderDataSource CreateNew(string name = null)
		{
			return CreateNew(TabularModelHandler.Singleton.Model, name);
		}


		/// <summary>
		/// Creates an exact copy of this ProviderDataSource object.
		/// </summary>
		public ProviderDataSource Clone(string newName = null) {
			if(TabularModelHandler.Singleton.UsePowerBIGovernance && !PowerBI.PowerBIGovernance.AllowCreate(typeof(ProviderDataSource))) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(ProviderDataSource).GetTypeName()));
			}

		    Handler.BeginUpdate("Clone ProviderDataSource");

			// Create a clone of the underlying metadataobject:
			var tom = MetadataObject.Clone() as TOM.ProviderDataSource;


			// Assign a new, unique name:
			tom.Name = Parent.DataSources.GetNewName(string.IsNullOrEmpty(newName) ? tom.Name + " copy" : newName);
				
			// Create the TOM Wrapper object, representing the metadataobject
			ProviderDataSource obj = CreateFromMetadata(Parent, tom);

            Handler.EndUpdate();

            return obj;
		}

		TabularNamedObject IClonableObject.Clone(string newName, bool includeTranslations, TabularNamedObject newParent) 
		{
			if (newParent != null) throw new ArgumentException("This object can not be cloned to another parent. Argument newParent should be left as null.", "newParent");
			return Clone(newName);
		}

	
        internal override void RenewMetadataObject()
        {
            Handler.WrapperLookup.Remove(MetadataObject);
            MetadataObject = MetadataObject.Clone() as TOM.ProviderDataSource;
            Handler.WrapperLookup.Add(MetadataObject, this);
        }

		public new Model Parent { 
			get {
				return Handler.WrapperLookup[MetadataObject.Parent] as Model;
			}
		}



		/// <summary>
		/// CTOR - only called from static factory methods on the class
		/// </summary>
		ProviderDataSource(TOM.ProviderDataSource metadataObject) : base(metadataObject)
		{
		}



		internal override void Undelete(ITabularObjectCollection collection) {
			base.Undelete(collection);
			Reinit();
			ReapplyReferences();
		}

		public override bool Browsable(string propertyName) {
			switch (propertyName) {
				case Properties.PARENT:
					return false;
				
				default:
					return base.Browsable(propertyName);
			}
		}

    }

  
	/// <summary>
///             Represents a logical relationship between two Table objects. It is a child of a Model object.
///             </summary>
	[TypeConverter(typeof(DynamicPropertyConverter))]
	public abstract partial class Relationship: TabularNamedObject
			, IAnnotationObject
			, IExtendedPropertyObject
	{
	    internal new TOM.Relationship MetadataObject 
		{ 
			get 
			{ 
				return base.MetadataObject as TOM.Relationship; 
		    } 
			set 
			{ 
				base.MetadataObject = value; 
			}
		}

/// <summary>
///             Gets the destination table in a directional table relationship.
///             </summary>
		[DisplayName("To Table")]
		[Category("Other"),Description(@"Gets the destination table in a directional table relationship."),IntelliSense(@"Gets the destination table in a directional table relationship.")]
		public Table ToTable {
			get {
				if (MetadataObject.ToTable == null) return null;
			    return Handler.WrapperLookup[MetadataObject.ToTable] as Table;
            }
			
		}
		private bool ShouldSerializeToTable() { return false; }
/// <summary>
///             Gets the starting table in a directional table relationship.
///             </summary>
		[DisplayName("From Table")]
		[Category("Other"),Description(@"Gets the starting table in a directional table relationship."),IntelliSense(@"Gets the starting table in a directional table relationship.")]
		public Table FromTable {
			get {
				if (MetadataObject.FromTable == null) return null;
			    return Handler.WrapperLookup[MetadataObject.FromTable] as Table;
            }
			
		}
		private bool ShouldSerializeFromTable() { return false; }
        [Browsable(true),NoMultiselect,Category("Translations and Perspectives"),Description("The collection of Annotations on this object."),Editor(typeof(AnnotationCollectionEditor), typeof(UITypeEditor))]
		public AnnotationCollection Annotations { get; private set; }
		public string GetAnnotation(int index) {
			return MetadataObject.Annotations[index].Value;
		}
		[IntelliSense("Returns true if an annotation with the given name exists. Otherwise false.")]
		public bool HasAnnotation(string name) {
		    return MetadataObject.Annotations.ContainsName(name);
		}
		[IntelliSense("Gets the value of the annotation with the given name. Returns null if no such annotation exists.")]
		public string GetAnnotation(string name) {
		    return HasAnnotation(name) ? MetadataObject.Annotations[name].Value : null;
		}
		public void SetAnnotation(int index, string value, bool undoable = true) {
			var name = MetadataObject.Annotations[index].Name;
			SetAnnotation(name, value, undoable);
		}
		public string GetNewAnnotationName() {
			return MetadataObject.Annotations.GetNewName("New Annotation");
		}
		[IntelliSense("Sets the value of the annotation having the given name. If no such annotation exists, it will be created. If value is set to null, the annotation will be removed.")]
		public void SetAnnotation(string name, string value) {
		    SetAnnotation(name, value, true);
		}
		public void SetAnnotation(string name, string value, bool undoable) {
			if(name == null) name = GetNewAnnotationName();

			if(value == null) {
				// Remove annotation if set to null:
				RemoveAnnotation(name, undoable);
				return;
			}

			if(GetAnnotation(name) == value) return;
			bool undoable2 = true;
			bool cancel = false;
			OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + value, ref undoable2, ref cancel);
			if (cancel) return;

			if(MetadataObject.Annotations.Contains(name)) {
				// Change existing annotation:
				var oldValue = GetAnnotation(name);
				MetadataObject.Annotations[name].Value = value;
				if (undoable) Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, oldValue));
				OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, name + ":" + value);
			} else {
				// Add new annotation:
				MetadataObject.Annotations.Add(new TOM.Annotation{ Name = name, Value = value });
				if (undoable) Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, null));
				OnPropertyChanged(Properties.ANNOTATIONS, null, name + ":" + value);
			}

		}
		[IntelliSense("Remove an annotation by the given name.")]
		public void RemoveAnnotation(string name) {
		    RemoveAnnotation(name, true);
		}
		public void RemoveAnnotation(string name, bool undoable) {
			if(MetadataObject.Annotations.Contains(name)) {
				// Get current value:
				bool undoable2 = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + GetAnnotation(name), ref undoable2, ref cancel);
				if (cancel) return;

				var oldValue = MetadataObject.Annotations[name].Value;
				MetadataObject.Annotations.Remove(name);

				// Undo-handling:
				if (undoable) Handler.UndoManager.Add(new UndoAnnotationAction(this, name, null, oldValue));
				OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, null);
			}
		}
		[IntelliSense("Gets the number of annotations on the current object.")]
		public int GetAnnotationsCount() {
			return MetadataObject.Annotations.Count;
		}
		[IntelliSense("Gets a collection of all annotation names on the current object.")]
		public IEnumerable<string> GetAnnotations() {
			return MetadataObject.Annotations.Select(a => a.Name);
		}

		        [DisplayName("Extended Properties"),NoMultiselect,Category("Translations and Perspectives"),Description("The collection of Extended Properties on this object."),Editor(typeof(ExtendedPropertyCollectionEditor), typeof(UITypeEditor))]
		public ExtendedPropertyCollection ExtendedProperties { get; private set; }

		[IntelliSense("Returns true if an ExtendedProperty with the given name exists. Otherwise false.")]
		public bool HasExtendedProperty(string name) {
		    return MetadataObject.ExtendedProperties.ContainsName(name);
		}
		public ExtendedPropertyType GetExtendedPropertyType(int index) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[index].Type;
		}
		public ExtendedPropertyType GetExtendedPropertyType(string name) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[name].Type;
		}
		public string GetExtendedProperty(int index) {
			var ep = MetadataObject.ExtendedProperties[index];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		[IntelliSense("Gets the value of the ExtendedProperty with the given name. Returns null if no such ExtendedProperty exists.")]
		public string GetExtendedProperty(string name) {
		    if(!HasExtendedProperty(name)) return null;
			var ep = MetadataObject.ExtendedProperties[name];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		public void SetExtendedProperty(int index, string value, ExtendedPropertyType type = ExtendedPropertyType.String) {
			var name = MetadataObject.ExtendedProperties[index].Name;
			SetExtendedProperty(name, value, type);
		}
		public string GetNewExtendedPropertyName() {
			return MetadataObject.ExtendedProperties.GetNewName("New ExtendedProperty");
		}
		[IntelliSense("Sets the value of the ExtendedProperty having the given name. If no such ExtendedProperty exists, it will be created. If value is set to null, the ExtendedProperty will be removed.")]
		public void SetExtendedProperty(string name, string value, ExtendedPropertyType type = ExtendedPropertyType.String) {
			if(name == null) name = GetNewExtendedPropertyName();

			if(value == null) {
				// Remove ExtendedProperty if set to null:
				RemoveExtendedProperty(name);
				return;
			}

			if(GetExtendedProperty(name) == value) return;
			bool undoable = true;
			bool cancel = false;
			OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + value, ref undoable, ref cancel);
			if (cancel) return;

			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Change existing ExtendedProperty:
				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				var ep = MetadataObject.ExtendedProperties[name];
				if (ep is TOM.JsonExtendedProperty)
					(ep as TOM.JsonExtendedProperty).Value = value;
				else 
					(ep as TOM.StringExtendedProperty).Value = value;
					
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, name + ":" + value);
			} else {
				// Add new ExtendedProperty:
				if (type == ExtendedPropertyType.Json)
					MetadataObject.ExtendedProperties.Add(new TOM.JsonExtendedProperty{ Name = name, Value = value });
				else
					MetadataObject.ExtendedProperties.Add(new TOM.StringExtendedProperty{ Name = name, Value = value });

				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, null, type));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, null, name + ":" + value);
			}

		}
		[IntelliSense("Remove an ExtendedProperty by the given name.")]
		public void RemoveExtendedProperty(string name) {
			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Get current value:
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + GetExtendedProperty(name), ref undoable, ref cancel);
				if (cancel) return;

				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				MetadataObject.ExtendedProperties.Remove(name);

				// Undo-handling:
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, null, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, null);
			}
		}
		[IntelliSense("Gets the number of ExtendedProperties on the current object.")]
		public int GetExtendedPropertyCount() {
			return MetadataObject.ExtendedProperties.Count;
		}
		[IntelliSense("Gets a collection of all ExtendedProperty names on the current object.")]
		public IEnumerable<string> GetExtendedProperties() {
			return MetadataObject.ExtendedProperties.Select(a => a.Name);
		}

		/// <summary>
///             A boolean value that indicates whether the relationship is marked as Active or Inactive. An Active relationship is automatically used for filtering across tables. An Inactive relationship can be used explicitly by DAX calculations with the USERELATIONSHIP function.
///             </summary>
		[DisplayName("Active")]
		[Category("Relationship"),Description(@"A boolean value that indicates whether the relationship is marked as Active or Inactive. An Active relationship is automatically used for filtering across tables. An Inactive relationship can be used explicitly by DAX calculations with the USERELATIONSHIP function."),IntelliSense(@"A boolean value that indicates whether the relationship is marked as Active or Inactive. An Active relationship is automatically used for filtering across tables. An Inactive relationship can be used explicitly by DAX calculations with the USERELATIONSHIP function.")]
		public bool IsActive {
			get {
			    return MetadataObject.IsActive;
			}
			set {
				
				var oldValue = IsActive;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ISACTIVE, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.IsActive = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.ISACTIVE, oldValue, newValue));
				OnPropertyChanged(Properties.ISACTIVE, oldValue, newValue);
			}
		}
		private bool ShouldSerializeIsActive() { return false; }
/// <summary>
///             The type of Relationship. At present, the only possible value is SingleColumn (1) or a normal column-column relationship.
///             </summary>
		[DisplayName("Type")]
		[Category("Other"),Description(@"The type of Relationship. At present, the only possible value is SingleColumn (1) or a normal column-column relationship."),IntelliSense(@"The type of Relationship. At present, the only possible value is SingleColumn (1) or a normal column-column relationship.")]
		public RelationshipType Type {
			get {
			    return (RelationshipType)MetadataObject.Type;
			}
			
		}
		private bool ShouldSerializeType() { return false; }
/// <summary>
///             Indicates how relationships influence filtering of data. The enumeration defines the possible behaviors. Possible values are as follows. OneDirection (1) The rows selected in the 'To' end of the relationship will automatically filter scans of the table in the 'From' end of the relationship. BothDirections (2) Filters on either end of the relationship will automatically filter the other table. Automatic (3) The engine will analyze the relationships and choose one of the behaviors by using heuristics.
///             </summary>
		[DisplayName("Cross Filtering Behavior")]
		[Category("Relationship Behavior"),Description(@"Indicates how relationships influence filtering of data. The enumeration defines the possible behaviors. Possible values are as follows. OneDirection (1) The rows selected in the 'To' end of the relationship will automatically filter scans of the table in the 'From' end of the relationship. BothDirections (2) Filters on either end of the relationship will automatically filter the other table. Automatic (3) The engine will analyze the relationships and choose one of the behaviors by using heuristics."),IntelliSense(@"Indicates how relationships influence filtering of data. The enumeration defines the possible behaviors. Possible values are as follows. OneDirection (1) The rows selected in the 'To' end of the relationship will automatically filter scans of the table in the 'From' end of the relationship. BothDirections (2) Filters on either end of the relationship will automatically filter the other table. Automatic (3) The engine will analyze the relationships and choose one of the behaviors by using heuristics.")]
		public CrossFilteringBehavior CrossFilteringBehavior {
			get {
			    return (CrossFilteringBehavior)MetadataObject.CrossFilteringBehavior;
			}
			set {
				
				var oldValue = CrossFilteringBehavior;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.CROSSFILTERINGBEHAVIOR, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.CrossFilteringBehavior = (TOM.CrossFilteringBehavior)newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.CROSSFILTERINGBEHAVIOR, oldValue, newValue));
				OnPropertyChanged(Properties.CROSSFILTERINGBEHAVIOR, oldValue, newValue);
			}
		}
		private bool ShouldSerializeCrossFilteringBehavior() { return false; }
/// <summary>
///             When joining two date time columns, indicates whether to join on date and time parts, or on date part only. DateAndTime (1) When joining two date time columns, join on date and time parts. DatePartOnly (2) When joining two date time columns, join on date part only.
///             </summary>
		[DisplayName("Join On Date Behavior")]
		[Category("Relationship Behavior"),Description(@"When joining two date time columns, indicates whether to join on date and time parts, or on date part only. DateAndTime (1) When joining two date time columns, join on date and time parts. DatePartOnly (2) When joining two date time columns, join on date part only."),IntelliSense(@"When joining two date time columns, indicates whether to join on date and time parts, or on date part only. DateAndTime (1) When joining two date time columns, join on date and time parts. DatePartOnly (2) When joining two date time columns, join on date part only.")]
		public DateTimeRelationshipBehavior JoinOnDateBehavior {
			get {
			    return (DateTimeRelationshipBehavior)MetadataObject.JoinOnDateBehavior;
			}
			set {
				
				var oldValue = JoinOnDateBehavior;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.JOINONDATEBEHAVIOR, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.JoinOnDateBehavior = (TOM.DateTimeRelationshipBehavior)newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.JOINONDATEBEHAVIOR, oldValue, newValue));
				OnPropertyChanged(Properties.JOINONDATEBEHAVIOR, oldValue, newValue);
			}
		}
		private bool ShouldSerializeJoinOnDateBehavior() { return false; }
/// <summary>
///             Unused; reserved for future use.
///             </summary>
		[DisplayName("Rely On Referential Integrity")]
		[Category("Relationship Behavior"),Description(@"If set to 'True', queries generated in DirectQuery mode will use INNER JOIN rather than OUTER JOIN."),IntelliSense(@"If set to 'True', queries generated in DirectQuery mode will use INNER JOIN rather than OUTER JOIN.")]
		public bool RelyOnReferentialIntegrity {
			get {
			    return MetadataObject.RelyOnReferentialIntegrity;
			}
			set {
				
				var oldValue = RelyOnReferentialIntegrity;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.RELYONREFERENTIALINTEGRITY, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.RelyOnReferentialIntegrity = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.RELYONREFERENTIALINTEGRITY, oldValue, newValue));
				OnPropertyChanged(Properties.RELYONREFERENTIALINTEGRITY, oldValue, newValue);
			}
		}
		private bool ShouldSerializeRelyOnReferentialIntegrity() { return false; }
/// <summary>
///             Provides information on the state of the relationship. Possible values and their interpretation are as follows. Ready (1) The relationship is queryable and has up-to-date data. NoData (3) Not applicable to relationships. CalculationNeeded (4) The relationship does not contain any data because it was not refreshed. There is no error associated with the relationship. SemanticError (5) Not applicable to Relationship. EvaluationError (6) Not applicable to Relationship. DependencyError (7) A dependency associated with this relationship is in an error state (SemanticError, EvaluationError, or DependencyError). Incomplete (8) Not applicable to relationships. SyntaxError (9) Not applicable to relationships.
///             </summary>
		[DisplayName("State")]
		[Category("Metadata"),Description(@"Provides information on the state of the relationship. Possible values and their interpretation are as follows. Ready (1) The relationship is queryable and has up-to-date data. NoData (3) Not applicable to relationships. CalculationNeeded (4) The relationship does not contain any data because it was not refreshed. There is no error associated with the relationship. SemanticError (5) Not applicable to Relationship. EvaluationError (6) Not applicable to Relationship. DependencyError (7) A dependency associated with this relationship is in an error state (SemanticError, EvaluationError, or DependencyError). Incomplete (8) Not applicable to relationships. SyntaxError (9) Not applicable to relationships."),IntelliSense(@"Provides information on the state of the relationship. Possible values and their interpretation are as follows. Ready (1) The relationship is queryable and has up-to-date data. NoData (3) Not applicable to relationships. CalculationNeeded (4) The relationship does not contain any data because it was not refreshed. There is no error associated with the relationship. SemanticError (5) Not applicable to Relationship. EvaluationError (6) Not applicable to Relationship. DependencyError (7) A dependency associated with this relationship is in an error state (SemanticError, EvaluationError, or DependencyError). Incomplete (8) Not applicable to relationships. SyntaxError (9) Not applicable to relationships.")]
		public ObjectState State {
			get {
			    return (ObjectState)MetadataObject.State;
			}
			
		}
		private bool ShouldSerializeState() { return false; }
/// <summary>
///             Indicates how relationships influence filtering of data when evaluating row-level security expressions. Possible values are as follows. OneDirection (1): The rows selected in the 'To' end of the relationship will automatically filter scans of the table in the 'From' end of the relationship. BothDirections (2): Filters on either end of the relationship will automatically filter the other table.
///             </summary>
		[DisplayName("Security Filtering Behavior")]
		[Category("Relationship Behavior"),Description(@"Indicates how relationships influence filtering of data when evaluating row-level security expressions. Possible values are as follows. OneDirection (1): The rows selected in the 'To' end of the relationship will automatically filter scans of the table in the 'From' end of the relationship. BothDirections (2): Filters on either end of the relationship will automatically filter the other table."),IntelliSense(@"Indicates how relationships influence filtering of data when evaluating row-level security expressions. Possible values are as follows. OneDirection (1): The rows selected in the 'To' end of the relationship will automatically filter scans of the table in the 'From' end of the relationship. BothDirections (2): Filters on either end of the relationship will automatically filter the other table.")]
		public SecurityFilteringBehavior SecurityFilteringBehavior {
			get {
			    return (SecurityFilteringBehavior)MetadataObject.SecurityFilteringBehavior;
			}
			set {
				
				var oldValue = SecurityFilteringBehavior;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.SECURITYFILTERINGBEHAVIOR, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.SecurityFilteringBehavior = (TOM.SecurityFilteringBehavior)newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.SECURITYFILTERINGBEHAVIOR, oldValue, newValue));
				OnPropertyChanged(Properties.SECURITYFILTERINGBEHAVIOR, oldValue, newValue);
			}
		}
		private bool ShouldSerializeSecurityFilteringBehavior() { return false; }

	
        internal override void RenewMetadataObject()
        {
            Handler.WrapperLookup.Remove(MetadataObject);
            MetadataObject = MetadataObject.Clone() as TOM.Relationship;
            Handler.WrapperLookup.Add(MetadataObject, this);
        }

		public Model Parent { 
			get {
				return Handler.WrapperLookup[MetadataObject.Parent] as Model;
			}
		}



		/// <summary>
		/// CTOR - only called from static factory methods on the class
		/// </summary>
		protected Relationship(TOM.Relationship metadataObject) : base(metadataObject)
		{
			
			// Create indexer for annotations:
			Annotations = new AnnotationCollection(this);
			
			// Create indexer for extended properties:
			ExtendedProperties = new ExtendedPropertyCollection(this);
		}



		internal override void Undelete(ITabularObjectCollection collection) {
			base.Undelete(collection);
			Reinit();
			ReapplyReferences();
		}

		public override bool Browsable(string propertyName) {
			switch (propertyName) {
 
				case Properties.EXTENDEDPROPERTIES:
					return Handler.CompatibilityLevel >= 1400;
				case Properties.PARENT:
					return false;
				
				default:
					return base.Browsable(propertyName);
			}
		}

    }


	/// <summary>
	/// Collection class for Relationship. Provides convenient properties for setting a property on multiple objects at once.
	/// </summary>
	public sealed partial class RelationshipCollection: TabularObjectCollection<SingleColumnRelationship>
	{
		internal Model Model { get { return Parent as Model; } }
		TOM.RelationshipCollection TOM_Collection;
		internal RelationshipCollection(string collectionName, TOM.RelationshipCollection metadataObjectCollection, Model parent) : base(collectionName, parent)
		{
			TOM_Collection = metadataObjectCollection;
		}
		internal override Type GetItemType() { return typeof(Relationship); }
        protected override void TOM_Add(TOM.MetadataObject obj) { TOM_Collection.Add(obj as TOM.Relationship); }
        protected override bool TOM_Contains(TOM.MetadataObject obj) { return TOM_Collection.Contains(obj as TOM.Relationship); }
        protected override void TOM_Remove(TOM.MetadataObject obj) { TOM_Collection.Remove(obj as TOM.Relationship); }
        protected override void TOM_Clear() { TOM_Collection.Clear(); }
        protected override bool TOM_ContainsName(string name) { return TOM_Collection.ContainsName(name); }
        protected override TOM.MetadataObject TOM_Get(int index) { return TOM_Collection[index]; }
        protected override TOM.MetadataObject TOM_Get(string name) { return TOM_Collection[name]; }
 
		internal override string GetNewName(string prefix = null) { return Guid.NewGuid().ToString(); }
        public override int IndexOf(TOM.MetadataObject obj) { return TOM_Collection.IndexOf(obj as TOM.Relationship); }
        public override int Count { get { return TOM_Collection.Count; } }
        public override IEnumerator<SingleColumnRelationship> GetEnumerator() { return TOM_Collection.Select(h => Handler.WrapperLookup[h]).OfType<SingleColumnRelationship>().GetEnumerator(); }
		internal override void Reinit() {
			var ixOffset = 0;
			for(int i = 0; i < Count; i++) {
				var item = this[i];
				Handler.WrapperLookup.Remove(item.MetadataObject);
				item.MetadataObject = Model.MetadataObject.Relationships[i + ixOffset] as TOM.SingleColumnRelationship;
				Handler.WrapperLookup.Add(item.MetadataObject, item);
				item.Collection = this;
			}
			TOM_Collection = Model.MetadataObject.Relationships;
			foreach(var item in this) item.Reinit();
		}

		internal override void ReapplyReferences() {
			foreach(var item in this) item.ReapplyReferences();
		}

		/// <summary>
		/// Calling this method will populate the RelationshipCollection with objects based on the MetadataObjects in the corresponding MetadataObjectCollection.
		/// </summary>
		internal override void CreateChildrenFromMetadata()
		{
			// Construct child objects (they are automatically added to the Handler's WrapperLookup dictionary):
			foreach(var obj in TOM_Collection) {
				if(obj is TOM.SingleColumnRelationship) SingleColumnRelationship.CreateFromMetadata(Model, obj as TOM.SingleColumnRelationship);
		    }
		}

		/// <summary>
		/// Sets the IsActive property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the IsActive property of all objects in the collection at once.")]
		public bool IsActive {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("IsActive"));
				this.ToList().ForEach(item => { item.IsActive = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the CrossFilteringBehavior property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the CrossFilteringBehavior property of all objects in the collection at once.")]
		public CrossFilteringBehavior CrossFilteringBehavior {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("CrossFilteringBehavior"));
				this.ToList().ForEach(item => { item.CrossFilteringBehavior = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the JoinOnDateBehavior property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the JoinOnDateBehavior property of all objects in the collection at once.")]
		public DateTimeRelationshipBehavior JoinOnDateBehavior {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("JoinOnDateBehavior"));
				this.ToList().ForEach(item => { item.JoinOnDateBehavior = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the RelyOnReferentialIntegrity property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the RelyOnReferentialIntegrity property of all objects in the collection at once.")]
		public bool RelyOnReferentialIntegrity {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("RelyOnReferentialIntegrity"));
				this.ToList().ForEach(item => { item.RelyOnReferentialIntegrity = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the SecurityFilteringBehavior property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the SecurityFilteringBehavior property of all objects in the collection at once.")]
		public SecurityFilteringBehavior SecurityFilteringBehavior {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("SecurityFilteringBehavior"));
				this.ToList().ForEach(item => { item.SecurityFilteringBehavior = value; });
				Handler.UndoManager.EndBatch();
			}
		}

		public override string ToString() {
			return string.Format("({0} {1})", Count, (Count == 1 ? "Relationship" : "Relationships").ToLower());
		}
	}
  
	/// <summary>
///             SingleColumnRelationship object.
///             </summary>
	[TypeConverter(typeof(DynamicPropertyConverter))]
	public sealed partial class SingleColumnRelationship: Relationship
			, IClonableObject
	{
	    internal new TOM.SingleColumnRelationship MetadataObject 
		{ 
			get 
			{ 
				return base.MetadataObject as TOM.SingleColumnRelationship; 
		    } 
			set 
			{ 
				base.MetadataObject = value; 
			}
		}

/// <summary>
///             Gets or sets the starting column in a single column relationship.
///             </summary>
		[DisplayName("From Column")]
		[Category("Relationship"),Description(@"Gets or sets the starting column in a single column relationship."),IntelliSense(@"Gets or sets the starting column in a single column relationship.")][TypeConverter(typeof(AllColumnConverter))]
		public Column FromColumn {
			get {
				if (MetadataObject.FromColumn == null) return null;
			    return Handler.WrapperLookup[MetadataObject.FromColumn] as Column;
            }
			set {
				
				var oldValue = FromColumn;
				var newValue = value;
				if (oldValue?.MetadataObject == newValue?.MetadataObject) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.FROMCOLUMN, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.FromColumn = value?.MetadataObject;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.FROMCOLUMN, oldValue, newValue));
				OnPropertyChanged(Properties.FROMCOLUMN, oldValue, newValue);
			}
		}
		private bool ShouldSerializeFromColumn() { return false; }
/// <summary>
///             Gets or sets the destination column in a single column relationship.
///             </summary>
		[DisplayName("To Column")]
		[Category("Relationship"),Description(@"Gets or sets the destination column in a single column relationship."),IntelliSense(@"Gets or sets the destination column in a single column relationship.")][TypeConverter(typeof(AllColumnConverter))]
		public Column ToColumn {
			get {
				if (MetadataObject.ToColumn == null) return null;
			    return Handler.WrapperLookup[MetadataObject.ToColumn] as Column;
            }
			set {
				
				var oldValue = ToColumn;
				var newValue = value;
				if (oldValue?.MetadataObject == newValue?.MetadataObject) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.TOCOLUMN, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.ToColumn = value?.MetadataObject;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.TOCOLUMN, oldValue, newValue));
				OnPropertyChanged(Properties.TOCOLUMN, oldValue, newValue);
			}
		}
		private bool ShouldSerializeToColumn() { return false; }
/// <summary>
///             Indicates whether the "From" end of the relationship has a cardinality of One (1) or Many (2).
///             </summary>
		[DisplayName("From Cardinality")]
		[Category("Relationship"),Description(@"Indicates whether the ""From"" end of the relationship has a cardinality of One (1) or Many (2)."),IntelliSense(@"Indicates whether the ""From"" end of the relationship has a cardinality of One (1) or Many (2).")]
		public RelationshipEndCardinality FromCardinality {
			get {
			    return (RelationshipEndCardinality)MetadataObject.FromCardinality;
			}
			set {
				
				var oldValue = FromCardinality;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.FROMCARDINALITY, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.FromCardinality = (TOM.RelationshipEndCardinality)newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.FROMCARDINALITY, oldValue, newValue));
				OnPropertyChanged(Properties.FROMCARDINALITY, oldValue, newValue);
			}
		}
		private bool ShouldSerializeFromCardinality() { return false; }
/// <summary>
///             Indicates whether the "To" end of the relationship has a cardinality of One (1) or Many (2).
///             </summary>
		[DisplayName("To Cardinality")]
		[Category("Relationship"),Description(@"Indicates whether the ""To"" end of the relationship has a cardinality of One (1) or Many (2)."),IntelliSense(@"Indicates whether the ""To"" end of the relationship has a cardinality of One (1) or Many (2).")]
		public RelationshipEndCardinality ToCardinality {
			get {
			    return (RelationshipEndCardinality)MetadataObject.ToCardinality;
			}
			set {
				
				var oldValue = ToCardinality;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.TOCARDINALITY, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.ToCardinality = (TOM.RelationshipEndCardinality)newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.TOCARDINALITY, oldValue, newValue));
				OnPropertyChanged(Properties.TOCARDINALITY, oldValue, newValue);
			}
		}
		private bool ShouldSerializeToCardinality() { return false; }

		internal static SingleColumnRelationship CreateFromMetadata(Model parent, TOM.SingleColumnRelationship metadataObject) {
			var obj = new SingleColumnRelationship(metadataObject);
			parent.Relationships.Add(obj);
			
			obj.Init();

			return obj;
		}


		/// <summary>
		/// Creates a new SingleColumnRelationship and adds it to the parent Model.
		/// Also creates the underlying metadataobject and adds it to the TOM tree.
		/// </summary>
		public static SingleColumnRelationship CreateNew(Model parent, string name = null)
		{
			if(TabularModelHandler.Singleton.UsePowerBIGovernance && !PowerBI.PowerBIGovernance.AllowCreate(typeof(SingleColumnRelationship))) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(SingleColumnRelationship).GetTypeName()));
			}

			var metadataObject = new TOM.SingleColumnRelationship();
			metadataObject.Name = parent.Relationships.GetNewName(string.IsNullOrWhiteSpace(name) ? "New " + typeof(SingleColumnRelationship).GetTypeName() : name);

			var obj = new SingleColumnRelationship(metadataObject);

			parent.Relationships.Add(obj);
			
			obj.Init();

			return obj;
		}

		/// <summary>
		/// Creates a new SingleColumnRelationship and adds it to the current Model.
		/// Also creates the underlying metadataobject and adds it to the TOM tree.
		/// </summary>		
		public static SingleColumnRelationship CreateNew(string name = null)
		{
			return CreateNew(TabularModelHandler.Singleton.Model, name);
		}


		/// <summary>
		/// Creates an exact copy of this SingleColumnRelationship object.
		/// </summary>
		public SingleColumnRelationship Clone(string newName = null) {
			if(TabularModelHandler.Singleton.UsePowerBIGovernance && !PowerBI.PowerBIGovernance.AllowCreate(typeof(SingleColumnRelationship))) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(SingleColumnRelationship).GetTypeName()));
			}

		    Handler.BeginUpdate("Clone SingleColumnRelationship");

			// Create a clone of the underlying metadataobject:
			var tom = MetadataObject.Clone() as TOM.SingleColumnRelationship;


			// Assign a new, unique name:
			tom.Name = Parent.Relationships.GetNewName(string.IsNullOrEmpty(newName) ? tom.Name + " copy" : newName);
				
			// Create the TOM Wrapper object, representing the metadataobject
			SingleColumnRelationship obj = CreateFromMetadata(Parent, tom);

            Handler.EndUpdate();

            return obj;
		}

		TabularNamedObject IClonableObject.Clone(string newName, bool includeTranslations, TabularNamedObject newParent) 
		{
			if (newParent != null) throw new ArgumentException("This object can not be cloned to another parent. Argument newParent should be left as null.", "newParent");
			return Clone(newName);
		}

	
        internal override void RenewMetadataObject()
        {
            Handler.WrapperLookup.Remove(MetadataObject);
            MetadataObject = MetadataObject.Clone() as TOM.SingleColumnRelationship;
            Handler.WrapperLookup.Add(MetadataObject, this);
        }

		public new Model Parent { 
			get {
				return Handler.WrapperLookup[MetadataObject.Parent] as Model;
			}
		}



		/// <summary>
		/// CTOR - only called from static factory methods on the class
		/// </summary>
		SingleColumnRelationship(TOM.SingleColumnRelationship metadataObject) : base(metadataObject)
		{
		}



		internal override void Undelete(ITabularObjectCollection collection) {
			base.Undelete(collection);
			Reinit();
			ReapplyReferences();
		}

		public override bool Browsable(string propertyName) {
			switch (propertyName) {
				case Properties.PARENT:
					return false;
				
				default:
					return base.Browsable(propertyName);
			}
		}

    }

  
	/// <summary>
///             Represents a Table in the data model. A Table object is a member of the <see cref="T:TabularEditor.TOMWrapper.TableCollection" /> object under a <see cref="T:TabularEditor.TOMWrapper.Model" /> object. It contains a <see cref="T:TabularEditor.TOMWrapper.ColumnCollection" />. Rows are based on <see cref="T:TabularEditor.TOMWrapper.Partition" /> object or a <see cref="T:TabularEditor.TOMWrapper.CalculatedPartitionSource" /> if the Table is a calculated table.
///             </summary>
	[TypeConverter(typeof(DynamicPropertyConverter))]
	public partial class Table: TabularNamedObject
			, IHideableObject
			, IDescriptionObject
			, IAnnotationObject
			, IExtendedPropertyObject
			, ITabularPerspectiveObject
			, ITranslatableObject
			, IClonableObject
	{
	    internal new TOM.Table MetadataObject 
		{ 
			get 
			{ 
				return base.MetadataObject as TOM.Table; 
		    } 
			set 
			{ 
				base.MetadataObject = value; 
			}
		}

        [Browsable(true),NoMultiselect,Category("Translations and Perspectives"),Description("The collection of Annotations on this object."),Editor(typeof(AnnotationCollectionEditor), typeof(UITypeEditor))]
		public AnnotationCollection Annotations { get; private set; }
		public string GetAnnotation(int index) {
			return MetadataObject.Annotations[index].Value;
		}
		[IntelliSense("Returns true if an annotation with the given name exists. Otherwise false.")]
		public bool HasAnnotation(string name) {
		    return MetadataObject.Annotations.ContainsName(name);
		}
		[IntelliSense("Gets the value of the annotation with the given name. Returns null if no such annotation exists.")]
		public string GetAnnotation(string name) {
		    return HasAnnotation(name) ? MetadataObject.Annotations[name].Value : null;
		}
		public void SetAnnotation(int index, string value, bool undoable = true) {
			var name = MetadataObject.Annotations[index].Name;
			SetAnnotation(name, value, undoable);
		}
		public string GetNewAnnotationName() {
			return MetadataObject.Annotations.GetNewName("New Annotation");
		}
		[IntelliSense("Sets the value of the annotation having the given name. If no such annotation exists, it will be created. If value is set to null, the annotation will be removed.")]
		public void SetAnnotation(string name, string value) {
		    SetAnnotation(name, value, true);
		}
		public void SetAnnotation(string name, string value, bool undoable) {
			if(name == null) name = GetNewAnnotationName();

			if(value == null) {
				// Remove annotation if set to null:
				RemoveAnnotation(name, undoable);
				return;
			}

			if(GetAnnotation(name) == value) return;
			bool undoable2 = true;
			bool cancel = false;
			OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + value, ref undoable2, ref cancel);
			if (cancel) return;

			if(MetadataObject.Annotations.Contains(name)) {
				// Change existing annotation:
				var oldValue = GetAnnotation(name);
				MetadataObject.Annotations[name].Value = value;
				if (undoable) Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, oldValue));
				OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, name + ":" + value);
			} else {
				// Add new annotation:
				MetadataObject.Annotations.Add(new TOM.Annotation{ Name = name, Value = value });
				if (undoable) Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, null));
				OnPropertyChanged(Properties.ANNOTATIONS, null, name + ":" + value);
			}

		}
		[IntelliSense("Remove an annotation by the given name.")]
		public void RemoveAnnotation(string name) {
		    RemoveAnnotation(name, true);
		}
		public void RemoveAnnotation(string name, bool undoable) {
			if(MetadataObject.Annotations.Contains(name)) {
				// Get current value:
				bool undoable2 = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + GetAnnotation(name), ref undoable2, ref cancel);
				if (cancel) return;

				var oldValue = MetadataObject.Annotations[name].Value;
				MetadataObject.Annotations.Remove(name);

				// Undo-handling:
				if (undoable) Handler.UndoManager.Add(new UndoAnnotationAction(this, name, null, oldValue));
				OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, null);
			}
		}
		[IntelliSense("Gets the number of annotations on the current object.")]
		public int GetAnnotationsCount() {
			return MetadataObject.Annotations.Count;
		}
		[IntelliSense("Gets a collection of all annotation names on the current object.")]
		public IEnumerable<string> GetAnnotations() {
			return MetadataObject.Annotations.Select(a => a.Name);
		}

		        [DisplayName("Extended Properties"),NoMultiselect,Category("Translations and Perspectives"),Description("The collection of Extended Properties on this object."),Editor(typeof(ExtendedPropertyCollectionEditor), typeof(UITypeEditor))]
		public ExtendedPropertyCollection ExtendedProperties { get; private set; }

		[IntelliSense("Returns true if an ExtendedProperty with the given name exists. Otherwise false.")]
		public bool HasExtendedProperty(string name) {
		    return MetadataObject.ExtendedProperties.ContainsName(name);
		}
		public ExtendedPropertyType GetExtendedPropertyType(int index) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[index].Type;
		}
		public ExtendedPropertyType GetExtendedPropertyType(string name) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[name].Type;
		}
		public string GetExtendedProperty(int index) {
			var ep = MetadataObject.ExtendedProperties[index];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		[IntelliSense("Gets the value of the ExtendedProperty with the given name. Returns null if no such ExtendedProperty exists.")]
		public string GetExtendedProperty(string name) {
		    if(!HasExtendedProperty(name)) return null;
			var ep = MetadataObject.ExtendedProperties[name];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		public void SetExtendedProperty(int index, string value, ExtendedPropertyType type = ExtendedPropertyType.String) {
			var name = MetadataObject.ExtendedProperties[index].Name;
			SetExtendedProperty(name, value, type);
		}
		public string GetNewExtendedPropertyName() {
			return MetadataObject.ExtendedProperties.GetNewName("New ExtendedProperty");
		}
		[IntelliSense("Sets the value of the ExtendedProperty having the given name. If no such ExtendedProperty exists, it will be created. If value is set to null, the ExtendedProperty will be removed.")]
		public void SetExtendedProperty(string name, string value, ExtendedPropertyType type = ExtendedPropertyType.String) {
			if(name == null) name = GetNewExtendedPropertyName();

			if(value == null) {
				// Remove ExtendedProperty if set to null:
				RemoveExtendedProperty(name);
				return;
			}

			if(GetExtendedProperty(name) == value) return;
			bool undoable = true;
			bool cancel = false;
			OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + value, ref undoable, ref cancel);
			if (cancel) return;

			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Change existing ExtendedProperty:
				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				var ep = MetadataObject.ExtendedProperties[name];
				if (ep is TOM.JsonExtendedProperty)
					(ep as TOM.JsonExtendedProperty).Value = value;
				else 
					(ep as TOM.StringExtendedProperty).Value = value;
					
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, name + ":" + value);
			} else {
				// Add new ExtendedProperty:
				if (type == ExtendedPropertyType.Json)
					MetadataObject.ExtendedProperties.Add(new TOM.JsonExtendedProperty{ Name = name, Value = value });
				else
					MetadataObject.ExtendedProperties.Add(new TOM.StringExtendedProperty{ Name = name, Value = value });

				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, null, type));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, null, name + ":" + value);
			}

		}
		[IntelliSense("Remove an ExtendedProperty by the given name.")]
		public void RemoveExtendedProperty(string name) {
			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Get current value:
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + GetExtendedProperty(name), ref undoable, ref cancel);
				if (cancel) return;

				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				MetadataObject.ExtendedProperties.Remove(name);

				// Undo-handling:
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, null, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, null);
			}
		}
		[IntelliSense("Gets the number of ExtendedProperties on the current object.")]
		public int GetExtendedPropertyCount() {
			return MetadataObject.ExtendedProperties.Count;
		}
		[IntelliSense("Gets a collection of all ExtendedProperty names on the current object.")]
		public IEnumerable<string> GetExtendedProperties() {
			return MetadataObject.ExtendedProperties.Select(a => a.Name);
		}

		/// <summary>
///             Specifies the type of Table so that you can customize application behavior based on the type of data in the table. Allowed values are identical to those of dimension type properties for Multidimensional models. Regular is the default. Other values include Time (2), Geography (3), Organization (4), BillOfMaterials (5), Accounts (6), Customers (7), Products (8), Scenario (9), Quantitativ1e (10), Utility (11), Currency (12), Rates (13), Channel (14) - channel dimension, Promotion (15).
///             </summary>
		[DisplayName("Data Category")]
		[Category("Metadata"),Description(@"Specifies the type of Table so that you can customize application behavior based on the type of data in the table. Allowed values are identical to those of dimension type properties for Multidimensional models. Regular is the default. Other values include Time (2), Geography (3), Organization (4), BillOfMaterials (5), Accounts (6), Customers (7), Products (8), Scenario (9), Quantitativ1e (10), Utility (11), Currency (12), Rates (13), Channel (14) - channel dimension, Promotion (15)."),IntelliSense(@"Specifies the type of Table so that you can customize application behavior based on the type of data in the table. Allowed values are identical to those of dimension type properties for Multidimensional models. Regular is the default. Other values include Time (2), Geography (3), Organization (4), BillOfMaterials (5), Accounts (6), Customers (7), Products (8), Scenario (9), Quantitativ1e (10), Utility (11), Currency (12), Rates (13), Channel (14) - channel dimension, Promotion (15).")]
		public string DataCategory {
			get {
			    return MetadataObject.DataCategory;
			}
			set {
				
				var oldValue = DataCategory;
				var newValue = value.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DATACATEGORY, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.DataCategory = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DATACATEGORY, oldValue, newValue));
				OnPropertyChanged(Properties.DATACATEGORY, oldValue, newValue);
			}
		}
		private bool ShouldSerializeDataCategory() { return false; }
/// <summary>
///             The description of the table, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio.
///             </summary>
		[DisplayName("Description")]
		[Category("Basic"),Description(@"The description of the table, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio."),IntelliSense(@"The description of the table, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio.")][Editor(typeof(System.ComponentModel.Design.MultilineStringEditor), typeof(System.Drawing.Design.UITypeEditor))]
		public string Description {
			get {
			    return MetadataObject.Description;
			}
			set {
				
				var oldValue = Description;
				var newValue = value.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DESCRIPTION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.Description = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DESCRIPTION, oldValue, newValue));
				OnPropertyChanged(Properties.DESCRIPTION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeDescription() { return false; }
/// <summary>
///             A boolean value that indicates whether the table is treated as hidden by client visualization tools. True if the Table is treated as hidden; otherwise false.
///             </summary>
		[DisplayName("Hidden")]
		[Category("Basic"),Description(@"A boolean value that indicates whether the table is treated as hidden by client visualization tools. True if the Table is treated as hidden; otherwise false."),IntelliSense(@"A boolean value that indicates whether the table is treated as hidden by client visualization tools. True if the Table is treated as hidden; otherwise false.")]
		public bool IsHidden {
			get {
			    return MetadataObject.IsHidden;
			}
			set {
				
				var oldValue = IsHidden;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ISHIDDEN, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.IsHidden = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.ISHIDDEN, oldValue, newValue));
				OnPropertyChanged(Properties.ISHIDDEN, oldValue, newValue);
				Handler.UpdateObject(this);
			}
		}
		private bool ShouldSerializeIsHidden() { return false; }
/// <summary>
///             A boolean value that indicates a difference between a local and server version. If True, the Table is only shown when referenced as Variation.
///             </summary><remarks>This property is only supported when the compatibility level of the database is at 1400 or above.</remarks>
		[DisplayName("Show As Variations Only")]
		[Category("Options"),Description(@"A boolean value that indicates a difference between a local and server version. If True, the Table is only shown when referenced as Variation."),IntelliSense(@"A boolean value that indicates a difference between a local and server version. If True, the Table is only shown when referenced as Variation.")]
		public bool ShowAsVariationsOnly {
			get {
			    return MetadataObject.ShowAsVariationsOnly;
			}
			set {
				
				var oldValue = ShowAsVariationsOnly;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.SHOWASVARIATIONSONLY, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.ShowAsVariationsOnly = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.SHOWASVARIATIONSONLY, oldValue, newValue));
				OnPropertyChanged(Properties.SHOWASVARIATIONSONLY, oldValue, newValue);
			}
		}
		private bool ShouldSerializeShowAsVariationsOnly() { return false; }
/// <summary>
///             A boolean value that specifies whether to hide a table from the client. True hides the tables.
///             </summary><remarks>This property is only supported when the compatibility level of the database is at 1400 or above.</remarks>
		[DisplayName("Private")]
		[Category("Options"),Description(@"A boolean value that specifies whether to hide a table from the client. True hides the tables."),IntelliSense(@"A boolean value that specifies whether to hide a table from the client. True hides the tables.")]
		public bool IsPrivate {
			get {
			    return MetadataObject.IsPrivate;
			}
			set {
				
				var oldValue = IsPrivate;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ISPRIVATE, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.IsPrivate = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.ISPRIVATE, oldValue, newValue));
				OnPropertyChanged(Properties.ISPRIVATE, oldValue, newValue);
			}
		}
		private bool ShouldSerializeIsPrivate() { return false; }
/// <summary>
///             The ranking or precedence used to select the alternate source table in case more than one match is found.
///             </summary><remarks>This property is only supported when the compatibility level of the database is at 1460 or above.</remarks>
		[DisplayName("Alternate Source Precedence")]
		[Category("Other"),Description(@"The ranking or precedence used to select the alternate source table in case more than one match is found."),IntelliSense(@"The ranking or precedence used to select the alternate source table in case more than one match is found.")]
		public int AlternateSourcePrecedence {
			get {
			    return MetadataObject.AlternateSourcePrecedence;
			}
			set {
				
				var oldValue = AlternateSourcePrecedence;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ALTERNATESOURCEPRECEDENCE, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.AlternateSourcePrecedence = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.ALTERNATESOURCEPRECEDENCE, oldValue, newValue));
				OnPropertyChanged(Properties.ALTERNATESOURCEPRECEDENCE, oldValue, newValue);
			}
		}
		private bool ShouldSerializeAlternateSourcePrecedence() { return false; }

        /// <Summary>
		/// Collection of perspectives in which this Table is visible.
		/// </Summary>
		[Browsable(true),DisplayName("Shown in Perspective"), Description("Provides an easy way to include or exclude this object from the perspectives of the model."), Category("Translations and Perspectives")]
        public PerspectiveTableIndexer InPerspective { get; private set; }
		PerspectiveIndexer ITabularPerspectiveObject.InPerspective { get { return this.InPerspective; } }
        /// <summary>
        /// Collection of localized descriptions for this Table.
        /// </summary>
        [Browsable(true),DisplayName("Translated Descriptions"),Description("Shows all translated descriptions of this object."),Category("Translations and Perspectives")]
	    public TranslationIndexer TranslatedDescriptions { private set; get; }
        /// <summary>
        /// Collection of localized names for this Table.
        /// </summary>
        [Browsable(true),DisplayName("Translated Names"),Description("Shows all translated names of this object."),Category("Translations and Perspectives")]
	    public TranslationIndexer TranslatedNames { private set; get; }

		internal static Table CreateFromMetadata(Model parent, TOM.Table metadataObject) {
			var obj = new Table(metadataObject);
			parent.Tables.Add(obj);
			
			obj.Init();

			return obj;
		}


		/// <summary>
		/// Creates a new Table and adds it to the parent Model.
		/// Also creates the underlying metadataobject and adds it to the TOM tree.
		/// </summary>
		public static Table CreateNew(Model parent, string name = null)
		{
			if(TabularModelHandler.Singleton.UsePowerBIGovernance && !PowerBI.PowerBIGovernance.AllowCreate(typeof(Table))) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(Table).GetTypeName()));
			}

			var metadataObject = new TOM.Table();
			metadataObject.Name = parent.Tables.GetNewName(string.IsNullOrWhiteSpace(name) ? "New " + typeof(Table).GetTypeName() : name);

			var obj = new Table(metadataObject);

			parent.Tables.Add(obj);
			
			obj.Init();

			return obj;
		}

		/// <summary>
		/// Creates a new Table and adds it to the current Model.
		/// Also creates the underlying metadataobject and adds it to the TOM tree.
		/// </summary>		
		public static Table CreateNew(string name = null)
		{
			return CreateNew(TabularModelHandler.Singleton.Model, name);
		}


		/// <summary>
		/// Creates an exact copy of this Table object.
		/// </summary>
		public Table Clone(string newName = null, bool includeTranslations = true) {
			if(TabularModelHandler.Singleton.UsePowerBIGovernance && !PowerBI.PowerBIGovernance.AllowCreate(typeof(Table))) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(Table).GetTypeName()));
			}

		    Handler.BeginUpdate("Clone Table");

			// Create a clone of the underlying metadataobject:
			var tom = MetadataObject.Clone() as TOM.Table;

			// Make sure that measures on the table are renamed:
			foreach(var m in tom.Measures) m.Name = tom.Measures.GetNewName(m.Name);

			// Assign a new, unique name:
			tom.Name = Parent.Tables.GetNewName(string.IsNullOrEmpty(newName) ? tom.Name + " copy" : newName);
				
			// Create the TOM Wrapper object, representing the metadataobject
			Table obj ;
			if(this is CalculatedTable) obj = CalculatedTable.CreateFromMetadata(Parent, tom);
			else obj = CreateFromMetadata(Parent, tom);

			// Copy translations, if applicable:
			if(includeTranslations) {
				obj.CopyTranslationsFrom(this);
				foreach(var objChild in obj.Columns) objChild.CopyTranslationsFrom(obj.Columns[objChild.MetadataIndex]);
				foreach(var objChild in obj.Hierarchies) objChild.CopyTranslationsFrom(obj.Hierarchies[objChild.MetadataIndex]);
				foreach(var objChild in obj.Measures) objChild.CopyTranslationsFrom(obj.Measures[objChild.MetadataIndex]);
			}
				
			// Copy perspectives:
			obj.InPerspective.CopyFrom(InPerspective);

			// TODO: Make sure that dependency trees are properly rebuilt when IDaxDependantObjects are cloned
			// FormulaFixup.BuildDependencyTree(this);
            Handler.EndUpdate();

            return obj;
		}

		TabularNamedObject IClonableObject.Clone(string newName, bool includeTranslations, TabularNamedObject newParent) 
		{
			if (newParent != null) throw new ArgumentException("This object can not be cloned to another parent. Argument newParent should be left as null.", "newParent");
			return Clone(newName, includeTranslations);
		}

	
        internal override void RenewMetadataObject()
        {
            Handler.WrapperLookup.Remove(MetadataObject);
            MetadataObject = MetadataObject.Clone() as TOM.Table;
            Handler.WrapperLookup.Add(MetadataObject, this);
        }

		public Model Parent { 
			get {
				return Handler.WrapperLookup[MetadataObject.Parent] as Model;
			}
		}

        internal override ITabularObjectCollection GetCollectionForChild(TabularObject child)
        {
			if (child is Partition) return Partitions;
			if (child is Column) return Columns;
			if (child is Hierarchy) return Hierarchies;
			if (child is Measure) return Measures;
            return base.GetCollectionForChild(child);
        }

        /// <summary>
        /// The collection of Partition objects on this Table.
        /// </summary>
		[DisplayName("Partitions")]
		[Category("Data Source"),IntelliSense("The collection of Partition objects on this Table.")][NoMultiselect(),Editor(typeof(PartitionCollectionEditor),typeof(UITypeEditor))]
		public PartitionCollection Partitions { get; protected set; }
        /// <summary>
        /// The collection of Column objects on this Table.
        /// </summary>
		[DisplayName("Columns")]
		[Category("Other"),IntelliSense("The collection of Column objects on this Table.")][Browsable(false)]
		public ColumnCollection Columns { get; protected set; }
        /// <summary>
        /// The collection of Hierarchy objects on this Table.
        /// </summary>
		[DisplayName("Hierarchies")]
		[Category("Other"),IntelliSense("The collection of Hierarchy objects on this Table.")][Browsable(false)]
		public HierarchyCollection Hierarchies { get; protected set; }
        /// <summary>
        /// The collection of Measure objects on this Table.
        /// </summary>
		[DisplayName("Measures")]
		[Category("Other"),IntelliSense("The collection of Measure objects on this Table.")][Browsable(false)]
		public MeasureCollection Measures { get; protected set; }

		/// <summary>
		/// CTOR - only called from static factory methods on the class
		/// </summary>
		protected Table(TOM.Table metadataObject) : base(metadataObject)
		{
			// Create indexers for translations:
			TranslatedNames = new TranslationIndexer(this, TOM.TranslatedProperty.Caption);
			TranslatedDescriptions = new TranslationIndexer(this, TOM.TranslatedProperty.Description);

			// Create indexer for perspectives:
			InPerspective = new PerspectiveTableIndexer(this);
			
			// Create indexer for annotations:
			Annotations = new AnnotationCollection(this);
			
			// Create indexer for extended properties:
			ExtendedProperties = new ExtendedPropertyCollection(this);
			
			// Instantiate child collections:
			Partitions = new PartitionCollection(this.GetObjectPath() + ".Partitions", MetadataObject.Partitions, this);
			Columns = new ColumnCollection(this.GetObjectPath() + ".Columns", MetadataObject.Columns, this);
			Hierarchies = new HierarchyCollection(this.GetObjectPath() + ".Hierarchies", MetadataObject.Hierarchies, this);
			Measures = new MeasureCollection(this.GetObjectPath() + ".Measures", MetadataObject.Measures, this);

			// Populate child collections:
			Partitions.CreateChildrenFromMetadata();
			Columns.CreateChildrenFromMetadata();
			Hierarchies.CreateChildrenFromMetadata();
			Measures.CreateChildrenFromMetadata();

			// Hook up event handlers on child collections:
			Partitions.CollectionChanged += Children_CollectionChanged;
			Columns.CollectionChanged += Children_CollectionChanged;
			Hierarchies.CollectionChanged += Children_CollectionChanged;
			Measures.CollectionChanged += Children_CollectionChanged;
		}


		internal override void Reinit() {
			Partitions.Reinit();
			Columns.Reinit();
			Hierarchies.Reinit();
			Measures.Reinit();
		}

		internal override void Undelete(ITabularObjectCollection collection) {
			base.Undelete(collection);
			Reinit();
			ReapplyReferences();
		}

		public override bool Browsable(string propertyName) {
			switch (propertyName) {
 
				case Properties.EXTENDEDPROPERTIES:
					return Handler.CompatibilityLevel >= 1400;
				case Properties.PARENT:
					return false;
				
				// Hides translation properties in the grid, unless the model actually contains translations:
				case Properties.TRANSLATEDNAMES:
				case Properties.TRANSLATEDDESCRIPTIONS:
					return Model.Cultures.Any();
				
				// Hides the perspective property in the grid, unless the model actually contains perspectives:
				case Properties.INPERSPECTIVE:
					return Model.Perspectives.Any();
				
				default:
					return base.Browsable(propertyName);
			}
		}

    }


	/// <summary>
	/// Collection class for Table. Provides convenient properties for setting a property on multiple objects at once.
	/// </summary>
	public sealed partial class TableCollection: TabularObjectCollection<Table>
	{
		internal Model Model { get { return Parent as Model; } }
		TOM.TableCollection TOM_Collection;
		internal TableCollection(string collectionName, TOM.TableCollection metadataObjectCollection, Model parent) : base(collectionName, parent)
		{
			TOM_Collection = metadataObjectCollection;
		}
		internal override Type GetItemType() { return typeof(Table); }
        protected override void TOM_Add(TOM.MetadataObject obj) { TOM_Collection.Add(obj as TOM.Table); }
        protected override bool TOM_Contains(TOM.MetadataObject obj) { return TOM_Collection.Contains(obj as TOM.Table); }
        protected override void TOM_Remove(TOM.MetadataObject obj) { TOM_Collection.Remove(obj as TOM.Table); }
        protected override void TOM_Clear() { TOM_Collection.Clear(); }
        protected override bool TOM_ContainsName(string name) { return TOM_Collection.ContainsName(name); }
        protected override TOM.MetadataObject TOM_Get(int index) { return TOM_Collection[index]; }
        protected override TOM.MetadataObject TOM_Get(string name) { return TOM_Collection[name]; }
        internal override string GetNewName(string prefix = null) { return string.IsNullOrEmpty(prefix) ? TOM_Collection.GetNewName() : TOM_Collection.GetNewName(prefix); }
        public override int IndexOf(TOM.MetadataObject obj) { return TOM_Collection.IndexOf(obj as TOM.Table); }
        public override int Count { get { return TOM_Collection.Count; } }
        public override IEnumerator<Table> GetEnumerator() { return TOM_Collection.Select(h => Handler.WrapperLookup[h]).OfType<Table>().GetEnumerator(); }
		internal override void Reinit() {
			var ixOffset = 0;
			for(int i = 0; i < Count; i++) {
				var item = this[i];
				Handler.WrapperLookup.Remove(item.MetadataObject);
				item.MetadataObject = Model.MetadataObject.Tables[i + ixOffset] as TOM.Table;
				Handler.WrapperLookup.Add(item.MetadataObject, item);
				item.Collection = this;
			}
			TOM_Collection = Model.MetadataObject.Tables;
			foreach(var item in this) item.Reinit();
		}

		internal override void ReapplyReferences() {
			foreach(var item in this) item.ReapplyReferences();
		}

		/// <summary>
		/// Calling this method will populate the TableCollection with objects based on the MetadataObjects in the corresponding MetadataObjectCollection.
		/// </summary>
		internal override void CreateChildrenFromMetadata()
		{
			// Construct child objects (they are automatically added to the Handler's WrapperLookup dictionary):
			foreach(var obj in TOM_Collection) {
                if (obj.Partitions[0].SourceType == TOM.PartitionSourceType.Calculated) CalculatedTable.CreateFromMetadata(Model, obj);
                else Table.CreateFromMetadata(Model, obj);
		    }
		}

		/// <summary>
		/// Sets the DataCategory property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the DataCategory property of all objects in the collection at once.")]
		public string DataCategory {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("DataCategory"));
				this.ToList().ForEach(item => { item.DataCategory = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the Description property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the Description property of all objects in the collection at once.")]
		public string Description {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("Description"));
				this.ToList().ForEach(item => { item.Description = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the IsHidden property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the IsHidden property of all objects in the collection at once.")]
		public bool IsHidden {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("IsHidden"));
				this.ToList().ForEach(item => { item.IsHidden = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the ShowAsVariationsOnly property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the ShowAsVariationsOnly property of all objects in the collection at once.")]
		public bool ShowAsVariationsOnly {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("ShowAsVariationsOnly"));
				this.ToList().ForEach(item => { item.ShowAsVariationsOnly = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the IsPrivate property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the IsPrivate property of all objects in the collection at once.")]
		public bool IsPrivate {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("IsPrivate"));
				this.ToList().ForEach(item => { item.IsPrivate = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the AlternateSourcePrecedence property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the AlternateSourcePrecedence property of all objects in the collection at once.")]
		public int AlternateSourcePrecedence {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("AlternateSourcePrecedence"));
				this.ToList().ForEach(item => { item.AlternateSourcePrecedence = value; });
				Handler.UndoManager.EndBatch();
			}
		}

		public override string ToString() {
			return string.Format("({0} {1})", Count, (Count == 1 ? "Table" : "Tables").ToLower());
		}
	}
  
	/// <summary>
///             Represents an individual Windows user account or a Windows security group.
///             </summary>
	[TypeConverter(typeof(DynamicPropertyConverter))]
	public sealed partial class WindowsModelRoleMember: ModelRoleMember
			, IClonableObject
	{
	    internal new TOM.WindowsModelRoleMember MetadataObject 
		{ 
			get 
			{ 
				return base.MetadataObject as TOM.WindowsModelRoleMember; 
		    } 
			set 
			{ 
				base.MetadataObject = value; 
			}
		}


		internal static WindowsModelRoleMember CreateFromMetadata(ModelRole parent, TOM.WindowsModelRoleMember metadataObject) {
			var obj = new WindowsModelRoleMember(metadataObject);
			parent.Members.Add(obj);
			
			obj.Init();

			return obj;
		}


		/// <summary>
		/// Creates a new WindowsModelRoleMember and adds it to the parent ModelRole.
		/// Also creates the underlying metadataobject and adds it to the TOM tree.
		/// </summary>
		public static WindowsModelRoleMember CreateNew(ModelRole parent, string name = null)
		{
			if(TabularModelHandler.Singleton.UsePowerBIGovernance && !PowerBI.PowerBIGovernance.AllowCreate(typeof(WindowsModelRoleMember))) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(WindowsModelRoleMember).GetTypeName()));
			}

			var metadataObject = new TOM.WindowsModelRoleMember();
			metadataObject.Name = parent.Members.GetNewName(string.IsNullOrWhiteSpace(name) ? "New " + typeof(WindowsModelRoleMember).GetTypeName() : name);

			var obj = new WindowsModelRoleMember(metadataObject);

			parent.Members.Add(obj);
			
			obj.Init();

			return obj;
		}


		/// <summary>
		/// Creates an exact copy of this WindowsModelRoleMember object.
		/// </summary>
		public WindowsModelRoleMember Clone(string newName = null, ModelRole newParent = null) {
			if(TabularModelHandler.Singleton.UsePowerBIGovernance && !PowerBI.PowerBIGovernance.AllowCreate(typeof(WindowsModelRoleMember))) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(WindowsModelRoleMember).GetTypeName()));
			}

		    Handler.BeginUpdate("Clone WindowsModelRoleMember");

			// Create a clone of the underlying metadataobject:
			var tom = MetadataObject.Clone() as TOM.WindowsModelRoleMember;


			// Assign a new, unique name:
			tom.Name = Parent.Members.GetNewName(string.IsNullOrEmpty(newName) ? tom.Name + " copy" : newName);
				
			// Create the TOM Wrapper object, representing the metadataobject
			WindowsModelRoleMember obj = CreateFromMetadata(newParent ?? Parent, tom);

            Handler.EndUpdate();

            return obj;
		}

		TabularNamedObject IClonableObject.Clone(string newName, bool includeTranslations, TabularNamedObject newParent) 
		{
			return Clone(newName);
		}

	
        internal override void RenewMetadataObject()
        {
            Handler.WrapperLookup.Remove(MetadataObject);
            MetadataObject = MetadataObject.Clone() as TOM.WindowsModelRoleMember;
            Handler.WrapperLookup.Add(MetadataObject, this);
        }

		public new ModelRole Parent { 
			get {
				return Handler.WrapperLookup[MetadataObject.Parent] as ModelRole;
			}
		}



		/// <summary>
		/// CTOR - only called from static factory methods on the class
		/// </summary>
		WindowsModelRoleMember(TOM.WindowsModelRoleMember metadataObject) : base(metadataObject)
		{
		}



		internal override void Undelete(ITabularObjectCollection collection) {
			base.Undelete(collection);
			Reinit();
			ReapplyReferences();
		}

		public override bool Browsable(string propertyName) {
			switch (propertyName) {
				case Properties.PARENT:
					return false;
				
				default:
					return base.Browsable(propertyName);
			}
		}

    }

  
	/// <summary>
///             A named expression that can be used by one or more partitions.
///             </summary><remarks>This metadata object is only supported when the compatibility level of the database is at 1400 or above.</remarks>
	[TypeConverter(typeof(DynamicPropertyConverter))]
	public sealed partial class NamedExpression: TabularNamedObject
			, IDescriptionObject
			, IAnnotationObject
			, IExtendedPropertyObject
			, IClonableObject
	{
	    internal new TOM.NamedExpression MetadataObject 
		{ 
			get 
			{ 
				return base.MetadataObject as TOM.NamedExpression; 
		    } 
			set 
			{ 
				base.MetadataObject = value; 
			}
		}

        [Browsable(true),NoMultiselect,Category("Translations and Perspectives"),Description("The collection of Annotations on this object."),Editor(typeof(AnnotationCollectionEditor), typeof(UITypeEditor))]
		public AnnotationCollection Annotations { get; private set; }
		public string GetAnnotation(int index) {
			return MetadataObject.Annotations[index].Value;
		}
		[IntelliSense("Returns true if an annotation with the given name exists. Otherwise false.")]
		public bool HasAnnotation(string name) {
		    return MetadataObject.Annotations.ContainsName(name);
		}
		[IntelliSense("Gets the value of the annotation with the given name. Returns null if no such annotation exists.")]
		public string GetAnnotation(string name) {
		    return HasAnnotation(name) ? MetadataObject.Annotations[name].Value : null;
		}
		public void SetAnnotation(int index, string value, bool undoable = true) {
			var name = MetadataObject.Annotations[index].Name;
			SetAnnotation(name, value, undoable);
		}
		public string GetNewAnnotationName() {
			return MetadataObject.Annotations.GetNewName("New Annotation");
		}
		[IntelliSense("Sets the value of the annotation having the given name. If no such annotation exists, it will be created. If value is set to null, the annotation will be removed.")]
		public void SetAnnotation(string name, string value) {
		    SetAnnotation(name, value, true);
		}
		public void SetAnnotation(string name, string value, bool undoable) {
			if(name == null) name = GetNewAnnotationName();

			if(value == null) {
				// Remove annotation if set to null:
				RemoveAnnotation(name, undoable);
				return;
			}

			if(GetAnnotation(name) == value) return;
			bool undoable2 = true;
			bool cancel = false;
			OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + value, ref undoable2, ref cancel);
			if (cancel) return;

			if(MetadataObject.Annotations.Contains(name)) {
				// Change existing annotation:
				var oldValue = GetAnnotation(name);
				MetadataObject.Annotations[name].Value = value;
				if (undoable) Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, oldValue));
				OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, name + ":" + value);
			} else {
				// Add new annotation:
				MetadataObject.Annotations.Add(new TOM.Annotation{ Name = name, Value = value });
				if (undoable) Handler.UndoManager.Add(new UndoAnnotationAction(this, name, value, null));
				OnPropertyChanged(Properties.ANNOTATIONS, null, name + ":" + value);
			}

		}
		[IntelliSense("Remove an annotation by the given name.")]
		public void RemoveAnnotation(string name) {
		    RemoveAnnotation(name, true);
		}
		public void RemoveAnnotation(string name, bool undoable) {
			if(MetadataObject.Annotations.Contains(name)) {
				// Get current value:
				bool undoable2 = true;
				bool cancel = false;
				OnPropertyChanging(Properties.ANNOTATIONS, name + ":" + GetAnnotation(name), ref undoable2, ref cancel);
				if (cancel) return;

				var oldValue = MetadataObject.Annotations[name].Value;
				MetadataObject.Annotations.Remove(name);

				// Undo-handling:
				if (undoable) Handler.UndoManager.Add(new UndoAnnotationAction(this, name, null, oldValue));
				OnPropertyChanged(Properties.ANNOTATIONS, name + ":" + oldValue, null);
			}
		}
		[IntelliSense("Gets the number of annotations on the current object.")]
		public int GetAnnotationsCount() {
			return MetadataObject.Annotations.Count;
		}
		[IntelliSense("Gets a collection of all annotation names on the current object.")]
		public IEnumerable<string> GetAnnotations() {
			return MetadataObject.Annotations.Select(a => a.Name);
		}

		        [DisplayName("Extended Properties"),NoMultiselect,Category("Translations and Perspectives"),Description("The collection of Extended Properties on this object."),Editor(typeof(ExtendedPropertyCollectionEditor), typeof(UITypeEditor))]
		public ExtendedPropertyCollection ExtendedProperties { get; private set; }

		[IntelliSense("Returns true if an ExtendedProperty with the given name exists. Otherwise false.")]
		public bool HasExtendedProperty(string name) {
		    return MetadataObject.ExtendedProperties.ContainsName(name);
		}
		public ExtendedPropertyType GetExtendedPropertyType(int index) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[index].Type;
		}
		public ExtendedPropertyType GetExtendedPropertyType(string name) {
			return (ExtendedPropertyType)MetadataObject.ExtendedProperties[name].Type;
		}
		public string GetExtendedProperty(int index) {
			var ep = MetadataObject.ExtendedProperties[index];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		[IntelliSense("Gets the value of the ExtendedProperty with the given name. Returns null if no such ExtendedProperty exists.")]
		public string GetExtendedProperty(string name) {
		    if(!HasExtendedProperty(name)) return null;
			var ep = MetadataObject.ExtendedProperties[name];
			return ep.Type == TOM.ExtendedPropertyType.Json ? (ep as TOM.JsonExtendedProperty).Value : (ep as TOM.StringExtendedProperty).Value;
		}
		public void SetExtendedProperty(int index, string value, ExtendedPropertyType type = ExtendedPropertyType.String) {
			var name = MetadataObject.ExtendedProperties[index].Name;
			SetExtendedProperty(name, value, type);
		}
		public string GetNewExtendedPropertyName() {
			return MetadataObject.ExtendedProperties.GetNewName("New ExtendedProperty");
		}
		[IntelliSense("Sets the value of the ExtendedProperty having the given name. If no such ExtendedProperty exists, it will be created. If value is set to null, the ExtendedProperty will be removed.")]
		public void SetExtendedProperty(string name, string value, ExtendedPropertyType type = ExtendedPropertyType.String) {
			if(name == null) name = GetNewExtendedPropertyName();

			if(value == null) {
				// Remove ExtendedProperty if set to null:
				RemoveExtendedProperty(name);
				return;
			}

			if(GetExtendedProperty(name) == value) return;
			bool undoable = true;
			bool cancel = false;
			OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + value, ref undoable, ref cancel);
			if (cancel) return;

			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Change existing ExtendedProperty:
				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				var ep = MetadataObject.ExtendedProperties[name];
				if (ep is TOM.JsonExtendedProperty)
					(ep as TOM.JsonExtendedProperty).Value = value;
				else 
					(ep as TOM.StringExtendedProperty).Value = value;
					
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, name + ":" + value);
			} else {
				// Add new ExtendedProperty:
				if (type == ExtendedPropertyType.Json)
					MetadataObject.ExtendedProperties.Add(new TOM.JsonExtendedProperty{ Name = name, Value = value });
				else
					MetadataObject.ExtendedProperties.Add(new TOM.StringExtendedProperty{ Name = name, Value = value });

				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, value, null, type));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, null, name + ":" + value);
			}

		}
		[IntelliSense("Remove an ExtendedProperty by the given name.")]
		public void RemoveExtendedProperty(string name) {
			if(MetadataObject.ExtendedProperties.Contains(name)) {
				// Get current value:
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.EXTENDEDPROPERTIES, name + ":" + GetExtendedProperty(name), ref undoable, ref cancel);
				if (cancel) return;

				var oldValue = GetExtendedProperty(name);
				var oldType = GetExtendedPropertyType(name);
				MetadataObject.ExtendedProperties.Remove(name);

				// Undo-handling:
				if (undoable) Handler.UndoManager.Add(new UndoExtendedPropertyAction(this, name, null, oldValue, oldType));
				OnPropertyChanged(Properties.EXTENDEDPROPERTIES, name + ":" + oldValue, null);
			}
		}
		[IntelliSense("Gets the number of ExtendedProperties on the current object.")]
		public int GetExtendedPropertyCount() {
			return MetadataObject.ExtendedProperties.Count;
		}
		[IntelliSense("Gets a collection of all ExtendedProperty names on the current object.")]
		public IEnumerable<string> GetExtendedProperties() {
			return MetadataObject.ExtendedProperties.Select(a => a.Name);
		}

		/// <summary>
///             The description of the expression, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio.
///             </summary>
		[DisplayName("Description")]
		[Category("Basic"),Description(@"The description of the expression, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio."),IntelliSense(@"The description of the expression, visible to developers at design time and to administrators in management tools, such as SQL Server Management Studio.")][Editor(typeof(System.ComponentModel.Design.MultilineStringEditor), typeof(System.Drawing.Design.UITypeEditor))]
		public string Description {
			get {
			    return MetadataObject.Description;
			}
			set {
				
				var oldValue = Description;
				var newValue = value.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.DESCRIPTION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.Description = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.DESCRIPTION, oldValue, newValue));
				OnPropertyChanged(Properties.DESCRIPTION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeDescription() { return false; }
/// <summary>
///             The dialect of the expression.
///             </summary>
		[DisplayName("Kind")]
		[Category("Options"),Description(@"The dialect of the expression."),IntelliSense(@"The dialect of the expression.")]
		public ExpressionKind Kind {
			get {
			    return (ExpressionKind)MetadataObject.Kind;
			}
			set {
				
				var oldValue = Kind;
				var newValue = value;
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.KIND, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.Kind = (TOM.ExpressionKind)newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.KIND, oldValue, newValue));
				OnPropertyChanged(Properties.KIND, oldValue, newValue);
			}
		}
		private bool ShouldSerializeKind() { return false; }
/// <summary>
///             The expression text.
///             </summary>
		[DisplayName("Expression")]
		[Category("Options"),Description(@"The expression text."),IntelliSense(@"The expression text.")][Editor(typeof(System.ComponentModel.Design.MultilineStringEditor), typeof(System.Drawing.Design.UITypeEditor))]
		public string Expression {
			get {
			    return MetadataObject.Expression;
			}
			set {
				
				var oldValue = Expression;
				var newValue = value.Replace("\r", "");
				if (oldValue == newValue) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(Properties.EXPRESSION, newValue, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.Expression = newValue;
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, Properties.EXPRESSION, oldValue, newValue));
				OnPropertyChanged(Properties.EXPRESSION, oldValue, newValue);
			}
		}
		private bool ShouldSerializeExpression() { return false; }

		internal static NamedExpression CreateFromMetadata(Model parent, TOM.NamedExpression metadataObject) {
			var obj = new NamedExpression(metadataObject);
			parent.Expressions.Add(obj);
			
			obj.Init();

			return obj;
		}


		/// <summary>
		/// Creates a new NamedExpression and adds it to the parent Model.
		/// Also creates the underlying metadataobject and adds it to the TOM tree.
		/// </summary>
		public static NamedExpression CreateNew(Model parent, string name = null)
		{
			if(TabularModelHandler.Singleton.UsePowerBIGovernance && !PowerBI.PowerBIGovernance.AllowCreate(typeof(NamedExpression))) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(NamedExpression).GetTypeName()));
			}

			var metadataObject = new TOM.NamedExpression();
			metadataObject.Name = parent.Expressions.GetNewName(string.IsNullOrWhiteSpace(name) ? "New " + typeof(NamedExpression).GetTypeName() : name);

			var obj = new NamedExpression(metadataObject);

			parent.Expressions.Add(obj);
			
			obj.Init();

			return obj;
		}

		/// <summary>
		/// Creates a new NamedExpression and adds it to the current Model.
		/// Also creates the underlying metadataobject and adds it to the TOM tree.
		/// </summary>		
		public static NamedExpression CreateNew(string name = null)
		{
			return CreateNew(TabularModelHandler.Singleton.Model, name);
		}


		/// <summary>
		/// Creates an exact copy of this NamedExpression object.
		/// </summary>
		public NamedExpression Clone(string newName = null) {
			if(TabularModelHandler.Singleton.UsePowerBIGovernance && !PowerBI.PowerBIGovernance.AllowCreate(typeof(NamedExpression))) {
				throw new InvalidOperationException(string.Format(Messages.CannotCreatePowerBIObject,typeof(NamedExpression).GetTypeName()));
			}

		    Handler.BeginUpdate("Clone NamedExpression");

			// Create a clone of the underlying metadataobject:
			var tom = MetadataObject.Clone() as TOM.NamedExpression;


			// Assign a new, unique name:
			tom.Name = Parent.Expressions.GetNewName(string.IsNullOrEmpty(newName) ? tom.Name + " copy" : newName);
				
			// Create the TOM Wrapper object, representing the metadataobject
			NamedExpression obj = CreateFromMetadata(Parent, tom);

            Handler.EndUpdate();

            return obj;
		}

		TabularNamedObject IClonableObject.Clone(string newName, bool includeTranslations, TabularNamedObject newParent) 
		{
			if (newParent != null) throw new ArgumentException("This object can not be cloned to another parent. Argument newParent should be left as null.", "newParent");
			return Clone(newName);
		}

	
        internal override void RenewMetadataObject()
        {
            Handler.WrapperLookup.Remove(MetadataObject);
            MetadataObject = MetadataObject.Clone() as TOM.NamedExpression;
            Handler.WrapperLookup.Add(MetadataObject, this);
        }

		public Model Parent { 
			get {
				return Handler.WrapperLookup[MetadataObject.Parent] as Model;
			}
		}



		/// <summary>
		/// CTOR - only called from static factory methods on the class
		/// </summary>
		NamedExpression(TOM.NamedExpression metadataObject) : base(metadataObject)
		{
			
			// Create indexer for annotations:
			Annotations = new AnnotationCollection(this);
			
			// Create indexer for extended properties:
			ExtendedProperties = new ExtendedPropertyCollection(this);
		}



		internal override void Undelete(ITabularObjectCollection collection) {
			base.Undelete(collection);
			Reinit();
			ReapplyReferences();
		}

		public override bool Browsable(string propertyName) {
			switch (propertyName) {
 
				case Properties.EXTENDEDPROPERTIES:
					return Handler.CompatibilityLevel >= 1400;
				case Properties.PARENT:
					return false;
				
				default:
					return base.Browsable(propertyName);
			}
		}

    }


	/// <summary>
	/// Collection class for NamedExpression. Provides convenient properties for setting a property on multiple objects at once.
	/// </summary>
	public sealed partial class NamedExpressionCollection: TabularObjectCollection<NamedExpression>
	{
		internal Model Model { get { return Parent as Model; } }
		TOM.NamedExpressionCollection TOM_Collection;
		internal NamedExpressionCollection(string collectionName, TOM.NamedExpressionCollection metadataObjectCollection, Model parent) : base(collectionName, parent)
		{
			TOM_Collection = metadataObjectCollection;
		}
		internal override Type GetItemType() { return typeof(NamedExpression); }
        protected override void TOM_Add(TOM.MetadataObject obj) { TOM_Collection.Add(obj as TOM.NamedExpression); }
        protected override bool TOM_Contains(TOM.MetadataObject obj) { return TOM_Collection.Contains(obj as TOM.NamedExpression); }
        protected override void TOM_Remove(TOM.MetadataObject obj) { TOM_Collection.Remove(obj as TOM.NamedExpression); }
        protected override void TOM_Clear() { TOM_Collection.Clear(); }
        protected override bool TOM_ContainsName(string name) { return TOM_Collection.ContainsName(name); }
        protected override TOM.MetadataObject TOM_Get(int index) { return TOM_Collection[index]; }
        protected override TOM.MetadataObject TOM_Get(string name) { return TOM_Collection[name]; }
        internal override string GetNewName(string prefix = null) { return string.IsNullOrEmpty(prefix) ? TOM_Collection.GetNewName() : TOM_Collection.GetNewName(prefix); }
        public override int IndexOf(TOM.MetadataObject obj) { return TOM_Collection.IndexOf(obj as TOM.NamedExpression); }
        public override int Count { get { return TOM_Collection.Count; } }
        public override IEnumerator<NamedExpression> GetEnumerator() { return TOM_Collection.Select(h => Handler.WrapperLookup[h]).OfType<NamedExpression>().GetEnumerator(); }
		internal override void Reinit() {
			var ixOffset = 0;
			for(int i = 0; i < Count; i++) {
				var item = this[i];
				Handler.WrapperLookup.Remove(item.MetadataObject);
				item.MetadataObject = Model.MetadataObject.Expressions[i + ixOffset] as TOM.NamedExpression;
				Handler.WrapperLookup.Add(item.MetadataObject, item);
				item.Collection = this;
			}
			TOM_Collection = Model.MetadataObject.Expressions;
			foreach(var item in this) item.Reinit();
		}

		internal override void ReapplyReferences() {
			foreach(var item in this) item.ReapplyReferences();
		}

		/// <summary>
		/// Calling this method will populate the NamedExpressionCollection with objects based on the MetadataObjects in the corresponding MetadataObjectCollection.
		/// </summary>
		internal override void CreateChildrenFromMetadata()
		{
			// Construct child objects (they are automatically added to the Handler's WrapperLookup dictionary):
			foreach(var obj in TOM_Collection) {
				if(obj is TOM.NamedExpression) NamedExpression.CreateFromMetadata(Model, obj as TOM.NamedExpression);
		    }
		}

		/// <summary>
		/// Sets the Description property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the Description property of all objects in the collection at once.")]
		public string Description {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("Description"));
				this.ToList().ForEach(item => { item.Description = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the Kind property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the Kind property of all objects in the collection at once.")]
		public ExpressionKind Kind {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("Kind"));
				this.ToList().ForEach(item => { item.Kind = value; });
				Handler.UndoManager.EndBatch();
			}
		}
		/// <summary>
		/// Sets the Expression property of all objects in the collection at once.
		/// </summary>
		[Description("Sets the Expression property of all objects in the collection at once.")]
		public string Expression {
			set {
				if(Handler == null) return;
				Handler.UndoManager.BeginBatch(UndoPropertyChangedAction.GetActionNameFromProperty("Expression"));
				this.ToList().ForEach(item => { item.Expression = value; });
				Handler.UndoManager.EndBatch();
			}
		}

		public override string ToString() {
			return string.Format("({0} {1})", Count, (Count == 1 ? "NamedExpression" : "Expressions").ToLower());
		}
	}
}